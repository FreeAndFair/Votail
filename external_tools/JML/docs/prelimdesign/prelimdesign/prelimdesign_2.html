<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 20  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Preliminary Design of JML: Class and Interface Specifications</TITLE>

<META NAME="description" CONTENT="Preliminary Design of JML: Class and Interface Specifications">
<META NAME="keywords" CONTENT="Preliminary Design of JML: Class and Interface Specifications">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_1.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_3.html#SEC49"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_7.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 2. Class and Interface Specifications </H1>
<!--docid::SEC11::-->
<P>

<A NAME="IDX208"></A>
<A NAME="IDX209"></A>
In this section we give some examples of JML class
specifications that illustrate the basic features of JML.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC12">2.1 Abstract Models</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC21">2.2 Data Groups</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC34">2.3 Types For Modeling</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC43">2.4 Use of Pure Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC44">2.5 Composition for Container Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC48">2.6 Behavioral Subtyping</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Abstract Models"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<H2> 2.1 Abstract Models </H2>
<!--docid::SEC12::-->
<P>

<A NAME="IDX210"></A>
<A NAME="IDX211"></A>
<A NAME="IDX212"></A>
A simple example of an abstract class specification is the ever-popular
<CODE>UnboundedStack</CODE> type,
which is presented below.
It would appear in a file named <TT>`UnboundedStack.java'</TT>.
</P><P>

<A NAME="IDX213"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.stacks;

//@ model import org.jmlspecs.models.*;

public abstract class UnboundedStack {

  /*@ public model JMLObjectSequence theStack;
    @ public initially theStack != null
    @                  &#38;&#38; theStack.isEmpty();
    @*/

  //@ public invariant theStack != null;

  /*@ public normal_behavior
    @   requires !theStack.isEmpty();
    @   assignable theStack;
    @   ensures theStack.equals(
    @              \old(theStack.trailer()));
    @*/
  public abstract void pop( );

  /*@ public normal_behavior
    @   assignable theStack;
    @   ensures theStack.equals(
    @              \old(theStack.insertFront(x)));
    @*/
  public abstract void push(Object x);

  /*@ public normal_behavior
    @   requires !theStack.isEmpty();
    @   assignable \nothing;
    @   ensures \result == theStack.first();
    @*/
  public /*@ pure @*/ abstract Object top( );
}
</pre></td></tr></table></P><P>

The above specification contains the declaration of a model field, an
invariant, and some method specifications.  These are described below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC13">2.1.1 Model Fields</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC14">2.1.2 Invariants</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC15">2.1.3 Method Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC20">2.1.4 Models and Lightweight Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Model Fields"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<H3> 2.1.1 Model Fields </H3>
<!--docid::SEC13::-->
<P>

<A NAME="IDX214"></A>
<A NAME="IDX215"></A>
In the fourth non-blank line of <TT>`UnboundedStack.java'</TT>,
a model data field, <CODE>theStack</CODE>,
is declared.
Since it is declared using the JML modifier <CODE>model</CODE>,
such a field is not part of the Java implementation, and must appear
in an annotation;
however, for purposes of the specification we treat it much like any other
Java field (i.e., as a variable location).
That is, we imagine that each instance of the class <CODE>UnboundedStack</CODE>
has such a field.
</P><P>

<A NAME="IDX216"></A>
<A NAME="IDX217"></A>
<A NAME="IDX218"></A>
<A NAME="IDX219"></A>
The type of the model field <CODE>theStack</CODE>
is a type designed for mathematical modeling,
<CODE>JMLObjectSequence</CODE>.
Objects of this type are sequences of objects.
This type is provided by JML in the package <CODE>org.jmlspecs.models</CODE>,
which is imported in the second non-blank line of the figure.
Note that this <CODE>import</CODE> declaration is not part of
the Java implementation, since it is modified by the keyword
<CODE>model</CODE>.
Such model imports must also appear in annotation comments.
In general, any declaration form in Java can have the <CODE>model</CODE> modifier,
with the same meaning.  That is, a model declaration is only
used for specification purposes, and does not have to appear in
an implementation.
</P><P>

<A NAME="IDX220"></A>
<A NAME="IDX221"></A>
<A NAME="IDX222"></A>
<A NAME="IDX223"></A>
<A NAME="IDX224"></A>
<A NAME="IDX225"></A>
<A NAME="IDX226"></A>
<A NAME="IDX227"></A>
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>
At the end of the model field's declaration
above
is an <CODE>initially</CODE> clause.
(Such clauses are adapted from RESOLVE <A HREF="prelimdesign_6.html#BIB66">[Ogden-etal94]</A>
and the refinement calculus
<A HREF="prelimdesign_6.html#BIB4">[Back88]</A> <A HREF="prelimdesign_6.html#BIB7">[Back-vonWright98]</A> <A HREF="prelimdesign_6.html#BIB62">[Morgan-Vickers94]</A> <A HREF="prelimdesign_6.html#BIB61">[Morgan94]</A>.)
Model fields cannot be explicitly initialized (and thus cannot be
final), because there is no storage directly associated with them.
However, one can use an <CODE>initially</CODE> clause to describe an
abstract initialization for a model field.
Initially clauses can be attached to any field declaration, including
non-model fields, and permit one to constrain the initial values
of such fields.
Knowing something about the initial value of the field
permits data type induction <A HREF="prelimdesign_6.html#BIB30">[Hoare72a]</A> <A HREF="prelimdesign_6.html#BIB85">[Wing83]</A>
for abstract classes and interfaces.
The <CODE>initially</CODE> clause must be true
of the field's starting value.
That is,
all reachable objects of the type <CODE>UnboundedStack</CODE>
must have been created
as empty stacks and subsequently modified using the type's methods.
</P><P>

<A NAME="Invariants"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<H3> 2.1.2 Invariants </H3>
<!--docid::SEC14::-->
<P>

<A NAME="IDX230"></A>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>
<A NAME="IDX233"></A>
Following the model field declaration is an invariant.
An invariant does not have to hold during the execution
of an object's methods,
but it must hold, for each reachable object
in each <EM>publicly visible state</EM>;
i.e., for each state outside of a public method or constructor's execution,
and at the beginning and end of each public method's
execution.<A NAME="DOCF9" HREF="prelimdesign_fot.html#FOOT9">(9)</A>
The figure's invariant just says that the value of <CODE>theStack</CODE>
should never be <CODE>null</CODE>.
</P><P>

<A NAME="Method Specifications"></A>
<HR SIZE="6">
<A NAME="SEC15"></A>
<H3> 2.1.3 Method Specifications </H3>
<!--docid::SEC15::-->
<P>

<A NAME="IDX234"></A>
Following the invariant are the specifications of
the methods <CODE>pop</CODE>, <CODE>push</CODE>, and <CODE>top</CODE>.
We describe the new aspects of these specifications below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC16">2.1.3.1 The Assignable Clause</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC17">2.1.3.2 Old Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC18">2.1.3.3 Reference Semantics</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC19">2.1.3.4 Correct Implementation</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="The Assignable Clause"></A>
<HR SIZE="6">
<A NAME="SEC16"></A>
<H4> 2.1.3.1 The Assignable Clause </H4>
<!--docid::SEC16::-->
<P>

<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>
<A NAME="IDX241"></A>
<A NAME="IDX242"></A>
The use of the <CODE>assignable</CODE><A NAME="DOCF10" HREF="prelimdesign_fot.html#FOOT10">(10)</A>  clauses in
the behavioral specifications of <CODE>pop</CODE> and <CODE>push</CODE>
<A NAME="IDX243"></A>
is interesting (and another difference from Eiffel).
<A NAME="IDX244"></A>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
These clauses give frame conditions <A HREF="prelimdesign_6.html#BIB10">[Borgida-Mylopoulos-Reiter95]</A>.
<A NAME="IDX247"></A>
In JML, the frame condition given by a method's assignable clause
only permits the method to assign to a location, <I>loc</I>, if:
<UL>
<LI>
<I>loc</I> is mentioned in the method's <CODE>assignable</CODE> clause,
<P>

<LI>
<I>loc</I> is a member of a data group mentioned in the 
method's <CODE>assignable</CODE> clause (see section <A HREF="prelimdesign_2.html#SEC21">2.2 Data Groups</A>),
<P>

<LI>
<I>loc</I> was not allocated when the method started execution, or
<P>

<LI>
<I>loc</I> is local to the method (i.e., a local variable, including the
method's formal parameters).
</UL>
For example, <CODE>push</CODE>'s specification says that it may only assign
to <CODE>theStack</CODE> (and locations in <CODE>theStack</CODE>'s data group).
This allows <CODE>push</CODE> to assign to <CODE>theStack</CODE> (and the members
of its data group), or to call some other method that makes such an
assignment.  Furthermore, <CODE>push</CODE> may assign to the formal
parameter <CODE>x</CODE> itself, even though that location is not listed in
the <CODE>assignable</CODE> clause, since <CODE>x</CODE> is local to the method.
However, <CODE>push</CODE> may not assign to fields not mentioned in the
<CODE>assignable</CODE> clause; in particular it may not assign to fields of
its formal parameter <CODE>x</CODE>,<A NAME="DOCF11" HREF="prelimdesign_fot.html#FOOT11">(11)</A>  or call a method that makes such an
assignment.
<P>

<A NAME="IDX248"></A>
The design of JML is intended to allow tools to statically check the
body of a method's implementation to determine whether its
<CODE>assignable</CODE> clause is satisfied.  This would be done by checking
each assignment statement in the implementation to see if what is
being assigned to is a location that some <CODE>assignable</CODE> clause
permits.  It is an error to assign to any other allocated, non-local
location.  However, to do this, a tool must conservatively track
aliases and changes to objects containing the locations in question.
Also, arrays can only be dynamically checked, in general.<A NAME="DOCF12" HREF="prelimdesign_fot.html#FOOT12">(12)</A>  Furthermore, JML will flag as an error a call to a method
that would assign to locations that are not permitted by the calling
method's <CODE>assignable</CODE> clause.  It can do this using the
<CODE>assignable</CODE> clause of the called method.
</P><P>

<A NAME="IDX249"></A>
<A NAME="IDX250"></A>
<A NAME="IDX251"></A>
In JML, a location is <EM>modified</EM> by a method when it is allocated
in both the pre-state of the method, reachable in the post-state, and
has a value that is different in these two states.  The
<EM>pre-state</EM> of a method call is the state just after the method is
called and parameters have been evaluated and passed, but before
execution of the method's body.  The <EM>post-state</EM> of a method call
is the state just before the method returns or throws an exception; in
JML we imagine that <CODE>\result</CODE> and information about exception
results is recorded in the post-state.
</P><P>

<A NAME="IDX252"></A>
<A NAME="IDX253"></A>
Since modification only involves objects allocated in the pre-state,
allocation of an object, using Java's <CODE>new</CODE> operator, does not
itself cause any modification.  Furthermore, since the fields of new
objects are locations that were not allocated when the method started
execution, they may be assigned to freely.
</P><P>

<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
The reason assignments to local variables are permitted by the
assignable clause is that a JML specification takes the client's
(i.e., the caller's) point of view.  From the client's point of view,
the local variables in a method are newly-allocated, and thus
assignments to such variables are invisible to the client.  Hence, in
JML, it is an error to list the locations corresponding to formal
parameters in the <CODE>assignable</CODE> clause.
However, the locations corresponding to fields or array elements of
such formal parameters can be sensibly mentioned in 
the <CODE>assignable</CODE> clause.
Furthermore, when formal
parameters are used in a postcondition, JML interprets these as
meaning the value initially given to the formal in the pre-state,
since assignments to the formals within the method do not matter to
the client.
</P><P>

<A NAME="IDX256"></A>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>
<A NAME="IDX259"></A>
<A NAME="IDX260"></A>
JML's interpretation of the assignable clause does not permit
either temporary side effects or benevolent side effects.
A method with a <EM>temporary side effect</EM> assigns to a location,
does some work, and then assigns the original value back to that location.
In JML, a method may not have temporary side effects
on locations that it is not permitted to modify
<A HREF="prelimdesign_6.html#BIB72">[Ruby-Leavens00]</A>.
A method has a <EM>benevolent side effect</EM>
if it assigns to a location in a way that is not observable by clients.
In JML, a method may not have benevolent side effects on locations
that it is not permitted to modify  <A HREF="prelimdesign_6.html#BIB47">[Leino95]</A> <A HREF="prelimdesign_6.html#BIB46">[Leino95a]</A>.
</P><P>

<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
Because JML's assignable clauses give permission
to assign to locations, it is safe for clients to assume that
only the listed locations (and locations of their data group members)
may have their values modified.
Because locations listed in the <CODE>assignable</CODE> clause are the only
ones that can be modified, we often speak of what locations a method can
"modify," instead of the more precise "can assign to."
</P><P>

<A NAME="IDX263"></A>
<A NAME="IDX264"></A>
<A NAME="IDX265"></A>
What does the assignable clause say about the modification of locations?
In particular, although the "location" for a model field
or model variable cannot be directly assigned to in JML,
its value is determined by the concrete fields and variables
that it (ultimately) depends on, specifically the members of its 
data group. 
That is, a model field or variable can be modified by assignments
to the concrete members of its data group (see section <A HREF="prelimdesign_2.html#SEC21">2.2 Data Groups</A>). 
Thus, a method's assignable clause only
permits the method to modify a location if the location:
<UL>
<LI>
is mentioned in the method's <CODE>assignable</CODE> clause,
<P>

<LI>
is a member of a data group mentioned in the <CODE>assignable</CODE> 
clause (see section <A HREF="prelimdesign_2.html#SEC21">2.2 Data Groups</A>),
<P>

<LI>
was not allocated when the method started execution, or
<P>

<LI>
is local to the method.
</UL>
<P>

<A NAME="IDX266"></A>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
In the specification of <CODE>top</CODE>,
the assignable clause says that a call to <CODE>top</CODE> that satisfies
the precondition cannot assign to any locations.
It does this by using the <A HREF="#store-ref"><VAR>store-ref</VAR></A> "<CODE>\nothing</CODE>."
Unlike some formal specification languages (including Larch BISLs and
older versions of JML),
when the <CODE>assignable</CODE> clause is omitted in a heavyweight
specification, the default <A HREF="#store-ref"><VAR>store-ref</VAR></A> for the assignable 
clause is <CODE>\everything</CODE>. 
Thus an omitted assignable clause in JML means that the method can assign 
to all locations (that could otherwise be assigned to by the method). 
Such an assignable clause plays havoc with formal
reasoning, and thus if one cares about verification, one should give
an assignable clause explicitly if the method is not pure
(see section <A HREF="prelimdesign_2.html#SEC35">2.3.1 Purity</A>).
</P><P>

<A NAME="Old Values"></A>
<HR SIZE="6">
<A NAME="SEC17"></A>
<H4> 2.1.3.2 Old Values </H4>
<!--docid::SEC17::-->
<P>

<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>
When a method can modify some locations, they may have different
values in the pre-state and post-state of a call.
Often the post-condition must refer to the values held
in both of these states.
JML uses a notation similar to Eiffel's to refer
to the pre-state value of a variable.
In JML the syntax is <CODE>\old(</CODE><I>E</I><CODE>)</CODE>, where <I>E</I> is an expression.
(Unlike Eiffel, we use parentheses following <CODE>\old</CODE>
to delimit the expression to be evaluated in the pre-state explicitly.
JML also uses backslashes (<CODE>\\</CODE>) to mark the keywords it uses in
expressions; this avoids interfering with Java program identifiers,
such as "<CODE>old</CODE>".)
</P><P>

<A NAME="IDX274"></A>
<A NAME="IDX275"></A>
The meaning of <CODE>\old(</CODE><I>E</I><CODE>)</CODE> is as if <I>E</I> were evaluated
in the pre-state and that value is used in place of
<CODE>\old(</CODE><I>E</I><CODE>)</CODE> in the assertion.
It follows that, an expression like <CODE>\old(myVar).theStack</CODE>
may not mean what is desired,
since only the old value of <CODE>myVar</CODE> is saved;
access to the field <CODE>theStack</CODE> is done in the post-state.
If it is the field, <CODE>theStack</CODE>, not the variable, <CODE>myVar</CODE>,
that is changing, then probably
what is desired is <CODE>\old(myVar.theStack)</CODE>.
To avoid such problems, it is good practice to have the expression <I>E</I>
in <CODE>\old(</CODE><I>E</I><CODE>)</CODE>
be such that its type is either the type of a primitive value,
such as an <CODE>int</CODE>, or a type with immutable objects,
such as <CODE>JMLObjectSequence</CODE>.
</P><P>

As another example, in <CODE>pop</CODE>'s postcondition
the expression <CODE>\old(theStack.trailer())</CODE>
has type <CODE>JMLObjectSequence</CODE>, so it is immutable.
The value of <CODE>theStack.trailer()</CODE> is computed
in the pre-state of the method.
</P><P>

<A NAME="Reference Semantics"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<H4> 2.1.3.3 Reference Semantics </H4>
<!--docid::SEC18::-->
<P>

<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
Note also that, since <CODE>JMLObjectSequence</CODE> is a reference type,
one must use <CODE>equals</CODE> instead of <CODE>==</CODE> to compare
instances of this type for equality of values.  For example, in
the postcondition of the <CODE>pop</CODE> method, we use <CODE>equals</CODE>
to compare <CODE>theStack</CODE> and <CODE>\old(theStack.trailer())</CODE>,
as these may yield different objects.
Using <CODE>==</CODE> would be a mistake, since it would only compare them
for object identity.
</P><P>

<A NAME="IDX280"></A>
<A NAME="IDX281"></A>
<A NAME="IDX282"></A>
<A NAME="IDX283"></A>
<A NAME="IDX284"></A>
As in Java itself, most types are reference types, and hence many expressions
yield references (i.e., object identities or addresses),
as opposed to primitive values.
This means that <CODE>==</CODE>, except when used to compare
pure values of primitive types such as <CODE>boolean</CODE> or <CODE>int</CODE>,
is reference equality.
As in Java,
to get value equality for reference types one uses the
<CODE>equals</CODE> method in assertions.
For example, the predicate
<CODE>myString == yourString</CODE>, is only true if
the objects denoted by <CODE>myString</CODE> and <CODE>yourString</CODE> are the
same object (i.e., if the names are aliases);
to compare their values one must write
<CODE>myString.equals(yourString)</CODE>.
</P><P>

<A NAME="Correct Implementation"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<H4> 2.1.3.4 Correct Implementation </H4>
<!--docid::SEC19::-->
<P>

<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
<A NAME="IDX290"></A>
<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>
<A NAME="IDX294"></A>
<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
<A NAME="IDX297"></A>
The specification of <CODE>push</CODE> does not have a <CODE>requires</CODE>
clause.
This means that the method imposes no obligations on the caller.
(The meaning of an omitted <CODE>requires</CODE> clause
is that the method's precondition is <CODE>true</CODE>, which
is satisfied by all states, and hence imposes no obligations on the caller.)
This seems to imply that the implementation must provide
a literally unbounded stack, which is surely impossible.
We avoid this problem, by following Poetzsch-Heffter <A HREF="prelimdesign_6.html#BIB69">[Poetzsch-Heffter97]</A>
in releasing implementations from their obligations
to fulfill the postcondition when Java runs out of storage.
In general, a method specified with <CODE>normal_behavior</CODE>
has a correct implementation if,
whenever it is called in a state that satisfies
its precondition, either
<UL>
<LI>
the method terminates normally in a state that satisfies its postcondition,
having assigned to only the locations permitted by its <CODE>assignable</CODE>
clause, or
<P>

<LI>
Java signals an error,
by throwing an exception that inherits from <CODE>java.lang.Error</CODE>.
</UL>
We discuss the specification of methods with exceptions in the next
subsection.
<P>

<A NAME="Models and Lightweight Specifications"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<H3> 2.1.4 Models and Lightweight Specifications </H3>
<!--docid::SEC20::-->
<P>

<A NAME="IDX298"></A>
<A NAME="IDX299"></A>
<A NAME="IDX300"></A>
<A NAME="IDX301"></A>
In specifying existing code, one often does not want to introduce new
model fields or think up new names for them.  And sometimes,
especially for fields with simple, atomic values, the field name
itself is so "natural" that it would be difficult to think up a second
good name for a model field that would be an abstraction of it.
Thus JML provides two modifiers, <CODE>spec_public</CODE> and
<CODE>spec_protected</CODE> that can used to make existing fields public or
protected, for purposes of specification.
</P><P>

For example, consider the (lightweight) specification of the class
<CODE>Point2D</CODE> below.  In this specification the private fields,
<CODE>x</CODE> and <CODE>y</CODE> are specified as <CODE>spec_public</CODE>, which
allows them to be used in the public invariant clause and in the
(implicitly public) specifications of the constructors and methods of
<CODE>Point2D</CODE>. 
</P><P>

<A NAME="IDX302"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

//@ model import org.jmlspecs.models.JMLDouble;

public class Point2D
{
  private /*@ spec_public @*/ double x = 0.0;
  private /*@ spec_public @*/ double y = 0.0;

  //@ public invariant !Double.isNaN(x);
  //@ public invariant !Double.isNaN(y);
  //@ public invariant !Double.isInfinite(x);
  //@ public invariant !Double.isInfinite(y);

  //@ ensures x == 0.0 &#38;&#38; y == 0.0;
  public Point2D() { }

  /*@ requires !Double.isNaN(xc);
    @ requires !Double.isNaN(yc);
    @ requires !Double.isInfinite(xc);
    @ requires !Double.isInfinite(yc);
    @ assignable x, y;
    @ ensures x == xc &#38;&#38; y == yc;
    @*/
  public Point2D(double xc, double yc) {
    x = xc;
    y = yc;
  }

  //@ ensures \result == x;
  public /*@ pure @*/ double getX() {
    return x;
  }

  //@ ensures \result == y;
  public /*@ pure @*/ double getY() {
    return y;
  }
  
  /*@ requires !Double.isNaN(x+dx);
    @ requires !Double.isInfinite(x+dx);
    @ assignable x;
    @ ensures JMLDouble.approximatelyEqualTo(x,
    @                       \old(x+dx), 1e-10);
    @*/
  public void moveX(double dx) {
    x += dx;
  }
  
  /*@ requires !Double.isNaN(y+dy);
    @ requires !Double.isInfinite(y+dy);
    @ assignable y;
    @ ensures JMLDouble.approximatelyEqualTo(y,
    @                       \old(y+dy), 1e-10);
    @*/
  public void moveY(double dy) {
    y += dy;
  }
}
</pre></td></tr></table></P><P>

Note that these specifications would be illegal without the use of
<CODE>spec_public</CODE>, since JML requires that public specifications only
mention publicly-visible names
(see section <A HREF="prelimdesign_1.html#SEC2">1.1 Behavioral Interface Specification</A>).
</P><P>

<A NAME="IDX303"></A>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>
<A NAME="IDX306"></A>
However, <CODE>spec_public</CODE> is more than just a way to change the
visibility of a name for specification purposes.  When applied to
fields it can be considered to be shorthand for the declaration of a
model field with the same name.  That is, the declaration of <CODE>x</CODE>
in <CODE>Point2D</CODE> can be thought of as equivalent to the following
declarations, together with a rewrite of the Java code that uses <CODE>x</CODE> to
use <CODE>_x</CODE> instead (where we assume <CODE>_x</CODE> is not used elsewhere).
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  //@ public model int x;
  private int _x; //@ in x;
  //@ private represents x &#60;- _x;
</pre></td></tr></table></P><P>

So in this way of thinking <CODE>spec_public</CODE> is not
just an access modifier, but shorthand for declaration of a model
field.  This model field declaration is a commitment to readers that
they can understand the specification using these model fields, even
if the underlying private fields are changed, just as if the model
field were declared explicitly.
The model fields that are implicit allow such changes to be made without
affecting the readers of the specification.
</P><P>

For example, suppose one wanted to change the implementation of
<CODE>Point2D</CODE>, to use polar coordinates.
To do that while keeping the public specification
unchanged, one would declare the model fields <CODE>x</CODE> and <CODE>y</CODE>
explicitly.  One would then declare other fields for the polar and
rectangular coordinates (and perhaps additional model fields as well).
One would then also need to give explicit declarations that the new
concrete fields are members of the model fields data groups, and give
appropriate represents clauses.  
(See section <A HREF="prelimdesign_2.html#SEC29">2.2.2.1 Data Groups and Represents Clauses</A>, for more on data group
membership and represents clauses.)
All of this is exactly analogous to what is done implicitly in the the
desugaring described above. 
</P><P>

Similar remarks apply to <CODE>spec_protected</CODE>.  The
<CODE>spec_public</CODE> and <CODE>spec_protected</CODE> shorthands were borrowed
from ESC/Java, but the desugaring described above is novel with JML.
</P><P>

<A NAME="Data Groups"></A>
<HR SIZE="6">
<A NAME="SEC21"></A>
<H2> 2.2 Data Groups </H2>
<!--docid::SEC21::-->
<P>

<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
<A NAME="IDX309"></A>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>
In this subsection we present two example specifications.
The two example specifications,
<CODE>BoundedThing</CODE> and <CODE>BoundedStackInterface</CODE>,
are used to describe how model (and concrete) fields can be related
to one another, and how dependencies among them affect the meaning
of the <CODE>assignable</CODE> clause.
Along the way we also demonstrate how to specify methods
that can throw exceptions and other features of JML.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC22">2.2.1 Specification of BoundedThing</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC28">2.2.2 Specification of BoundedStackInterface</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Specification of BoundedThing"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<H3> 2.2.1 Specification of BoundedThing </H3>
<!--docid::SEC22::-->
<P>

<A NAME="IDX312"></A>
The specification in the file <TT>`BoundedThing.java'</TT>,
shown below, is an interface specification
with a simple abstract model.
In this case, there are two model fields <CODE>MAX_SIZE</CODE>
and <CODE>size</CODE>.
</P><P>

<A NAME="IDX313"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.stacks;

public interface BoundedThing {

    //@ public model instance int MAX_SIZE;
    //@ public model instance int size;

    /*@ public instance invariant MAX_SIZE &#62; 0;
        public instance invariant
                0 &#60;= size &#38;&#38; size &#60;= MAX_SIZE;
        public instance constraint
                MAX_SIZE == \old(MAX_SIZE);
      @*/

    /*@  public normal_behavior
           ensures \result == MAX_SIZE;
      @*/
    public /*@ pure @*/ int getSizeLimit();

    /*@  public normal_behavior
           ensures \result &#60;==&#62; size == 0;
      @*/
    public /*@ pure @*/ boolean isEmpty();

    /*@  public normal_behavior
          ensures \result &#60;==&#62; size == MAX_SIZE;
      @*/
    public /*@ pure @*/ boolean isFull();

    /*@ also
         public behavior
           assignable \nothing;
           ensures \result instanceof BoundedThing
               &#38;&#38; size == ((BoundedThing)\result).size;
           signals_only CloneNotSupportedException;
      @*/
    public Object clone ()
       throws CloneNotSupportedException;
}
</pre></td></tr></table></P><P>

After discussing the model fields, we describe the other parts
of the specification below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC23">2.2.1.1 Model Fields in Interfaces</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC24">2.2.1.2 Invariants and History Constraint</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC25">2.2.1.3 Details of the Method Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC26">2.2.1.4 Adding to Method Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC27">2.2.1.5 Specifying Exceptional Behavior</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Model Fields in Interfaces"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<H4> 2.2.1.1 Model Fields in Interfaces </H4>
<!--docid::SEC23::-->
<P>

<A NAME="IDX314"></A>
<A NAME="IDX315"></A>
In the specification above,
the fields <CODE>MAX_SIZE</CODE> and <CODE>size</CODE> 
are both declared using the modifier <CODE>instance</CODE>.
Because of the use of the keyword <CODE>instance</CODE>,
these fields are thus treated as normal model fields,
i.e., as an instance variable in each object that implements this interface.
By default, as in Java, fields are static in interfaces,
and so if <CODE>instance</CODE> is omitted, the field declarations
would be treated as class variables.
The <CODE>instance</CODE> keyword tells the reader
that the variable being declared is not
static, but has a copy in each instance of a class that implements this
interface.
</P><P>

Java does not allow non-static fields to be declared in interfaces.
However,  JML allows non-static model (and ghost) fields in interfaces
when one uses <CODE>instance</CODE>.
The reason for this extension is that such fields
are essential for defining the abstract values and behavior of
the objects being specified.<A NAME="DOCF13" HREF="prelimdesign_fot.html#FOOT13">(13)</A>
</P><P>

In specifications of interfaces that extend
or classes that implement this interface,
these model fields are inherited.
Thus, every object that has a type that is a subtype of the
<CODE>BoundedThing</CODE> interface is thought of, abstractly,
as having two fields, <CODE>MAX_SIZE</CODE> and <CODE>size</CODE>,
both of type <CODE>int</CODE>.
</P><P>

<A NAME="Invariants and History Constraint"></A>
<HR SIZE="6">
<A NAME="SEC24"></A>
<H4> 2.2.1.2 Invariants and History Constraint </H4>
<!--docid::SEC24::-->
<P>

<A NAME="IDX316"></A>
Three pieces of class-level specification come after the abstract model
in the above specification.
</P><P>

<A NAME="IDX317"></A>
<A NAME="IDX318"></A>
The first two are <CODE>invariant</CODE> clauses.
Writing several invariant clauses in a specification, like this
is equivalent to writing one invariant clause which is their
conjunction.
Both of these invariants are instance invariants,
because they use the <CODE>instance</CODE> modifier.
By default, in interfaces, invariants and history constraints are
static, unless marked with the <CODE>instance</CODE> modifier.
Static invariants may only refer to static fields, while instance
invariants can refer to both instance and static fields.
</P><P>

The first invariant in the figure says that in every publicly visible state,
every reachable object that is a <CODE>BoundedThing</CODE>
must have a positive <CODE>MAX_SIZE</CODE> field.
The second invariant says that, in each publicly visible state,
every reachable object that is a <CODE>BoundedThing</CODE> must have a size
field that is non-negative and less than or equal to <CODE>MAX_SIZE</CODE>.
</P><P>

<A NAME="IDX319"></A>
<A NAME="IDX320"></A>
<A NAME="IDX321"></A>
<A NAME="IDX322"></A>
<A NAME="IDX323"></A>
<A NAME="IDX324"></A>
<A NAME="IDX325"></A>
<A NAME="IDX326"></A>
Following the invariants is a history constraint <A HREF="prelimdesign_6.html#BIB53">[Liskov-Wing94]</A>.
Like the invariants, it uses the modifier <CODE>instance</CODE>,
because it refers to instance fields.
A history constraint is used to say how values can change between earlier
and later publicly-visible states, 
such as a method's pre-state and its post-state.
This prohibits subtype objects from making certain state changes, even
if they implement more methods than are specified in a given class.
The history constraint in the specification above
says that the value of <CODE>MAX_SIZE</CODE> cannot change,
since in every pre-state and post-state, its value in the post-state,
written <CODE>MAX_SIZE</CODE>, must equal its value in the pre-state,
written <CODE>\old(MAX_SIZE)</CODE>.
</P><P>

<A NAME="Details of the Method Specifications"></A>
<HR SIZE="6">
<A NAME="SEC25"></A>
<H4> 2.2.1.3 Details of the Method Specifications </H4>
<!--docid::SEC25::-->
<P>

<A NAME="IDX327"></A>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
Following the history constraint are the interfaces and specifications
for four public methods.  Notice that, if desired,
the at-signs (<CODE>@</CODE>) may be omitted from the left sides
of intermediate lines, as we do in this specification.
</P><P>

<A NAME="IDX330"></A>
<A NAME="IDX331"></A>
The use of <CODE>==</CODE> in the method specifications
is okay, since in each case, the things being compared are primitive values,
not references.
The notation <CODE>&#60;==&#62;</CODE> can be read "if and only if".  It has the same
meaning for Boolean  values as <CODE>==</CODE>, but has a lower precedence.
Therefore, the expression "<CODE>\result <==> size == 0</CODE>"
in the postcondition of the <CODE>isEmpty</CODE> method means the same
thing as "<CODE>\result == (size == 0)</CODE>".
</P><P>

<A NAME="Adding to Method Specifications"></A>
<HR SIZE="6">
<A NAME="SEC26"></A>
<H4> 2.2.1.4 Adding to Method Specifications </H4>
<!--docid::SEC26::-->
<P>

<A NAME="IDX332"></A>
<A NAME="IDX333"></A>
<A NAME="IDX334"></A>
<A NAME="IDX335"></A>
<A NAME="IDX336"></A>
<A NAME="IDX337"></A>
The specification of the last method of <CODE>BoundedThing</CODE>,
<CODE>clone</CODE>, is interesting.
Note that it begins with the keyword <CODE>also</CODE>.
This form is intended to tell the reader that the specification given is
in addition to any specification that might have been given in the superclass
<CODE>Object</CODE>, where <CODE>clone</CODE> is declared as a protected
method.
A form like this must be used whenever a specification is given for a
method that overrides a method in a superclass, or that implements a
method from an implemented interface.
</P><P>

<A NAME="Specifying Exceptional Behavior"></A>
<HR SIZE="6">
<A NAME="SEC27"></A>
<H4> 2.2.1.5 Specifying Exceptional Behavior </H4>
<!--docid::SEC27::-->
<P>

<A NAME="IDX338"></A>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>
<A NAME="IDX341"></A>
<A NAME="IDX342"></A>
The specification of <CODE>clone</CODE>
also uses <CODE>behavior</CODE> instead of <CODE>normal_behavior</CODE>.
In a specification that starts this way, one can describe
not just the case where the execution returns normally, but also
executions where exceptions are thrown.
In such a specification, the conditions under
which exceptions can be thrown can be described by the predicate in the
<CODE>signals</CODE> clauses,<A NAME="DOCF14" HREF="prelimdesign_fot.html#FOOT14">(14)</A>
and the conditions under which the method may return without throwing
an exception are described by the <CODE>ensures</CODE> clause. 
In this specification, the <CODE>clone</CODE>
method may always throw the exception, because it only needs to make
the predicate "<CODE>true</CODE>" true to do so.
When the method returns normally, it must make the given postcondition
true.
</P><P>

<A NAME="IDX343"></A>
<A NAME="IDX344"></A>
In JML, a <CODE>normal_behavior</CODE> specification can be thought of as a
syntactic sugar for a <CODE>behavior</CODE> specification to which the
following clause is added <A HREF="prelimdesign_6.html#BIB70">[Raghavan-Leavens05]</A>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     signals (java.lang.Exception) false;
</pre></td></tr></table></P><P>

This formalizes the idea that a method with a <CODE>normal_behavior</CODE>
specification may not throw an exception
when the specification's precondition is satisfied.
</P><P>

<A NAME="IDX345"></A>
<A NAME="IDX346"></A>
<A NAME="IDX347"></A>
JML also has a specification form <CODE>exceptional_behavior</CODE>,
which can be used to specify when a method may not return normally.
A specification that uses <CODE>exceptional_behavior</CODE> can be thought of as a
syntactic sugar for a <CODE>behavior</CODE> specification to which the
following clause is added <A HREF="prelimdesign_6.html#BIB70">[Raghavan-Leavens05]</A>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     ensures false;
</pre></td></tr></table></P><P>

This formalizes the idea that a method with an <CODE>exceptional_behavior</CODE>
specification may not return normally
when the specification's precondition is satisfied.
Thus, when the precondition of such a specification case holds,
some exception must be thrown (unless the execution encounters an
error or is permitted to not return to the caller).
</P><P>

<A NAME="IDX348"></A>
Since, in the specification of <CODE>clone</CODE>, we want to allow the
implementation to make a choice between either returning normally or
throwing an exception, and we do not wish to distinguish the
preconditions under which each choice must be made,
we cannot use either of the more specialized
forms <CODE>normal_behavior</CODE> or <CODE>exceptional_behavior</CODE>.
Thus the specification of <CODE>clone</CODE>
demonstrates the somewhat unusual case when
the more general form of a <CODE>behavior</CODE> specification is needed.
</P><P>

<A NAME="IDX349"></A>
<A NAME="IDX350"></A>
<A NAME="IDX351"></A>
<A NAME="IDX352"></A>
The specification of <CODE>clone</CODE> also illustrates the
<CODE>signals_only</CODE> clause.
The <CODE>signals_only</CODE> clause in the example says that the method may
only throw an exception that is a subtype of
<CODE>CloneNotSupportedException</CODE> when the exceptional behavior's
precondition is true.  This says the same thing as the following,
more verbose, signals clause.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     signals (Exception e) e instanceof CloneNotSupportedException;
</pre></td></tr></table></P><P>

The signals clause itself only describes what must be true when
the exceptions it applies to are thrown; it does not constrain a
method's behavior with respect to exceptions that are not subtypes of
the exceptions named.  For example, a <CODE>signals</CODE> clause of the
form
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    signals (CloneNotSupportedException) true;
</pre></td></tr></table></P><P>

would only say that a <CODE>CloneNotSupportedException</CODE> can always be thrown;
it would not prohibit other exceptions
that are not subtypes of <CODE>CloneNotSupportedException</CODE> from being
thrown.
For example, if <CODE>clone</CODE> were specified with such a signals
clause, then an implementation could legally throw a
<CODE>NullPointerException</CODE>.  To prevent such a possibility, in many
cases it is preferable to use a <CODE>signals_only</CODE> clause to limit
what exceptions may be thrown. 
</P><P>

<A NAME="IDX353"></A>
<A NAME="IDX354"></A>
<A NAME="IDX355"></A>
<A NAME="IDX356"></A>
Finally note that in the specification of <CODE>clone</CODE>,
the normal postcondition says that the result will be a <CODE>BoundedThing</CODE>
and that its size will be the same as the model field <CODE>size</CODE>.
The use of the cast in this postcondition is necessary,
since the type of <CODE>\result</CODE> is <CODE>Object</CODE>.
(This also adheres to our goal of using Java syntax and
semantics to the extent possible.)
Note also that the conjunct <CODE>\result instanceof BoundedThing</CODE>
"protects" the next conjunct <A HREF="prelimdesign_6.html#BIB44">[Leavens-Wing97a]</A>
since if it is false the meaning of the cast does not matter.
</P><P>

<A NAME="Specification of BoundedStackInterface"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<H3> 2.2.2 Specification of BoundedStackInterface </H3>
<!--docid::SEC28::-->
<P>

<A NAME="IDX357"></A>
<A NAME="IDX358"></A>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
The specification in the file <TT>`BoundedStackInterface.java'</TT> below
gives an interface for bounded stacks
that extends the interface for <CODE>BoundedThing</CODE>.
Note that this specification can refer to the instance fields
<CODE>MAX_SIZE</CODE> and <CODE>size</CODE> inherited from the
<CODE>BoundedThing</CODE> interface.
</P><P>

<A NAME="IDX362"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.stacks;
//@ model import org.jmlspecs.models.*;
public interface BoundedStackInterface extends BoundedThing {
    //@ public initially theStack != null &#38;&#38; theStack.isEmpty();
  /*@ public model instance JMLObjectSequence theStack;
    @                                             in size;
    @*/
  //@ public instance represents size &#60;- theStack.int_length();
  /*@ public instance invariant theStack != null;
    @ public instance invariant_redundantly
    @                           theStack.int_length() &#60;= MAX_SIZE;
    @ public instance invariant 
    @         (\forall int i; 0 &#60;= i &#38;&#38; i &#60; theStack.int_length();
    @                         theStack.itemAt(i) != null);
    @*/

  /*@   public normal_behavior
    @     requires !theStack.isEmpty();
    @     assignable size, theStack;
    @     ensures theStack.equals(\old(theStack.trailer()));
    @ also
    @   public exceptional_behavior
    @     requires theStack.isEmpty();
    @     assignable \nothing;
    @     signals_only BoundedStackException;
    @*/
  public void pop( ) throws BoundedStackException;

  /*@   public normal_behavior
    @     requires theStack.int_length() &#60; MAX_SIZE &#38;&#38; x != null;
    @     assignable size, theStack;
    @     ensures theStack.equals(\old(theStack.insertFront(x)));
    @     ensures_redundantly theStack != null &#38;&#38; top() == x
    @              &#38;&#38; theStack.int_length() 
    @                     == \old(theStack.int_length()+1);
    @ also
    @   public exceptional_behavior
    @     requires theStack.int_length() &#62;= MAX_SIZE || x == null;
    @     assignable \nothing;
    @     signals_only BoundedStackException, NullPointerException;
    @     signals (BoundedStackException)
    @                  theStack.int_length() == MAX_SIZE;
    @     signals (NullPointerException) x == null;
    @*/
  public void push(Object x )
         throws BoundedStackException, NullPointerException;

  /*@   public normal_behavior
    @     requires !theStack.isEmpty();
    @     ensures \result == theStack.first() &#38;&#38; \result != null;
    @ also
    @   public exceptional_behavior
    @     requires theStack.isEmpty();
    @     signals_only BoundedStackException;
    @     signals (BoundedStackException e)
    @             \fresh(e) &#38;&#38; e != null &#38;&#38; e.getMessage() != null
    @           &#38;&#38; e.getMessage().equals("empty stack");
    @*/
  public /*@ pure @*/ Object top( ) throws BoundedStackException;
}
</pre></td></tr></table></P><P>

The abstract model for <CODE>BoundedStackInterface</CODE> adds to the inherited
model by declaring a model instance field named <CODE>theStack</CODE>.
This field is typed as a <CODE>JMLObjectSequence</CODE>.
</P><P>

In the following we describe how the new model instance field,
<CODE>theStack</CODE>, is related to <CODE>size</CODE> from <CODE>BoundedThing</CODE>.
We also use this example to explain more JML features.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC29">2.2.2.1 Data Groups and Represents Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC30">2.2.2.2 Redundant Specification</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC31">2.2.2.3 Multiple Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC32">2.2.2.4 Pitfalls in Specifying Exceptions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC33">2.2.2.5 Redundant Ensures Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Data Groups and Represents Clauses"></A>
<HR SIZE="6">
<A NAME="SEC29"></A>
<H4> 2.2.2.1 Data Groups and Represents Clauses </H4>
<!--docid::SEC29::-->
<P>

<A NAME="IDX363"></A>
<A NAME="IDX364"></A>
<A NAME="IDX365"></A>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
<A NAME="IDX368"></A>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>
The <CODE>in</CODE> and <CODE>represents</CODE> clauses
that follow the declaration of <CODE>theStack</CODE>
are an important feature in modeling
with layers of model fields.<A NAME="DOCF15" HREF="prelimdesign_fot.html#FOOT15">(15)</A>
They also play a crucial role in relating model fields
to the concrete fields of objects,
which can be considered to be the final layer of detail in a design.
</P><P>

<A NAME="IDX374"></A>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>
<A NAME="IDX378"></A>
When a model field is declared, a data group with the same name is 
automatically created; 
furthermore, this field is always a <EM>member of</EM> the group it creates.
A <EM>data group</EM> is a set of fields (locations) referenced by 
a specific name, i.e., the name of the model field that created it
<A HREF="prelimdesign_6.html#BIB48">[Leino98]</A> <A HREF="prelimdesign_6.html#BIB50">[Leino-Poetzsch-Heffter-Zhou02]</A>.
</P><P>

<A NAME="IDX379"></A>
<A NAME="IDX380"></A>
<A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>
<A NAME="IDX386"></A>
When a data group (or field) is mentioned in the <CODE>assignable</CODE> clause 
for a method <CODE>M</CODE>, then all members (i.e., fields) in that group 
can be assigned to in the body of <CODE>M</CODE>. 
Fields can become a <EM>member of</EM> a data group through the 
data group clauses (i.e., the <CODE>in</CODE> and <CODE>maps-into</CODE> clauses) that 
come immediately after the field declaration, in this case 
the <CODE>in</CODE> clause. 
The <CODE>in</CODE> clause in <CODE>BoundedStackInterface</CODE>
says that <CODE>theStack</CODE> is a member of the group created by 
the declaration of model field <CODE>size</CODE>;
this means that <CODE>theStack</CODE> 
might change its value whenever <CODE>size</CODE> changes.
However, another way of looking at this is that,
if one wants to change <CODE>size</CODE>, this can be done by
changing <CODE>theStack</CODE>.
We also say that <CODE>theStack</CODE> is a <EM>member of</EM> <CODE>size</CODE>.
</P><P>

<A NAME="IDX387"></A>
<A NAME="IDX388"></A>
The <A HREF="#maps-into"><VAR>maps-into</VAR></A> clause is another way of adding members to a data 
group; it allows the fields of an object to 
be included in an existing data group.
For example, if a field <CODE>F</CODE> is a reference or an array type, 
then the fields or array elements of <CODE>F</CODE> can be included in a 
data group using the <A HREF="#maps-into"><VAR>maps-into</VAR></A> clause.  
The following are examples.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  protected ArrayList elems;
  //@             maps elems.theList \into theStack;
  protected java.lang.Object[] theItems;
  //@             maps theItems[*] \into theStack;
</pre></td></tr></table></P><P>

In the first example, the <CODE>maps-into</CODE> clause says that 
<CODE>theList</CODE> field of 
<CODE>elems</CODE> is a member of <CODE>theStack</CODE> data group. 
Field <CODE>elems</CODE> is a <EM>concrete</EM> field of the type 
(i.e., it is not a model field and thus is part of the implementation).  
This allows model field <CODE>theList</CODE> of <CODE>elems</CODE> to change when 
<CODE>theStack</CODE> changes.  
Since <CODE>theList</CODE> is a model field and data group, this also allows
concrete fields of <CODE>elems</CODE> to change as <CODE>theStack</CODE> changes.  
Similarly, the second example says that the elements of the array,
<CODE>theItems</CODE>, can change when <CODE>theStack</CODE> changes.  
</P><P>

Data groups have the same visibility as the model field that declared it, 
i.e, public, protected, private, or package visibility. 
A field cannot be a member of a group that is less visible than it is. 
For example, a public field cannot be a member of a 
protected group.  
</P><P>

<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>
<A NAME="IDX396"></A>
The <CODE>in</CODE> and <A HREF="#maps-into"><VAR>maps-into</VAR></A> clauses are important in "loosening up" 
the <CODE>assignable</CODE> clause, for example to permit the fields of an object
that implement the abstract model to be changed
<A HREF="prelimdesign_6.html#BIB47">[Leino95]</A> <A HREF="prelimdesign_6.html#BIB46">[Leino95a]</A>.
This "loosening up" also applies to model fields
that are members of other groups.
For example, since <CODE>theStack</CODE> is a member of <CODE>size</CODE>, 
whenever <CODE>size</CODE> is mentioned in an <CODE>assignable</CODE> clause,
then <CODE>theStack</CODE> is implicitly allowed to be modified.<A NAME="DOCF16" HREF="prelimdesign_fot.html#FOOT16">(16)</A>
Thus it is only for rhetorical purposes that
we mention both <CODE>size</CODE> and <CODE>theStack</CODE>
in the assignable clauses of <CODE>pop</CODE> and <CODE>push</CODE>.
Note, however, that just mentioning <CODE>theStack</CODE> would not permit
<CODE>size</CODE> to be modified, because <CODE>size</CODE> is not a member of 
<CODE>theStack</CODE>'s group. 
Furthermore, it is redundant to mention <CODE>theStack</CODE> when 
<CODE>size</CODE> has already been mentioned (although this can help clarify 
the <CODE>assignable</CODE> clause, i.e., clarify which fields can be changed). 
</P><P>

<A NAME="IDX397"></A>
The <CODE>represents</CODE> clause in <CODE>BoundedStackInterface</CODE>
says how the value of <CODE>size</CODE> is related
to the value of <CODE>theStack</CODE>.
It says that the value of <CODE>size</CODE> is <CODE>theStack.length()</CODE>.
</P><P>

<A NAME="IDX398"></A>
A represents clause gives additional facts that can be used
in reasoning about the specification.
It serves the same purpose as an abstraction function in various
proof methods for abstract data types (such as <A HREF="prelimdesign_6.html#BIB30">[Hoare72a]</A>).
</P><P>

One can only use a represents clause to state facts about a field
and its data group members.
To state relationships among concrete data fields
or on fields that are not related by a data group membership,
one should use an invariant.
</P><P>

<A NAME="Redundant Specification"></A>
<HR SIZE="6">
<A NAME="SEC30"></A>
<H4> 2.2.2.2 Redundant Specification </H4>
<!--docid::SEC30::-->
<P>

<A NAME="IDX399"></A>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>
<A NAME="IDX405"></A>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>
The second <CODE>invariant</CODE> clause
that follows the <CODE>represents</CODE> clause
in the specification of <CODE>BoundedStackInterface</CODE> above
is our first example of checkable redundancy in a specification
<A HREF="prelimdesign_6.html#BIB41">[Leavens-Baker99]</A> <A HREF="prelimdesign_6.html#BIB77">[Tan94]</A> <A HREF="prelimdesign_6.html#BIB78">[Tan95]</A>.
This concept is signaled in JML by the use of the suffix <CODE>_redundantly</CODE>
on a keyword (as in <CODE>ensures_redundantly</CODE>).
It says both that the stated property is specified to hold
and that this property is believed to follow from the other
properties of the specification.
In this case the redundant invariant follows from the given invariant,
the invariant inherited from the specification of <CODE>BoundedThing</CODE>,
and the fact stated in the <CODE>represents</CODE> clause.
Even though this invariant is redundant,
it is sometimes helpful to state such properties, to bring them
to the attention of the readers of the specification.
</P><P>

<A NAME="IDX408"></A>
<A NAME="IDX409"></A>
Checking that such claimed redundancies really do follow from
other information is also a good way to make sure that what is being specified
is really what is intended.
Such checks could be done manually, during reviews, or with the aid
of a theorem prover.
JML's runtime assertion checker can also check such redundant
specifications, but, of course, can only find examples where they do
not hold.
</P><P>

<A NAME="Multiple Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<H4> 2.2.2.3 Multiple Specification Cases </H4>
<!--docid::SEC31::-->
<P>

<A NAME="IDX410"></A>
<A NAME="IDX411"></A>
<A NAME="IDX412"></A>
After the redundant invariant of <CODE>BoundedStackInterface</CODE>
are the specifications of
the <CODE>pop</CODE>, <CODE>push</CODE>, and <CODE>top</CODE> methods.
These are interesting for several new features that they present.
Each of these has both a normal and exceptional behavior specified.
The meaning of such multiple <EM>specification cases</EM> is that,
when the precondition of one of them is satisfied,
the rest of that specification case must also be obeyed.
</P><P>

<A NAME="IDX413"></A>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>
<A NAME="IDX419"></A>
<A NAME="IDX420"></A>
<A NAME="IDX421"></A>
<A NAME="IDX422"></A>
<A NAME="IDX423"></A>
A specification with several specification cases
is shorthand for one in which the
separate specifications are combined
<A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A> <A HREF="prelimdesign_6.html#BIB38">[Leavens97c]</A> <A HREF="prelimdesign_6.html#BIB85">[Wing83]</A> <A HREF="prelimdesign_6.html#BIB82">[Wills94]</A>.
The desugaring can be thought of as proceeding in two steps
(see <A HREF="prelimdesign_6.html#BIB70">[Raghavan-Leavens05]</A> for more details).
First, the <CODE>public normal_behavior</CODE> and <CODE>public exceptional_behavior</CODE>
cases are converted into <CODE>public behavior</CODE> specifications as explained above.
This would produce a specification for <CODE>pop</CODE> as shown below.
The use of <CODE>implies_that</CODE> introduces a redundant specification
that can be used, as is done here,
to point out consequences of the specification to the reader.
<A NAME="IDX424"></A>
In this case the specification in question is the one mentioned in the
<CODE>refine</CODE> clause.
Note that in the second specification case of the figure below, 
the default signals clause has been added.
This clause was omitted from the original specification, since no
particular details of the exception object were important to the specifier.
</P><P>

<A NAME="IDX425"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>//@ refine "BoundedStackInterface.java";

public interface BoundedStackInterface extends BoundedThing {
  /*@ also
    @ implies_that
    @   public behavior
    @     requires !theStack.isEmpty();
    @     assignable size, theStack;
    @     ensures theStack.equals(\old(theStack.trailer()));
    @     signals (java.lang.Exception) false;
    @  also
    @   public behavior
    @     requires theStack.isEmpty();
    @     assignable \nothing;
    @     ensures false;
    @     signals_only BoundedStackException;
    @     signals (java.lang.Exception) true;
    @*/
  public void pop( ) throws BoundedStackException;
}    
</pre></td></tr></table></P><P>

<A NAME="IDX426"></A>
<A NAME="IDX427"></A>
The second step of the desugaring is shown
below.
As can be seen from this example,
<CODE>public behavior</CODE> specifications that are joined together using <CODE>also</CODE>
have a precondition that is the disjunction of the preconditions
of the combined specification cases.
The <CODE>assignable</CODE> clause for the expanded specification
is the union of all the assignable clauses for the cases.
To compensate for this, the predicate <CODE>\not_assigned</CODE>, is used in
the exceptional behavior specification cases to prohibit assignment to
the locations (those in the data groups of <CODE>size</CODE> and <CODE>theStack</CODE>)
that are now part of the assignable clause.
The ensures clauses of the second desugaring step correspond to
the ensures clauses for each specification case;
they say that whenever the precondition for that specification case held
in the pre-state, its postcondition must also hold.
As can be seen in the specification below,
in logic this is written using an implication between
<CODE>\old</CODE> wrapped around the case's precondition and its postcondition.
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>
<A NAME="IDX431"></A>
Having multiple ensures clauses is equivalent to writing
a single ensures clause that has as its postcondition the conjunction
of the given postconditions.
Similarly, the signals clauses in the desugaring correspond to
those in the given specification cases;
as for the ensures clauses, each has a predicate that
says that signaling that exception can only happen
when the predicate in that case's precondition holds.
</P><P>

<A NAME="IDX432"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>//@ refine "BoundedStackInterface.jml";
public interface BoundedStackInterface extends BoundedThing {
  /*@ also
    @ implies_that
    @   public behavior
    @     requires !theStack.isEmpty() || theStack.isEmpty();
    @     assignable size, theStack;
    @     ensures \old(!theStack.isEmpty())
    @               ==&#62; theStack.equals(\old(theStack.trailer()));
    @     ensures \old(theStack.isEmpty()) ==&#62; 
    @                 \not_assigned(size) &#38;&#38; \not_assigned(theStack);
    @     signals_only BoundedStackException;
    @     signals (java.lang.Exception)
    @              \old(!theStack.isEmpty()) ==&#62; false;
    @     signals (java.lang.Exception)
    @              \old(theStack.isEmpty()) ==&#62;
    @               \not_assigned(size) &#38;&#38; \not_assigned(theStack)
    @               &#38;&#38; true;
    @*/
  public void pop( ) throws BoundedStackException;
}
</pre></td></tr></table></P><P>

In the file <TT>`BoundedStackInterface.refines-java'</TT> above,
the precondition of <CODE>pop</CODE> reduces to <CODE>true</CODE>.
However, the precondition shown is the general form of the expansion.
Similar remarks apply to other predicates.
</P><P>

<A NAME="IDX433"></A>
<A NAME="IDX434"></A>
Finally, note how, as in the specification of <CODE>top</CODE>,
one can specify more details about the exception object thrown.
The exceptional behavior for <CODE>top</CODE> says that the exception object
thrown, <CODE>e</CODE>, must be freshly allocated, non-null, and have the
given message.
</P><P>

<A NAME="Pitfalls in Specifying Exceptions"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<H4> 2.2.2.4 Pitfalls in Specifying Exceptions </H4>
<!--docid::SEC32::-->
<P>

<A NAME="IDX435"></A>
<A NAME="IDX436"></A>
<A NAME="IDX437"></A>
<A NAME="IDX438"></A>
<A NAME="IDX439"></A>
<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
A particularly interesting example of multiple specification cases occurs
in the specification of the <CODE>BoundedStackInterface</CODE>'s <CODE>push</CODE> method.
Like the other methods, this example has two specification cases;
one of these is a <CODE>normal_behavior</CODE>
and one is an <CODE>exceptional_behavior</CODE>.
However, the exceptional behavior of <CODE>push</CODE> is interesting
because it specifies more than one exception that may be thrown.
The requires clause of the exceptional behavior says that
an exception must be thrown when either the stack cannot grow larger,
or when the argument <CODE>x</CODE> is null.
The first signals clause says that, if a <CODE>BoundedStackException</CODE>
is thrown, then the stack cannot grow larger,
and the second signals clause says that, if a <CODE>NullPointerException</CODE>
is thrown, then <CODE>x</CODE> must be null.
The specification is written in this way because it may be that
<EM>both</EM> conditions occur;
when that is the case, the specification allows the implementation to choose
(even nondeterministically) which exception is thrown.
</P><P>

<A NAME="IDX442"></A>
<A NAME="IDX443"></A>
<A NAME="IDX444"></A>
Specifiers should be wary of such situations, where two different
signals clauses may both apply simultaneously, because it is impossible in
Java to throw more than one exception from a method call.  Thus, for
example, if the specification of <CODE>push</CODE> had been written as
follows, it would not be implementable.<A NAME="DOCF17" HREF="prelimdesign_fot.html#FOOT17">(17)</A>
The problem is that both exceptional preconditions may be true,
and in that case an implementation cannot throw an exception that is
an instance of both a <CODE>BoundedStackException</CODE> and a
<CODE>NullPointerException</CODE>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  /*@   public normal_behavior
    @     requires theStack.length() &#60; MAX_SIZE &#38;&#38; x != null;
    @     assignable size, theStack;
    @     ensures theStack.equals(\old(theStack.insertFront(x)));
    @     ensures_redundantly theStack != null &#38;&#38; top() == x
    @              &#38;&#38; theStack.length() == \old(theStack.length()+1);
    @ also
    @   public exceptional_behavior
    @     requires theStack.length() &#62;= MAX_SIZE;
    @     assignable \nothing;
    @     signals (Exception e) e instanceof BoundedStackException;
    @ also                                   // this is wrong!
    @   public exceptional_behavior
    @     requires x == null;
    @     assignable \nothing;
    @     signals (Exception e) e instanceof NullPointerException;
    @*/
  public void push(Object x )
         throws BoundedStackException, NullPointerException;
</pre></td></tr></table></P><P>

One could fix the example above by writing one of the requires clauses
in the two exceptional behaviors to exclude the other, although this
would make the specification deterministic about which exception
would be thrown when both exceptional conditions occur.  In general, it
seems best to avoid this pitfall by writing signals clauses
that do not exclude other exceptions from being thrown whenever there
are states in which multiple exceptions may be thrown.
That is, instead of using multiple <CODE>signals_only</CODE> clauses or
using multiple <CODE>signals</CODE> clauses like:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   signals (Exception e) e instanceof BoundedStackException;
</pre></td></tr></table>which only allows a <CODE>BoundedStackException</CODE> to be thrown when the
precondition is true, one can write a signals clause like:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   signals (BoundedStackException);
</pre></td></tr></table>which says nothing about what happens when other exceptions are thrown
(see section <A HREF="prelimdesign_2.html#SEC27">2.2.1.5 Specifying Exceptional Behavior</A> for more details).
</P><P>

<A NAME="Redundant Ensures Clauses"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<H4> 2.2.2.5 Redundant Ensures Clauses </H4>
<!--docid::SEC33::-->
<P>

<A NAME="IDX445"></A>
<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
<A NAME="IDX448"></A>
Finally, there is more redundancy in the specifications of <CODE>push</CODE>
in the original specification of <CODE>BoundedStackInterface</CODE> above,
which has a redundant <CODE>ensures</CODE> clause in its normal behavior.
For an <CODE>ensures_redundantly</CODE> clause,
what one checks is that the conjunction
of the precondition, the meaning of the <CODE>assignable</CODE> clause, and the
(non-redundant) postcondition together imply the redundant postcondition.
It is interesting to note that,
for <CODE>push</CODE>, the specifications for stacks written in
Eiffel (see page 339 of <A HREF="prelimdesign_6.html#BIB60">[Meyer97]</A>) expresses just what we specify
in <CODE>push</CODE>'s redundant postcondition.
This conveys strictly less information than the non-redundant
postcondition for <CODE>push</CODE>'s normal behavior,
since it says little about the elements of the stack.<A NAME="DOCF18" HREF="prelimdesign_fot.html#FOOT18">(18)</A>
</P><P>

In summary, using types like <CODE>JMLObjectSequence</CODE> for modeling can
help the specifier give more precise specifications.  We describe more
about such types in the next section.
</P><P>

<A NAME="Types For Modeling"></A>
<HR SIZE="6">
<A NAME="SEC34"></A>
<H2> 2.3 Types For Modeling </H2>
<!--docid::SEC34::-->
<P>

<A NAME="IDX449"></A>
<A NAME="IDX450"></A>
<A NAME="IDX451"></A>
<A NAME="IDX452"></A>
<A NAME="IDX453"></A>
JML comes with a suite of types with immutable objects and pure
methods, that can be used for defining abstract models.
These are found in the package
<CODE>org.jmlspecs.models</CODE>,
which includes both collection and non-collection types
(such as <CODE>JMLInteger</CODE>)
and a few auxiliary classes (such as exceptions and enumerators).
</P><P>

<A NAME="IDX454"></A>
<A NAME="IDX455"></A>
The collection types in this package can hold either objects or values;
this distinction determines the notion of equality used on their
elements and whether cloning is done on the elements.
The object collections, such as <CODE>JMLObjectSet</CODE>
and <CODE>JMLObjectBag</CODE>, use <CODE>==</CODE> and do not clone.
The value collections, such as <CODE>JMLValueSet</CODE>
and <CODE>JMLValueBag</CODE>, use <CODE>.equals</CODE> to compare elements,
and clone the objects added to and returned from them.
The objects in a value collection are representatives of equivalence
classes (under <CODE>.equals</CODE>) of objects; their values matter, but not
their object identities.  By contrast an object container contains
object identities, and the values in these objects do not matter.
</P><P>

<A NAME="IDX456"></A>
<A NAME="IDX457"></A>
Simple collection types include
the set types, <CODE>JMLObjectSet</CODE> and <CODE>JMLValueSet</CODE>,
and sequence types <CODE>JMLObjectSequence</CODE> and <CODE>JMLValueSequence</CODE>.
The binary relation and map types can independently have objects in their
domain or range.
The binary relation types are named
<CODE>JMLObjectToObjectRelation</CODE>, <CODE>JMLObjectToValueRelation</CODE>,
and so on.
For example, <CODE>JMLObjectToValueRelation</CODE> is a type of binary
relations between objects (not cloned and compared using <CODE>==</CODE>)
and values (which are cloned and compared using <CODE>.equals</CODE>).
The four map types are similarly named according to the scheme
<CODE>JML...To...Map</CODE>.
</P><P>

<A NAME="IDX458"></A>
<A NAME="IDX459"></A>
<A NAME="IDX460"></A>
Users can also create their own types with pure methods for
mathematical modeling if desired.
Since pure methods may be used in assertions,
they must be declared with the modifier <CODE>pure</CODE>
and pass certain conservative checks that make sure there is no
possibility of observable side-effects from their use.
We discuss purity and give several examples of such types below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC35">2.3.1 Purity</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC36">2.3.2 Money</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC39">2.3.3 MoneyComparable and MoneyOps</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC40">2.3.4 MoneyAC</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC41">2.3.5 MoneyComparableAC</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC42">2.3.6 USMoney</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Purity"></A>
<HR SIZE="6">
<A NAME="SEC35"></A>
<H3> 2.3.1 Purity </H3>
<!--docid::SEC35::-->
<P>

<A NAME="IDX461"></A>
<A NAME="IDX462"></A>
We say a method
is <EM>pure</EM> if it is either specified with
the modifier <CODE>pure</CODE> or is a method that
appears in the specification of a <CODE>pure</CODE> interface or class.
Similarly, a constructor is pure if it is either specified with
the modifier <CODE>pure</CODE> or appears in the specification of a <CODE>pure</CODE>
class.
</P><P>

A <EM>pure method</EM>, that is not a constructor,
implicitly has a specification that does not allow any side-effects.
That is, its specification
has the clauses
<TABLE><tr><td>&nbsp;</td><td class=example><pre>           diverges false;
           assignable \nothing;
</pre></td></tr></table>added to each specification case; if the method has no specification
given explicitly, then these clauses are added as a lightweight specification.
For this reason, if one is writing a pure method, it is not necessary
to otherwise specify an assignable clause
(see section <A HREF="prelimdesign_2.html#SEC16">2.1.3.1 The Assignable Clause</A>), although doing so may improve the
specification's clarity.
</P><P>

<A NAME="IDX463"></A>
<A NAME="IDX464"></A>
A <EM>pure constructor</EM> has the clauses
<TABLE><tr><td>&nbsp;</td><td class=example><pre>           diverges false;
           assignable this.*;
</pre></td></tr></table>added to each specification case; if the constructor has no specification
given explicitly, then these clauses are added as a lightweight specification.
This specification allows the constructor to assign to the non-static
fields of the class in which it appears (including those inherited
from its superclasses and model and ghost instance fields from the interfaces
that it implements).
</P><P>

<A NAME="IDX465"></A>
<A NAME="IDX466"></A>
Implementations of pure methods and constructors
will be checked to see that they meet these conditions; i.e., that
pure methods do not assign to locations that exist in the pre-state, and
that pure constructors only assign to pre-existing locations that
are fields of the <CODE>this</CODE> object.
To make such checking modular, some JML tools prohibit a pure method
or constructor implementation from calling methods or constructors
that are not pure.  However, more sophisticated tools could more
directly check the intended semantics <A HREF="prelimdesign_6.html#BIB73">[Salcianu-Rinard05]</A>.
</P><P>

<A NAME="IDX467"></A>
A pure method or constructor must also be provably terminating.
Although JML does not force users to make such proofs of termination,
users writing pure methods and constructors are supposed to make pure
methods total in the sense that whenever, a pure method is called it either
returns normally or throws some exception.
This is supposed to lessen the possibility that assertion evaluation
could loop forever, help make pure methods more like mathematical functions,
and help the runtime assertion checker.
The runtime assertion checker turns
exceptions into arbitrary values of the appropriate result type
<A HREF="prelimdesign_6.html#BIB13">[Cheon03]</A> <A HREF="prelimdesign_6.html#BIB16">[Cheon-Leavens05]</A>;
it cannot do anything with infinite loops.
</P><P>

<A NAME="IDX468"></A>
Furthermore, a pure method is supposed to always either terminate
normally or throw an exception, even for calls that do not satisfy its
precondition.  Static verification
tools for JML should enforce this condition, by requiring a proof
that a pure method implementation satisfies the following
specification
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   private behavior
     requires true;
     diverges false;
     assignable \nothing;
</pre></td></tr></table>(and similarly for constructors, except that the assignable clause
becomes <CODE>assignable this.*;</CODE> for constructors).
</P><P>

However, this implicit verification condition is a
specification, and is thus cannot be used in reasoning about
calls to the method, even calls from within the class itself and recursive
calls from within the implementation.
For this reason we recommend writing the method or constructor
specification in such a way that the effective precondition of the
method is "true," making the proof of the above implicit verification
condition trivial, and allowing the
termination behavior of the implementation to be relied upon by all clients.
</P><P>

<A NAME="IDX469"></A>
Recursion is permitted, both in the implementation of pure methods
and the data structures they manipulate, and in the specifications of
pure methods.
When recursion is used in a specification,
the proof of well-formedness for the specification
involves the use of JML's <CODE>measured_by</CODE> clause.
</P><P>

Since a pure method may not go into an infinite loop,
if it has a non-trivial precondition, it should throw an exception
when its normal precondition is not met.
This exceptional behavior does not have to be specified or programmed
explicitly, but technically there is an obligation to meet the specification
that the method never loops forever.
</P><P>

<A NAME="IDX470"></A>
<A NAME="IDX471"></A>
Furthermore, a pure method must be deterministic, in
the sense that when called in a given state, it must always return the
same value.  Similarly a pure constructor should be deterministic in
the sense that when called in a given state, it always initializes the
object in the same way.
</P><P>

A pure method can be declared in any class or interface,
and a pure constructor can be declared in any class.
JML will specify the pure methods and constructors
in the standard Java libraries as pure.
</P><P>

<A NAME="IDX472"></A>
As a convenience, instead of writing <CODE>pure</CODE> on each
method declared in a class and interface,
one can use the modifier <CODE>pure</CODE> on classes and
interfaces.
This simply means that each non-static method and each constructor
declared in such a class or interface is <CODE>pure</CODE>.
Note that this does not mean that all methods inherited (but not
declared in and hence not overridden in) the class or interface are
pure.
For example, every class inherits ultimately from
<CODE>java.lang.Object</CODE>,
which has some methods, such as <CODE>notify</CODE> and <CODE>notifyAll</CODE>
that are manifestly not pure.
Thus each class will have some methods that are not pure.
Despite this, it is convenient to refer to classes and interfaces declared
with the <CODE>pure</CODE> modifier as <EM>pure</EM>.
</P><P>

<A NAME="IDX473"></A>
<A NAME="IDX474"></A>
In JML the modifiers <CODE>model</CODE> and <CODE>pure</CODE>
are orthogonal.  (Recall something declared with
the modifier <CODE>model</CODE> does not have to be
implemented, and is used purely for specification purposes.)
Therefore, one can have a model method
that is not pure (these might be useful in JML's model programs);
conversely, a Java method can be pure (and thus not a model method).
Nevertheless, usually a model method (or constructor) should be pure,
since there is no way to use non-pure methods in an assertion,
and model methods cannot be used in normal Java code.
</P><P>

<A NAME="IDX475"></A>
<A NAME="IDX476"></A>
By the same reasoning, model classes should, in
general, also be pure.
Model classes cannot be used in normal Java code, and hence their
methods are only useful in assertions (and JML's model programs).
Hence it is typical, although not required, that a model class also be
a pure class.
We give some examples of pure interfaces, abstract classes, and classes below.
</P><P>

<A NAME="Money"></A>
<HR SIZE="6">
<A NAME="SEC36"></A>
<H3> 2.3.2 Money </H3>
<!--docid::SEC36::-->
<P>

The following example begins a specification of money
that would be suitable for use in abstract models.
Our specification is rather artificially broken up into pieces
to allow each piece to have a specification that fits on a page.
This organization is not necessarily something we would recommend,
but it does give us a chance to illustrate more features of JML.
</P><P>

Consider first the interface <CODE>Money</CODE>
specified below.
The abstract model here is a single field
of the primitive Java type <CODE>long</CODE>,
which holds a number of pennies.
Note that the declaration of this field, <CODE>pennies</CODE>,
again uses the JML keyword <CODE>instance</CODE>.
</P><P>

<A NAME="IDX477"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

import org.jmlspecs.models.JMLType;

public /*@ pure @*/ interface Money extends JMLType
{
  //@ public model instance long pennies;

  //@ public instance constraint pennies == \old(pennies);

  /*@     public normal_behavior
    @       assignable \nothing;
    @       ensures \result == pennies / 100;
    @ for_example
    @     public normal_example
    @       requires pennies == 703;
    @       assignable \nothing;
    @       ensures \result == 7;
    @   also
    @     public normal_example
    @       requires pennies == 799;
    @       assignable \nothing;
    @       ensures \result == 7;
    @   also
    @     public normal_example
    @       requires pennies == -503;
    @       assignable \nothing;
    @       ensures \result == -5;
    @*/
  public long dollars();

  /*@   public normal_behavior
    @     assignable \nothing;
    @     ensures \result == pennies % 100;
    @ for_example
    @     requires pennies == 703;
    @     assignable \nothing;
    @     ensures \result == 3;
    @   also
    @     requires pennies == -503;
    @     assignable \nothing;
    @     ensures \result == -3;
    @*/
  public long cents();

  /*@ also
    @   public normal_behavior
    @     assignable \nothing;
    @     ensures \result
    @        &#60;==&#62; o2 instanceof Money
    @             &#38;&#38; pennies == ((Money)o2).pennies;
    @*/
  public boolean equals(/*@ nullable @*/ Object o2);

  /*@ also
    @   public normal_behavior
    @     assignable \nothing;
    @     ensures \result instanceof Money
    @       &#38;&#38; ((Money)\result).pennies == pennies;
    @*/
  public Object clone();
}
</pre></td></tr></table></P><P>

<A NAME="IDX478"></A>
This interface has a history constraint, which says that the number
of pennies in an object cannot change.<A NAME="DOCF19" HREF="prelimdesign_fot.html#FOOT19">(19)</A>
</P><P>

The following explain more aspects of JML related to the above specification.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC37">2.3.2.1 Redundant Examples</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC38">2.3.2.2 JMLType and Informal Predicates</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Redundant Examples"></A>
<HR SIZE="6">
<A NAME="SEC37"></A>
<H4> 2.3.2.1 Redundant Examples </H4>
<!--docid::SEC37::-->
<P>

<A NAME="IDX479"></A>
<A NAME="IDX480"></A>
<A NAME="IDX481"></A>
<A NAME="IDX482"></A>
<A NAME="IDX483"></A>
The interesting aspect of <CODE>Money</CODE>'s method specifications is another kind of redundancy.
This new form of redundancy is examples,
which follow the keyword "<CODE>for_example</CODE>".
</P><P>

<A NAME="IDX484"></A>
<A NAME="IDX485"></A>
<A NAME="IDX486"></A>
Individual examples
are given by <CODE>normal_example</CODE> clauses
(adapted from our previous work on Larch/C++ <A HREF="prelimdesign_6.html#BIB37">[Leavens96b]</A> <A HREF="prelimdesign_6.html#BIB41">[Leavens-Baker99]</A>).
Any number of these<A NAME="DOCF20" HREF="prelimdesign_fot.html#FOOT20">(20)</A> 
can be given in a specification.
In the specification of <CODE>Money</CODE> above
there are three normal examples given for <CODE>dollars</CODE>
and two in the specification of <CODE>cents</CODE>.
</P><P>

<A NAME="IDX487"></A>
The specification in each example should be such that:
<UL>
<LI>
the example's precondition implies
the precondition of the expanded meaning of the specified behaviors,
<P>

<LI>
the example's assignable clause
specifies a subset of the locations that are assignable
according to the expanded meaning of the specified behaviors, and
<P>

<LI>
assuming the example's assignable clause,
the conjunction of:
<UL>
<LI>
the example's precondition (wrapped by <CODE>\old()</CODE>),
<P>

<LI>
the precondition of the expanded meaning of the specified behaviors
(also wrapped by <CODE>\old()</CODE>),
and
<P>

<LI>
the postcondition of the expanded meaning of the specified behaviors
</UL>
should be equivalent to the example's postcondition.
</UL>
Requiring equivalence to the example's postcondition
means that it can serve as a test oracle for the
inputs described by the example's precondition.
If there is only one specified <CODE>public normal_behavior</CODE> clause
and if there are no preconditions and assignable clauses,
then the example's postcondition should the equivalent to
the conjunction of the example's precondition
and the postcondition of the <CODE>public normal_behavior</CODE> specification.
Typically, examples are concrete, and serve to make various rhetorical
points about the use of the specification to the reader.
(Exercise: check all the examples given!)
<P>

<A NAME="JMLType and Informal Predicates"></A>
<HR SIZE="6">
<A NAME="SEC38"></A>
<H4> 2.3.2.2 JMLType and Informal Predicates </H4>
<!--docid::SEC38::-->
<P>

<A NAME="IDX488"></A>
<A NAME="IDX489"></A>
<A NAME="IDX490"></A>
<A NAME="IDX491"></A>
The interface <CODE>Money</CODE> is specified to extend the interface
<CODE>JMLType</CODE>.
This interface is given below.
Classes that implement this interface must
have pure <CODE>equals</CODE> and <CODE>clone</CODE> methods
with the specified behavior.
The methods specified override methods in the class
<CODE>Object</CODE>, and so they use the form of specification
that begins with the keyword "<CODE>also</CODE>".
</P><P>

<A NAME="IDX492"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.models;

/** Objects with a clone and equals method.
 * JMLObjectType and JMLValueType are refinements
 * for object and value containers (respectively).
 * @version $Revision: 1.20 $
 * @author Gary T. Leavens and Albert L. Baker.
 * @see JMLObjectType
 * @see JMLValueType
 */
//@ pure
public interface JMLType extends Cloneable, java.io.Serializable {

    /** Return a clone of this object. */
    /*@ also
      @   public normal_behavior
      @     ensures \result != null;
      @     ensures \result instanceof JMLType;
      @     ensures ((JMLType)\result).equals(this);
      @*/
    //@ implies_that
    /*@    ensures \result != null
      @        &#38;&#38; \typeof(\result) &#60;: \type(JMLType);
      @*/
    public /*@ pure @*/ Object clone();    

    /** Test whether this object's value is equal to the given argument.
     */
    /*@ also
      @   public normal_behavior
      @     ensures \result ==&#62;
      @             ob2 != null
      @             &#38;&#38; (* ob2 is not distinguishable from this,
      @                   except by using mutation or == *);
      @ implies_that
      @   public normal_behavior
      @   {|
      @      requires ob2 != null &#38;&#38; ob2 instanceof JMLType;
      @      ensures ((JMLType)ob2).equals(this) == \result;
      @    also
      @      requires ob2 == this;
      @      ensures \result &#60;==&#62; true;
      @   |}
      @*/
    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object ob2);    

    /** Return a hash code for this object. */
    public /*@ pure @*/ int hashCode();
}
</pre></td></tr></table></P><P>

<A NAME="IDX493"></A>
<A NAME="IDX494"></A>
<A NAME="IDX495"></A>
<A NAME="IDX496"></A>
<A NAME="IDX497"></A>
<A NAME="IDX498"></A>
The specification of <CODE>JMLType</CODE> 
is noteworthy in its use of informal predicates <A HREF="prelimdesign_6.html#BIB37">[Leavens96b]</A>.
In JML these start with an open parenthesis and an asterisk (`<CODE>(*</CODE>')
and continue until a matching asterisk and closing parenthesis (`<CODE>*)</CODE>').
In the public specification of <CODE>equals</CODE>,
the <CODE>normal_behavior</CODE>'s <CODE>ensures</CODE> clause
uses an informal predicate as an escape from formality.
The use of informal predicates avoids the delicate issues of saying
formally what observable aliasing means,
and what equality of values means in general.<A NAME="DOCF21" HREF="prelimdesign_fot.html#FOOT21">(21)</A>
</P><P>

<A NAME="IDX499"></A>
<A NAME="IDX500"></A>
<A NAME="IDX501"></A>
<A NAME="IDX502"></A>
<A NAME="IDX503"></A>
<A NAME="IDX504"></A>
<A NAME="IDX505"></A>
In the <CODE>implies_that</CODE> section of the specification of the
<CODE>equals</CODE> method is a nested case analysis, between <CODE>{|</CODE>
and <CODE>|}</CODE>. The meaning of this is that each pre- and postcondition
pair has to be obeyed.  The first of these nested pairs is essentially
saying that <CODE>equals</CODE> has to be symmetric.  The second of these is
saying that it has to be reflexive.
</P><P>

The <CODE>implies_that</CODE> section of the <CODE>clone</CODE> method states
some implications of the specification given that are useful for 
ESC/Java.  These repeat, from the first part of <CODE>clone</CODE>'s
specification, that the result must not be null, and that
the result's dynamic type, <CODE>\typeof(\result)</CODE>,
must be a subtype of (written <CODE>&#60;:</CODE>) the type <CODE>JMLType</CODE>.
</P><P>

<A NAME="MoneyComparable and MoneyOps"></A>
<HR SIZE="6">
<A NAME="SEC39"></A>
<H3> 2.3.3 MoneyComparable and MoneyOps </H3>
<!--docid::SEC39::-->
<P>

The type <CODE>Money</CODE> lacks some useful operations.
The extensions below
provide specifications of comparison operations and arithmetic, respectively.
</P><P>

<A NAME="IDX506"></A>
<A NAME="IDX507"></A>
<A NAME="IDX508"></A>
<A NAME="IDX509"></A>
The specification in file <TT>`MoneyComparable.java'</TT> is interesting because
each of the specified preconditions protects the postcondition from
undefinedness in the postcondition <A HREF="prelimdesign_6.html#BIB44">[Leavens-Wing97a]</A>.
For example, if the argument <CODE>m2</CODE> in the <CODE>greaterThan</CODE>
method were <CODE>null</CODE>, then the expression <CODE>m2.pennies</CODE> would
not be defined.
</P><P>

<A NAME="IDX510"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public /*@ pure @*/ interface MoneyComparable extends Money
{
  /*@ public normal_behavior
    @   requires m2 != null;
    @   assignable \nothing;
    @   ensures \result &#60;==&#62; pennies &#62; m2.pennies;
    @*/
  public boolean greaterThan(Money m2);

  /*@ public normal_behavior
    @   requires m2 != null;
    @   assignable \nothing;
    @   ensures \result &#60;==&#62; pennies &#62;= m2.pennies;
    @*/
  public boolean greaterThanOrEqualTo(Money m2);

  /*@ public normal_behavior
    @   requires m2 != null;
    @   assignable \nothing;
    @   ensures \result &#60;==&#62; pennies &#60; m2.pennies;
    @*/
  public boolean lessThan(Money m2);

  /*@ public normal_behavior
    @   requires m2 != null;
    @   assignable \nothing;
    @   ensures \result &#60;==&#62; pennies &#60;= m2.pennies;
    @*/
  public boolean lessThanOrEqualTo(Money m2);
}
</pre></td></tr></table></P><P>

<A NAME="IDX511"></A>
<A NAME="IDX512"></A>
<A NAME="IDX513"></A>
<A NAME="IDX514"></A>
The interface specified in the file <TT>`MoneyOps.java'</TT>
below extends the interface specified above.
<CODE>MoneyOps</CODE> is interesting for
the use of its pure model methods: <CODE>inRange</CODE>,
<CODE>can_add</CODE>, and <CODE>can_scaleBy</CODE>.
These methods cannot be invoked by Java programs;
that is, they would not appear in the Java implementation.
When, for example <CODE>inRange</CODE> is called in a predicate, it is
equivalent to using some correct implementation of its specification.
The specification of <CODE>inRange</CODE> also makes use of a local specification
variable declaration, which follows the keyword "<CODE>old</CODE>".
Such declarations allow one to abbreviate long expressions, or,
to make rhetorical points by naming constants,
as is done with <CODE>epsilon</CODE>.
These <CODE>old</CODE> declarations are treated as locations
that are initialized to the pre-state value of the given expression.
Model methods can be normal (instance) methods
as well as static (class) methods. 
</P><P>

<A NAME="IDX515"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public /*@ pure @*/ interface MoneyOps extends MoneyComparable
{
  /*@  public normal_behavior
    @     old double epsilon = 1.0;
    @     assignable \nothing;
    @     ensures \result
    @        &#60;==&#62; Long.MIN_VALUE + epsilon &#60; d
    @             &#38;&#38; d &#60; Long.MAX_VALUE - epsilon;
    @ public model boolean inRange(double d);
    @
    @  public normal_behavior
    @     requires m2!= null;
    @     assignable \nothing;
    @     ensures \result
    @        &#60;==&#62; inRange((double) pennies + m2.pennies);
    @ public model boolean can_add(Money m2);
    @
    @  public normal_behavior
    @     ensures \result &#60;==&#62; inRange(factor * pennies);
    @ public model boolean can_scaleBy(double factor);
    @*/

  /*@   public normal_behavior
    @     old boolean can_add = can_add(m2); // FIXME: inline.
    @     requires m2 != null &#38;&#38; can_add;
    @     assignable \nothing;
    @     ensures \result != null
    @          &#38;&#38; \result.pennies == this.pennies + m2.pennies;
    @ for_example
    @   public normal_example
    @     requires this.pennies == 300 &#38;&#38; m2.pennies == 400;
    @     assignable \nothing;
    @     ensures \result != null &#38;&#38; \result.pennies == 700;
    @*/
  public MoneyOps plus(Money m2);

  /*@   public normal_behavior
    @     old boolean inRange = inRange((double) pennies - m2.pennies); // FIXME: inline.
    @     requires m2 != null
    @           &#38;&#38; inRange;
    @     assignable \nothing;
    @     ensures \result != null
    @          &#38;&#38; \result.pennies == this.pennies - m2.pennies;
    @ for_example
    @   public normal_example
    @     requires this.pennies == 400 &#38;&#38; m2.pennies == 300;
    @     assignable \nothing;
    @     ensures  \result != null &#38;&#38; \result.pennies == 100;
    @*/
  public MoneyOps minus(Money m2);

  /*@   public normal_behavior
    @     requires can_scaleBy(factor);
    @     assignable \nothing;
    @     ensures \result != null
    @          &#38;&#38; \result.pennies == (long)(factor * pennies);
    @ for_example
    @   public normal_example
    @     requires pennies == 400 &#38;&#38; factor == 1.01;
    @     assignable \nothing;
    @     ensures \result != null &#38;&#38; \result.pennies == 404;
    @*/
  public MoneyOps scaleBy(double factor);
}
</pre></td></tr></table></P><P>

Note also that JML uses the Java semantics for mixed-type expressions.
For example in the ensures clause of the above specification of <CODE>plus</CODE>,
<CODE>m2.pennies</CODE> is implicitly coerced to a double-precision floating point number,
as it would be in Java.
</P><P>

<A NAME="MoneyAC"></A>
<HR SIZE="6">
<A NAME="SEC40"></A>
<H3> 2.3.4 MoneyAC </H3>
<!--docid::SEC40::-->
<P>

<A NAME="IDX516"></A>
<A NAME="IDX517"></A>
<A NAME="IDX518"></A>
<A NAME="IDX519"></A>
<A NAME="IDX520"></A>
<A NAME="IDX521"></A>
<A NAME="IDX522"></A>
<A NAME="IDX523"></A>
The key to proofs that an implementation of a class or interface
specification is correct lies in the use of <CODE>in</CODE>, <CODE>maps-into</CODE>,
and <CODE>represents</CODE> clauses <A HREF="prelimdesign_6.html#BIB30">[Hoare72a]</A> <A HREF="prelimdesign_6.html#BIB47">[Leino95]</A>.
</P><P>

Consider, for example, the abstract class
specified in the file <TT>`MoneyAC.java'</TT> below.
This class is abstract and has no constructors.
The class declares a concrete field <CODE>numCents</CODE>,
which is related to the model instance field <CODE>pennies</CODE>
by the <CODE>represents</CODE> clause.<A NAME="DOCF22" HREF="prelimdesign_fot.html#FOOT22">(22)</A>
The represents clause states that the value of <CODE>pennies</CODE>
is the value of <CODE>numCents</CODE>.
This allows relatively trivial proofs of the correctness of the
<CODE>dollars</CODE> and <CODE>cents</CODE> methods, and is key to the proofs
of the other methods.
</P><P>

<A NAME="IDX524"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public /*@ pure @*/ abstract class MoneyAC implements Money
{
  protected long numCents;
  //@                in pennies;

  //@ protected represents pennies &#60;- numCents;

  /*@ protected constraint_redundantly
    @            numCents == \old(numCents); @*/

  public long dollars() {
    return numCents / 100;
  }

  public long cents() {
    return numCents % 100;
  }

  public boolean equals(/*@ nullable @*/ Object o2) {
    if (o2 instanceof Money) {
      Money m2 = (Money)o2;
      return numCents
             == (100 * m2.dollars() + m2.cents());
    } else {
      return false;
    }
  }

  public int hashCode() {
    return (int)numCents;
  }

  public Object clone() {
    return this;
  }
}
</pre></td></tr></table></P><P>

<A NAME="MoneyComparableAC"></A>
<HR SIZE="6">
<A NAME="SEC41"></A>
<H3> 2.3.5 MoneyComparableAC </H3>
<!--docid::SEC41::-->
<P>

The straightforward implementation of the pure abstract subclass
<CODE>MoneyComparableAC</CODE> is given below.
Besides extending the class <CODE>MoneyAC</CODE>,
it implements the interface <CODE>MoneyComparable</CODE>.
Note that the model and concrete fields are both inherited
by this class.
</P><P>

<A NAME="IDX525"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public /*@ pure @*/ abstract class MoneyComparableAC
    extends MoneyAC implements MoneyComparable
{
  protected static /*@ pure @*/
  long totalCents(Money m2)
  {
    long res = 100 * m2.dollars() + m2.cents();
    //@ assert res == m2.pennies;
    return res;
  }

  public boolean greaterThan(Money m2)
  {
    return numCents &#62; totalCents(m2);
  }

  public boolean greaterThanOrEqualTo(Money m2)
  {
    return numCents &#62;= totalCents(m2);
  }

  public boolean lessThan(Money m2)
  {
    return numCents &#60; totalCents(m2);
  }

  public boolean lessThanOrEqualTo(Money m2)
  {
    return numCents &#60;= totalCents(m2);
  }
}

</pre></td></tr></table></P><P>

<A NAME="IDX526"></A>
<A NAME="IDX527"></A>
<A NAME="IDX528"></A>
<A NAME="IDX529"></A>
<A NAME="IDX530"></A>
An interesting feature of the class <CODE>MoneyComparableAC</CODE>
is the protected static method named <CODE>totalCents</CODE>.
For this method, we give its code with an embedded assertion,
written following the keyword <CODE>assert</CODE>.<A NAME="DOCF23" HREF="prelimdesign_fot.html#FOOT23">(23)</A>
</P><P>

<A NAME="IDX531"></A>
Note that the model method, <CODE>inRange</CODE> is not implemented,
and does not need to be implemented to make this class correctly implement
the interface <CODE>MoneyComparable</CODE>.
</P><P>

<A NAME="USMoney"></A>
<HR SIZE="6">
<A NAME="SEC42"></A>
<H3> 2.3.6 USMoney </H3>
<!--docid::SEC42::-->
<P>

Finally, a concrete class implementation
is given in the file <TT>`USMoney.java'</TT> shown below.
The class <CODE>USMoney</CODE> implements the interface <CODE>MoneyOps</CODE>.
Note that specifications as well as code are given for the constructors.
</P><P>

<A NAME="IDX532"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public /*@ pure @*/ class USMoney
                extends MoneyComparableAC implements MoneyOps
{
  /*@   public normal_behavior
    @     assignable pennies;
    @     ensures pennies == cs;
    @ implies_that
    @   protected normal_behavior
    @     assignable pennies, numCents;
    @     ensures numCents == cs;
    @*/
  public USMoney(long cs)
  {
    numCents = cs;
  }

  /*@ public normal_behavior
    @   assignable pennies;
    @   ensures pennies == (long)(100.0 * amt);
    @   // ensures_redundantly (* pennies holds amt dollars *);
    @*/
  public USMoney(double amt)
  {
    numCents = (long)(100.0 * amt);
  }

  public MoneyOps plus(Money m2)
  {
    return new USMoney(numCents + totalCents(m2));
  }

  public MoneyOps minus(Money m2)
  {
    return new USMoney(numCents - totalCents(m2));
  }
    
  public MoneyOps scaleBy(double factor)
  {
    return new USMoney(numCents * factor / 100.0);
  }

  public String toString()
  {
    return "$" + dollars() + "." + cents();
  }
}
</pre></td></tr></table></P><P>

<A NAME="IDX533"></A>
<A NAME="IDX534"></A>
<A NAME="IDX535"></A>
<A NAME="IDX536"></A>
<A NAME="IDX537"></A>
The constructors each mention the fields that they initialize
in their <CODE>assignable</CODE> clause.
This is because the constructor's job is to initialize these fields.
One can think of a <CODE>new</CODE> expression in Java as executing
in two steps: allocating an object, and then calling the constructor.
Thus the specification of a constructor needs to mention the fields
that it can initialize in the <CODE>assignable</CODE> clause.
</P><P>

<A NAME="IDX538"></A>
<A NAME="IDX539"></A>
<A NAME="IDX540"></A>
The first constructor's specification also illustrates that redundancy
can also be used in an <CODE>assignable</CODE> clause.
A redundant <CODE>assignable</CODE> clause follows 
if the meaning of the set of locations named is a subset of the
ones denoted by the non-redundant clause for the same specification case.
In this example
the redundant assignable clause follows from the given assignable
clause and the meaning of the <CODE>in</CODE> clause inherited from the
superclass <CODE>MoneyAC</CODE>.
</P><P>

<A NAME="IDX541"></A>
<A NAME="IDX542"></A>
The second constructor above is noteworthy in that there is a redundant
ensures clause that uses an informal predicate <A HREF="prelimdesign_6.html#BIB37">[Leavens96b]</A>.
In this instance, the informal predicate is used as a comment
(which could also be used).
Recall that informal predicates allow
an escape from formality when
one does not wish to give part of a specification in formal detail.
</P><P>

<A NAME="IDX543"></A>
<A NAME="IDX544"></A>
<A NAME="IDX545"></A>
<A NAME="IDX546"></A>
<A NAME="IDX547"></A>
<A NAME="IDX548"></A>
The <CODE>plus</CODE> and <CODE>minus</CODE> methods use <CODE>assume</CODE> statements;
these are like assertions, but are intended to impose obligations
on the callers <A HREF="prelimdesign_6.html#BIB6">[Back-Mikhajlova-vonWright98]</A>.
The main distinction between a <CODE>assume</CODE> statement and a <CODE>requires</CODE>
clause is that the former is a statement and can be used within code.
These may also be treated differently by different tools.  
For example, ESC/Java <A HREF="prelimdesign_6.html#BIB51">[Leino-etal00]</A>
will require callers to satisfy the requires clause of a method,
but will not enforce the precondition if it is stated as an assumption.
</P><P>

<A NAME="Use of Pure Classes"></A>
<HR SIZE="6">
<A NAME="SEC43"></A>
<H2> 2.4 Use of Pure Classes </H2>
<!--docid::SEC43::-->
<P>

<A NAME="IDX549"></A>
<A NAME="IDX550"></A>
Since <CODE>USMoney</CODE> is a pure class,
it can be used to make models of other classes.
An example is the abstract class specified in the file
<TT>`Account.jml'</TT> below.
The first model field in this class has the type <CODE>USMoney</CODE>,
which was specified above.
(Further explanation follows the specification below.)
</P><P>

<A NAME="IDX551"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;
public class Account {
  //@ public model MoneyOps credit;
  //@ public model String accountOwner;
  /*@ public invariant accountOwner != null &#38;&#38; credit != null
    @         &#38;&#38; credit.greaterThanOrEqualTo(new USMoney(0)); @*/
  //@ public constraint accountOwner.equals(\old(accountOwner));

  /*@  public normal_behavior
    @    requires own != null &#38;&#38; amt != null
    @          &#38;&#38; (new USMoney(1)).lessThanOrEqualTo(amt);
    @    assignable credit, accountOwner;
    @    ensures credit.equals(amt) &#38;&#38; accountOwner.equals(own);
    @*/
  public Account(MoneyOps amt, String own);

  /*@  public normal_behavior
    @    assignable \nothing;
    @    ensures \result.equals(credit);
    @*/
  public /*@ pure @*/ MoneyOps balance();

  /*@  public normal_behavior
    @    old boolean can_scale = credit.can_scaleBy(1.0 + rate);
    @    requires 0.0 &#60;= rate &#38;&#38; rate &#60;= 1.0
    @          &#38;&#38; can_scale;
    @    assignable credit;
    @    ensures credit.equals(\old(credit).scaleBy(1.0 + rate));
    @ for_example
    @  public normal_example
    @    requires rate == 0.05
    @          &#38;&#38; (new USMoney(4000)).equals(credit);
    @    assignable credit;
    @    ensures credit.equals(new USMoney(4200));
    @*/
  public void payInterest(double rate);

  /*@  public normal_behavior
    @    old boolean can_add = credit.can_add(amt);
    @    requires amt != null
    @          &#38;&#38; amt.greaterThanOrEqualTo(new USMoney(0))
    @          &#38;&#38; can_add;
    @    assignable credit;
    @    ensures credit.equals(\old(credit).plus(amt));
    @ for_example
    @  public normal_example
    @    requires credit.equals(new USMoney(40000))
    @           &#38;&#38; amt.equals(new USMoney(1));
    @    assignable credit;
    @    ensures credit.equals(new USMoney(40001));
    @*/
  public void deposit(MoneyOps amt);

  /*@  public normal_behavior
    @   requires amt != null
   @          &#38;&#38; (new USMoney(0)).lessThanOrEqualTo(amt)
    @         &#38;&#38; amt.lessThanOrEqualTo(credit);
    @    assignable credit;
    @    ensures credit.equals(\old(credit).minus(amt));
    @ for_example
    @  public normal_example
    @    requires credit.equals(new USMoney(40001))
    @          &#38;&#38; amt.equals(new USMoney(40000));
    @    assignable credit;
    @    ensures credit.equals(new USMoney(1));
    @*/
  public void withdraw(MoneyOps amt);
}
</pre></td></tr></table></P><P>

<A NAME="IDX552"></A>
<A NAME="IDX553"></A>
<A NAME="IDX554"></A>
<A NAME="IDX555"></A>
<A NAME="IDX556"></A>
The specification of <CODE>Account</CODE> makes good use of examples.
It also demonstrates the various ways of protecting predicates used
in the specification from undefinedness <A HREF="prelimdesign_6.html#BIB44">[Leavens-Wing97a]</A>.
The principal concern here, as is often the case when using reference
types in a model, is to protect against the model fields being
<CODE>null</CODE>.
As in Java, fields and variables of reference types can be <CODE>null</CODE>.
In the specification of <CODE>Account</CODE>, the invariant states that these fields
should not be null.
Since implementations of public methods must preserve the invariants,
one can think of the invariant as conjoined to the precondition
and postcondition of each public method, and the postcondition of each
public constructor.
Hence, for example, method pre- and postconditions do not have
to state that the fields are not null.
However, often other parts of the specification must be written
to allow the invariant to be preserved, or established by a constructor.
For example, in the specification of <CODE>Account</CODE>'s constructor,
this is done by requiring <CODE>amt</CODE> and <CODE>own</CODE> are not null,
since, if they could be null, then the invariant and the postcondition
could not be established.
</P><P>

<A NAME="Composition for Container Classes"></A>
<HR SIZE="6">
<A NAME="SEC44"></A>
<H2> 2.5 Composition for Container Classes </H2>
<!--docid::SEC44::-->
<P>

<A NAME="IDX557"></A>
<A NAME="IDX558"></A>
The following specifications lead to
the specification of a class <CODE>Digraph</CODE> (directed graph).
This gives a more interesting example of how
more complex models can be composed in JML from
other classes.
In this example we use model classes
and the pure containers provided in the package
<CODE>org.jmlspecs.models</CODE>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC45">2.5.1 NodeType</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC46">2.5.2 ArcType</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="prelimdesign_2.html#SEC47">2.5.3 Digraph</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="NodeType"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<H3> 2.5.1 NodeType </H3>
<!--docid::SEC45::-->
<P>

<A NAME="IDX559"></A>
<A NAME="IDX560"></A>
The file <TT>`NodeType.java'</TT>
contains the specification of an interface <CODE>NodeType</CODE>.
We also declare this interface to be <CODE>pure</CODE>,
since we want to use its methods in the specifications of other
classes.
(This is appropriate, since all the methods of <CODE>NodeType</CODE> are
side-effect free.)
</P><P>

<A NAME="IDX561"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.digraph;

import org.jmlspecs.models.*;

public /*@ pure @*/ interface NodeType extends JMLType {
  
  /*@ also
    @   public normal_behavior
    @       requires !(o instanceof NodeType);
    @       ensures \result == false;
    @*/
  public boolean equals(/*@ nullable @*/ Object o);

  public int hashCode();

  /*@ also
    @   public normal_behavior
    @     ensures \result instanceof NodeType
    @          &#38;&#38; ((NodeType)\result).equals(this);
    @*/
  public Object clone();

}
</pre></td></tr></table></P><P>

<A NAME="ArcType"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<H3> 2.5.2 ArcType </H3>
<!--docid::SEC46::-->
<P>

<A NAME="IDX562"></A>
<A NAME="IDX563"></A>
<A NAME="IDX564"></A>
<A NAME="IDX565"></A>
<CODE>ArcType</CODE> is specified as a
pure class in the file <TT>`ArcType.jml'</TT> shown below.
In theory, this class could have been declared with the <CODE>model</CODE> modifier,
since it does not appear in the interface
to <CODE>Digraph</CODE>.  However, we specify it as a normal Java class for
simplicity, and because model classes do not currently work in JML's
runtime assertion checker.
We declare <CODE>ArcType</CODE> to be a pure class
so that its methods can be used in assertions.
The two model fields for <CODE>ArcType</CODE>,
<CODE>from</CODE> and <CODE>to</CODE>, are both
of type <CODE>NodeType</CODE>.
We specify the <CODE>equals</CODE> method so that two references
to objects of type <CODE>ArcType</CODE> are equal if and only if they have equal
values in the <CODE>from</CODE> and <CODE>to</CODE> model fields.
Thus, <CODE>equals</CODE> is specified using <CODE>NodeType.equals</CODE>.
We also specify that <CODE>ArcType</CODE>
has a public <CODE>clone</CODE> method,
fulfilling the obligations of a type that implements
<CODE>JMLType</CODE>.
<CODE>ArcType</CODE> must implement <CODE>JMLType</CODE> so that
its objects can be placed in a <CODE>JMLValueSet</CODE>.
We use such a set for one of the model fields of <CODE>Digraph</CODE>.
</P><P>

<A NAME="IDX566"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.digraph;

import org.jmlspecs.models.JMLType;

/*@ pure @*/ public class ArcType implements JMLType {

    //@ public model NodeType from;
    //@ public model NodeType to;
    //@ public invariant from != null &#38;&#38; to != null;

    /*@ public normal_behavior
      @   requires from != null &#38;&#38; to != null;
      @   assignable this.from, this.to;
      @   ensures this.from.equals(from)
      @        &#38;&#38; this.to.equals(to);
      @*/
    public ArcType(NodeType from, NodeType to);

    /*@ also
      @   public normal_behavior
      @   {|
      @     requires o instanceof ArcType;
      @     ensures \result
      @        &#60;==&#62; ((ArcType)o).from.equals(from)
      @             &#38;&#38; ((ArcType)o).to.equals(to);
      @   also
      @     requires !(o instanceof ArcType);
      @     ensures \result == false;
      @   |}
      @*/
    public boolean equals(/*@ nullable @*/ Object o);

    /*@ also
      @   public normal_behavior
      @     ensures \result instanceof ArcType
      @          &#38;&#38; ((ArcType)\result).equals(this);
      @*/
    public Object clone();
}

</pre></td></tr></table></P><P>

<A NAME="IDX567"></A>
<A NAME="IDX568"></A>
The use of <CODE>also</CODE> in the specification of
<CODE>ArcType</CODE>'s <CODE>equals</CODE> method is interesting.
It separates two cases of the normal behavior for that method.
This is equivalent to using two <CODE>public normal_behavior</CODE> clauses,
one for each case.
That is, when the argument is an instance of <CODE>ArcType</CODE>,
the method must return true just when 
<CODE>this</CODE> and <CODE>o</CODE> have the same <CODE>from</CODE> and <CODE>to</CODE> fields.
And when <CODE>o</CODE> is not an instance of <CODE>ArcType</CODE>,
the <CODE>equals</CODE> method must return false.
</P><P>

<A NAME="Digraph"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<H3> 2.5.3 Digraph </H3>
<!--docid::SEC47::-->
<P>

<A NAME="IDX569"></A>
<A NAME="IDX570"></A>
Finally, the specification of the class <CODE>Digraph</CODE>
is given in the file <TT>`Digraph.jml'</TT> shown below.
This specification
demonstrates how to use container classes,
like <CODE>JMLValueSet</CODE>, combined with
appropriate invariants, to specify models that are compositions of
other classes.
In this specification, the container class <CODE>JMLValueSet</CODE> is used
as the type of the model fields <CODE>nodes</CODE> and <CODE>arcs</CODE>.
Since JML currently only works with a non-generic version of Java,
the first invariant clause restricts
<CODE>nodes</CODE> so that every object in <CODE>nodes</CODE> is, in fact, of type
<CODE>NodeType</CODE>.
Similarly, the next invariant clause we restrict <CODE>arcs</CODE> to be
a set of <CODE>ArcType</CODE> objects. In both cases, since the type is
<CODE>JMLValueSet</CODE>, membership is determined by
the <CODE>equals</CODE> method for the
type of the elements (rather than reference equality).
</P><P>

<A NAME="IDX571"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.digraph;
//@ model import org.jmlspecs.models.*;
public class Digraph {
 //@ public model JMLValueSet nodes;
 //@ public model JMLValueSet arcs;
 /*@ public invariant_redundantly nodes != null;
   @ public invariant (\forall JMLType n; nodes.has(n);
   @                          n instanceof NodeType);
   @ public invariant_redundantly arcs != null;
   @ public invariant (\forall JMLType a; arcs.has(a);
   @                          a instanceof ArcType); 
   @ public invariant
   @      (\forall ArcType a; arcs.has(a);
   @           nodes.has(a.from) &#38;&#38; nodes.has(a.to));
   @*/

 /*@  public normal_behavior
   @   assignable nodes, arcs;
   @   ensures nodes.isEmpty() &#38;&#38; arcs.isEmpty();
   @*/
 public Digraph();

 /*@  public normal_behavior
   @   requires_redundantly n != null;
   @   assignable nodes;
   @   ensures nodes.equals(\old(nodes.insert(n)));
   @*/
 public void addNode(NodeType n);
 
 /*@  public normal_behavior
   @   requires unconnected(n);
   @   assignable nodes;
   @   ensures nodes.equals(\old(nodes.remove(n)));
   @*/
 public void removeNode(NodeType n);
 
 /*@  public normal_behavior
   @   requires_redundantly inFrom != null &#38;&#38; inTo != null;
   @   requires nodes.has(inFrom) &#38;&#38; nodes.has(inTo);
   @   assignable arcs;
   @   ensures arcs.equals(
   @            \old(arcs).insert(new ArcType(inFrom, inTo)));
   @*/
 public void addArc(NodeType inFrom, NodeType inTo);
 
 /*@  public normal_behavior
   @   requires_redundantly inFrom != null &#38;&#38; inTo != null;
   @   requires nodes.has(inFrom) &#38;&#38; nodes.has(inTo);
   @   assignable arcs;
   @   ensures arcs.equals(
   @            \old(arcs).remove(new ArcType(inFrom, inTo)));
   @*/
 public void removeArc(NodeType inFrom, NodeType inTo);

 /*@  public normal_behavior
   @   assignable \nothing;
   @   ensures \result == nodes.has(n);
   @*/
 public /*@ pure @*/ boolean isNode(NodeType n); 

 /*@  public normal_behavior
   @   requires_redundantly inFrom != null &#38;&#38; inTo != null;
   @   ensures \result == arcs.has(new ArcType(inFrom, inTo));
   @
   @*/
 public /*@ pure @*/ boolean isArc(NodeType inFrom,
                                   NodeType inTo); 

 /*@  public normal_behavior
   @   requires nodes.has(start) &#38;&#38; nodes.has(end);
   @   assignable \nothing;
   @   ensures \result
   @           == reachSet(new JMLValueSet(start)).has(end);
   @*/
 public /*@ pure @*/ boolean isAPath(NodeType start,
                                     NodeType end);

 /*@  public normal_behavior
   @   assignable \nothing;
   @   ensures \result &#60;==&#62;
   @              !(\exists ArcType a; arcs.has(a);
   @                     a.from.equals(n) || a.to.equals(n));
   @*/
 public /*@ pure @*/ boolean unconnected(NodeType n);

 /*@  public normal_behavior
   @   requires_redundantly nodeSet != null;
   @   requires (\forall JMLType o; nodeSet.has(o);
   @                o instanceof NodeType &#38;&#38; nodes.has(o));
   @   {|
   @      assignable \nothing;
   @    also
   @      requires nodeSet.equals(OneMoreStep(nodeSet));
   @      ensures \result != null &#38;&#38; \result.equals(nodeSet);
   @    also
   @      requires !nodeSet.equals(OneMoreStep(nodeSet));
   @      ensures \result != null
   @         &#38;&#38; \result.equals(reachSet(OneMoreStep(nodeSet)));
   @   |}
   @ public pure model JMLValueSet reachSet(JMLValueSet nodeSet);
   @*/

 /*@  public normal_behavior
   @   requires_redundantly nodeSet != null;
   @   requires (\forall JMLType o; nodeSet.has(o);
   @              o instanceof NodeType &#38;&#38; nodes.has(o));
   @      assignable \nothing;
   @   ensures_redundantly \result != null;
   @   ensures \result.equals(nodeSet.union(
   @        new JMLValueSet { NodeType n | nodes.has(n)
   @          &#38;&#38; (\exists ArcType a; a != null &#38;&#38; arcs.has(a);
   @                nodeSet.has(a.from) &#38;&#38; n.equals(a.to))}));
   @ public pure model
   @ JMLValueSet OneMoreStep(JMLValueSet nodeSet);
   @*/
}
</pre></td></tr></table></P><P>

<A NAME="IDX572"></A>
<A NAME="IDX573"></A>
<A NAME="IDX574"></A>
<A NAME="IDX575"></A>
<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
An interesting use of pure model methods appears at the end of
the specification of <CODE>Digraph</CODE> in the pure model method <CODE>reachSet</CODE>.
This method constructively defines the set of all nodes
that are reachable from the nodes in the argument <CODE>nodeSet</CODE>.
This specification uses a nested case analysis, between <CODE>{|</CODE>
and <CODE>|}</CODE>.  The meaning of this is again that each pre- and postcondition
pair has to be obeyed, but by using nesting, one can avoid duplication of the
requires clause that is found at the beginning of the specification.
The <CODE>measured_by</CODE> clause is needed because this specification is
recursive; the measure given allows one to describe a termination argument,
and thus ensure that the specification is well-defined. 
This clause defines an integer-valued measure that must always
be at least zero; furthermore, the measure for a call and recursive
uses in the specification must strictly decrease <A HREF="prelimdesign_6.html#BIB67">[Owre-etal95]</A>.
The recursion in the specification builds up the entire set
of reachable nodes by, for each recursive reference, adding the nodes
that can be reached directly (via a single arc) from the nodes in
<CODE>nodeSet</CODE>. 
</P><P>

<A NAME="Behavioral Subtyping"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<H2> 2.6 Behavioral Subtyping </H2>
<!--docid::SEC48::-->
<P>

<A NAME="IDX578"></A>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
<A NAME="IDX581"></A>
<A NAME="IDX582"></A>
<A NAME="IDX583"></A>
<A NAME="IDX584"></A>
<A NAME="IDX585"></A>
As in Java, a subtype inherits members (fields and methods) from its
supertypes.  A subtype also inherits all the class
level-specifications associated with fields and all method
specifications for public and protected instance methods.
This specification inheritance
has the effect of making the subtype a behavioral subtype <A HREF="prelimdesign_6.html#BIB53">[Liskov-Wing94]</A>,
in the sense that instances of the subtype obey the specifications its
supertype(s) <A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A> <A HREF="prelimdesign_6.html#BIB43">[Leavens-Weihl95]</A>.
</P><P>

<A NAME="IDX586"></A>
<A NAME="IDX587"></A>
<A NAME="IDX588"></A>
<A NAME="IDX589"></A>
Class-level specifications associated with fields include include
invariants and history constraints (see section <A HREF="prelimdesign_2.html#SEC24">2.2.1.2 Invariants and History Constraint</A>),
as well as <CODE>initially</CODE> clauses (see section <A HREF="prelimdesign_2.html#SEC13">2.1.1 Model Fields</A>)
data group declarations (see section <A HREF="prelimdesign_2.html#SEC21">2.2 Data Groups</A>),
and represents clauses (see section <A HREF="prelimdesign_2.html#SEC29">2.2.2.1 Data Groups and Represents Clauses</A>).
Inheritance of invariants means that
each supertype's invariants must also hold in the subtype.
Similarly, every history constraint specified in each supertype must
be obeyed in the subtype. And all initially clauses specified
for supertype fields must also be obeyed in all subtypes.
Fields declared in a supertype retain their data group
membership when inherited.  Their represents clauses are also
inherited.
</P><P>

<A NAME="IDX590"></A>
<A NAME="IDX591"></A>
<A NAME="IDX592"></A>
<A NAME="IDX593"></A>
<A NAME="IDX594"></A>
As in Java, private fields are inherited by a subtype but not visible
to it.  Similarly, default privacy (i.e., package
visibility) fields are not accessible if the subtype is declared in a
different package than the supertype declaring the field.
As in Java, these fields are present in the
objects of the subtype, but not accessible to code written in the
subtype.
In the same way, class level specifications associated with such
fields must still be obeyed by objects of the subtype.
Various restrictions to JML that ensure that this is always possible
are being investigated <A HREF="prelimdesign_6.html#BIB72">[Ruby-Leavens00]</A>.
</P><P>

Specifications for instance methods
are also inherited in the sense that public and
protected specification cases must
be obeyed by all overriding methods <A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A> <A HREF="prelimdesign_6.html#BIB38">[Leavens97c]</A>.
This inheritance of method specifications
ensures that a client's reasoning about a method call will still
be valid, even if the method is overridden
<A HREF="prelimdesign_6.html#BIB2">[America87]</A> <A HREF="prelimdesign_6.html#BIB3">[America91]</A> <A HREF="prelimdesign_6.html#BIB43">[Leavens-Weihl95]</A>,
and thus that a subclass is a behavioral subtype of its
supertypes <A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A>.
Note that private and default (package) visibility specification cases
are not visible to subtypes, and hence do not have to be obeyed by
them; not inheriting such specification cases does not cause clients
reasoning problems, as these specification cases are not
visible to clients making method calls (in general).<A NAME="DOCF24" HREF="prelimdesign_fot.html#FOOT24">(24)</A>
Furthermore, specifications are <EM>not</EM> inherited for constructors or for
static methods, since they are not involved in dynamic dispatch.
</P><P>

<A NAME="IDX595"></A>
Inheritance of method specifications can be thought of textually.
For each instance method, <I>m</I> specified in a class <I>C</I>,
one can imagine copying into the specification of <I>m</I> the public and protected 
specification cases for <I>m</I> given in all of <I>C</I>'s ancestors
and in all the interfaces <I>C</I> implements;
these specification cases would be combined using
<CODE>also</CODE> <A HREF="prelimdesign_6.html#BIB19">[Dhara-Leavens96]</A> <A HREF="prelimdesign_6.html#BIB70">[Raghavan-Leavens05]</A>.<A NAME="DOCF25" HREF="prelimdesign_fot.html#FOOT25">(25)</A>
(This is the reason for the use of <CODE>also</CODE> at the beginning
of specifications in overriding methods.)
By the semantics of method combination using <CODE>also</CODE>,
these behaviors must all be satisfied by the method,
in addition to any explicitly specified behaviors.
</P><P>

<A NAME="IDX596"></A>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>
<A NAME="IDX599"></A>
<A NAME="IDX600"></A>
For example, consider the class <CODE>PlusAccount</CODE>,
specified in file <TT>`PlusAccount.jml'</TT> shown below.
It is specified as a subclass of <CODE>Account</CODE>
(see section <A HREF="prelimdesign_2.html#SEC43">2.4 Use of Pure Classes</A>).
Thus it inherits the fields of <CODE>Account</CODE>,
and <CODE>Account</CODE>'s public invariants, history constraints,
and method specifications.
(The specification of <CODE>Account</CODE> given above
does not have any <CODE>protected</CODE> specification information.)
Since it inherits the fields of its superclass,
a textual copy of the method specification cases of <CODE>Account</CODE>
would still be meaningful in the context of <CODE>PlusAccount</CODE>.
Thinking of such textual copies works if one adds new (model) fields to
specify the subclass and relates them to the existing ones.
If instead one tried to respecify the fields of a supertype
with invariants and history constraints
that violated the (inherited) specification of that supertype, then
the resulting specification would be contradictory, and hence not be
correctly implementable. 
</P><P>

<A NAME="IDX601"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.prelimdesign;

public class PlusAccount extends Account {
  //@ public model MoneyOps savings, checking;  in credit;

  /*@ public represents credit \such_that
    @                   credit.equals(savings.plus(checking));
    @*/
  //@ public invariant savings != null &#38;&#38; checking != null;
  /*@ public invariant_redundantly
    @           savings.plus(checking)
    @                  .greaterThanOrEqualTo(new USMoney(0));
    @*/

  /*@  public normal_behavior
    @    requires sav != null &#38;&#38; chk != null &#38;&#38; own != null
    @          &#38;&#38; (new USMoney(1)).lessThanOrEqualTo(sav)
    @          &#38;&#38; (new USMoney(1)).lessThanOrEqualTo(chk);
    @    assignable credit, owner;
    @    assignable_redundantly savings, checking;
    @    ensures savings.equals(sav) &#38;&#38; checking.equals(chk)
    @             &#38;&#38; owner.equals(own);
    @    ensures_redundantly credit.equals(sav.plus(chk));
    @*/
  public PlusAccount(MoneyOps sav, MoneyOps chk, String own);


  /*@ also
    @  public normal_behavior
    @    old boolean can_scale = credit.can_scaleBy(1.0 + rate);
    @    requires 0.0 &#60;= rate &#38;&#38; rate &#60;= 1.0
    @          &#38;&#38; can_scale;
    @    assignable credit, savings, checking;
    @    ensures checking.equals(
    @             \old(checking).scaleBy(1.0 + rate));
    @ for_example
    @  public normal_example
    @    requires rate == 0.05
    @          &#38;&#38; checking.equals(new USMoney(2000));
    @    assignable credit, savings, checking;
    @    ensures checking.equals(new USMoney(2100));
    @*/
  public void payInterest(double rate);

  /*@ also
    @  public normal_behavior
    @    requires amt != null
    @            &#38;&#38; (new USMoney(0)).lessThanOrEqualTo(amt)
    @            &#38;&#38; amt.lessThanOrEqualTo(savings);
    @    assignable credit, savings;
    @    ensures savings.equals(\old(savings).minus(amt))
    @            &#38;&#38; \not_modified(checking);
    @ also
    @  public normal_behavior
    @    requires amt != null
    @            &#38;&#38; (new USMoney(0)).lessThanOrEqualTo(amt)
    @            &#38;&#38; amt.lessThanOrEqualTo(credit)
    @            &#38;&#38; amt.greaterThan(savings);
    @    assignable credit, savings, checking;
    @    ensures savings.equals(new USMoney(0))
    @           &#38;&#38; checking.equals(
    @                \old(checking).minus(amt.minus(savings)));
    @ for_example
    @   public normal_example
    @    requires savings.equals(new USMoney(40001))
    @             &#38;&#38; amt.equals(new USMoney(40000));
    @    assignable credit, savings, checking;
    @    ensures savings.equals(new USMoney(1))
    @            &#38;&#38; \not_modified(checking);
    @  also
    @   public normal_example
    @    requires savings.equals(new USMoney(30001))
    @           &#38;&#38; checking.equals(new USMoney(10000))
    @           &#38;&#38; amt.equals(new USMoney(40000));
    @    assignable credit, savings, checking;
    @    ensures savings.equals(new USMoney(0))
    @           &#38;&#38; checking.equals(new USMoney(1));
    @*/
  public void withdraw(MoneyOps amt);

  /*@ also
    @  public normal_behavior
    @    old boolean can_add = credit.can_add(amt);
    @    requires amt != null
    @           &#38;&#38; amt.greaterThanOrEqualTo(new USMoney(0))
    @           &#38;&#38; can_add;
    @    assignable credit, savings;
    @    ensures savings.equals(\old(savings).plus(amt))
    @            &#38;&#38; \not_modified(checking);
    @ for_example
    @  public normal_example
    @    requires savings.equals(new USMoney(20000))
    @           &#38;&#38; amt.equals(new USMoney(1));
    @    assignable credit, savings, checking;
    @    ensures savings.equals(new USMoney(20001));
    @*/ 
  public void deposit(MoneyOps amt);

  /*@    public normal_behavior
    @    old boolean can_add = credit.can_add(amt);
    @    requires amt != null
    @           &#38;&#38; amt.greaterThanOrEqualTo(new USMoney(0))
    @           &#38;&#38; can_add;
    @    assignable credit, checking;
    @    ensures checking.equals(\old(checking).plus(amt))
    @          &#38;&#38; \not_modified(savings);
    @ for_example
    @  public normal_example
    @    requires checking.equals(new USMoney(20000))
    @           &#38;&#38; amt.equals(new USMoney(1));
    @    assignable credit, checking;
    @    ensures checking.equals(new USMoney(20001));
    @*/
  public void depositToChecking(MoneyOps amt);

  /*@  public normal_behavior
    @    requires amt != null;
    @    {|
    @      requires (new USMoney(0)).lessThanOrEqualTo(amt)
    @             &#38;&#38; amt.lessThanOrEqualTo(checking);
    @      assignable credit, checking;
    @      ensures checking.equals(\old(checking).minus(amt))
    @             &#38;&#38; \not_modified(savings);
    @     also
    @      requires (new USMoney(0)).lessThanOrEqualTo(amt)
    @             &#38;&#38; amt.lessThanOrEqualTo(credit)
    @             &#38;&#38; amt.greaterThan(checking);
    @      assignable credit, checking, savings;
    @      ensures checking.equals(new USMoney(0))
    @          &#38;&#38; savings.equals(
    @              \old(savings).minus(amt.minus(checking)));
    @    |}
    @ for_example
    @  public normal_example 
    @    requires checking.equals(new USMoney(40001))
    @           &#38;&#38; amt.equals(new USMoney(40000));
    @    assignable credit, checking;
    @    ensures checking.equals(new USMoney(1))
    @           &#38;&#38; \not_modified(savings);
    @ also
    @  public normal_example
    @    requires savings.equals(new USMoney(30001))
    @           &#38;&#38; checking.equals(new USMoney(10000))
    @           &#38;&#38; amt.equals(new USMoney(40000));
    @    assignable credit, checking, savings;
    @    ensures checking.equals(new USMoney(0))
    @          &#38;&#38; savings.equals(new USMoney(1));
    @*/
  public void payCheck(MoneyOps amt);
}
</pre></td></tr></table></P><P>

Similarly, if one tried to respecify a method in a way that violated
an (inherited) specification case, then the method would have to obey
both specifications, and would not be correctly implementable. Thus,
specification inheritance guarantees that all subtypes are behavioral
subtypes in JML, and trying to avoid behavioral subtyping results in
unimplementable specifications <CITE>Dhara-Leavens96</CITE>.
</P><P>

<A NAME="IDX602"></A>
<A NAME="IDX603"></A>
<A NAME="IDX604"></A>
<A NAME="IDX605"></A>
Note that in the represents clause below,
instead of a left-facing arrow, <CODE>&#60;-</CODE>,
the connective "<CODE>\such_that</CODE>"
is used to introduce a relationship predicate.
This form of the represents clause allows one to specify abstraction relations,
instead of abstraction functions.
</P><P>

<A NAME="Extensions to Java Expressions"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_2.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_3.html#SEC49"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_7.html#SEC56">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="prelimdesign_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>May, 20  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
