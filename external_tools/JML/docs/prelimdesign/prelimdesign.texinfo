\input texinfo  @c -*-texinfo-*-
@comment %**start of header (This is for running Texinfo on a region.)
@setfilename prelimdesign.info
@settitle Preliminary Design of JML
@c @setchapternewpage odd

@ifinfo
@format
INFO-DIR-SECTION Programming & development tools
START-INFO-DIR-ENTRY
* Preliminary Design of JML: (prelimdesign).  Design of the Java Modeling Language.
END-INFO-DIR-ENTRY
@end format

Appears as @cite{ACM SIGSOFT Software Engineering Notes}, 31(3):1-38,
March 2006.

Copyright @copyright{} 1998-2005 Iowa State University

This document is part of JML and is
distributed under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
2, or (at your option) any later version.

Version Information:
 @@(#)$Id: prelimdesign.texinfo,v 1.114 2008/01/08 22:43:42 leavens Exp $
@end ifinfo

@comment ----- title and copyright pages
@titlepage
@title Preliminary Design of JML:
@subtitle A Behavioral Interface Specification Language for Java

@author by Gary T. Leavens, Albert L. Baker, and Clyde Ruby

@sp 1

@center TR #98-06-rev29
@center June 1998, revised July, November 1998,
@center January, April, June, July, August, December 1999,
@center February, May, July, December 2000,
@center February, April, May, August 2001,
@center June, August, October, December 2002,
@center April, May, September, November 2003,
@center June, November, December 2004,
@center February, April, July 2005,
@center January 2006

@sp 2

@b{Keywords:}  Behavioral interface specification, Java,
JML, Eiffel, Larch, model-based specification, assertion,
precondition, postcondition, frame.

@b{2000 CR Categories:}
D.2.1 [@i{Software Engineering}]
        Requirements/Specifications --- languages, tools, theory,
        Larch, Eiffel, JML, ESC/Java;
D.2.4 [@i{Software Engineering}]
        Software/Program Verification --- assertion checkers, class invariants,
        formal methods, programming by contract;
D.2.7 [@i{Software Engineering}]
        Distribution and Maintenance --- documentation;
F.3.1 [@i{Logics and Meanings of Programs}]
        Specifying and Verifying and Reasoning about Programs ---
                assertions, invariants, logics of programs,
                pre- and post-conditions, specification techniques.

@sp 1

Appears as @cite{ACM SIGSOFT Software Engineering Notes}, 31(3):1-38,
March 2006.

Copyright @copyright{} 1998-2006 Iowa State University

This document is part of JML and is
distributed under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
2, or (at your option) any later version.

@sp 1

@center Department of Computer Science, Iowa State University
@center 226 Atanasoff Hall
@center Ames, Iowa 50011-1041, USA
@end titlepage

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@node Top, Introduction, (dir), (dir)

@ifinfo
@c The following is orientation for the reader of the info file
The Java Modeling Language (JML) is a notation for formally specifying
the behavior and interfaces of Java classes and methods.
This document gives an overview of JML's design.
@end ifinfo

@menu
* Introduction::                
* Class and Interface Specifications::  
* Extensions to Java Expressions::  
* Conclusions::                 
* Specification Case Defaults::  
* Bibliography::                
* Example Index::               
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Behavioral Interface Specification::  
* Lightweight Specifications::  
* Goals::                       
* Tool Support::                
* Outline::                     

Tool Support

* Type Checking Specifications::  
* Generating HTML Documentation::  
* Run Time Assertion Checking::  
* Unit Testing with JML::       

Class and Interface Specifications

* Abstract Models::             
* Data Groups::                 
* Types For Modeling::          
* Use of Pure Classes::         
* Composition for Container Classes::  
* Behavioral Subtyping::        

Abstract Models

* Model Fields::                
* Invariants::                  
* Method Specifications::       
* Models and Lightweight Specifications::  

Method Specifications

* The Assignable Clause::       
* Old Values::                  
* Reference Semantics::         
* Correct Implementation::      

Data Groups

* Specification of BoundedThing::  
* Specification of BoundedStackInterface::  

Specification of BoundedThing

* Model Fields in Interfaces::  
* Invariants and History Constraint::  
* Details of the Method Specifications::  
* Adding to Method Specifications::  
* Specifying Exceptional Behavior::  

Specification of BoundedStackInterface

* Data Groups and Represents Clauses::  
* Redundant Specification::     
* Multiple Specification Cases::  
* Pitfalls in Specifying Exceptions::  
* Redundant Ensures Clauses::   

Types For Modeling

* Purity::                      
* Money::                       
* MoneyComparable and MoneyOps::  
* MoneyAC::                     
* MoneyComparableAC::           
* USMoney::                     

Money

* Redundant Examples::          
* JMLType and Informal Predicates::  

Composition for Container Classes

* NodeType::                    
* ArcType::                     
* Digraph::                     

Extensions to Java Expressions

* Extensions to Java Expressions for Predicates::  
* Extensions to Java Expressions for Store-Refs::  

@end detailmenu
@end menu

@contents

@c ------ chapter Introduction --------
@node Introduction, Class and Interface Specifications, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@center @b{Abstract}

@quotation
JML is a behavioral interface specification language tailored to Java(TM).
Besides pre- and postconditions,
it also allows assertions to be intermixed with Java code; these aid
verification and debugging.  JML is designed to be used by working
software engineers; to do this it follows Eiffel in using Java
expressions in assertions.  JML combines this idea from Eiffel with the
model-based approach to specifications, typified by VDM and Larch,
which results in greater expressiveness.  Other expressiveness
advantages over Eiffel include quantifiers, specification-only
variables, and frame conditions.

This paper discusses the goals of JML, the overall approach, and
describes the basic features of the language through examples.  It is
intended for readers who have some familiarity with both Java and
behavioral specification using pre- and postconditions.
@end quotation

@cindex JML
@cindex JML
@cindex Baker
@cindex Holmes
@cindex Java Modeling Language
@cindex BISL
@cindex Arnold
@cindex Gosling
@cindex Holmes
@cindex Java
@cindex Wing
@cindex module
JML stands for ``Java Modeling Language'' [Leavens-Baker-Ruby99].
JML is a @dfn{behavioral interface specification language} (BISL)
[Wing87]
designed to specify
Java [Arnold-Gosling-Holmes00] [Gosling-etal00] 
modules.
Java @dfn{modules} are classes and interfaces.

@cindex goals, of JML
The main goal of our research on JML is to better understand
how to make BISLs (and BISL tools)
that are practical and effective for production software environments.
In order to understand this goal, and the more detailed discussion
of our goals for JML, it helps to define more precisely what
a behavioral interface specification is.
After doing this, we return
to describing the goals of JML,
and then give a brief overview of the tool support for JML and an
outline of the rest of the paper.

@menu
* Behavioral Interface Specification::  
* Lightweight Specifications::  
* Goals::                       
* Tool Support::                
* Outline::                     
@end menu

@node Behavioral Interface Specification, Lightweight Specifications, Introduction, Introduction
@c  node-name,  next,  previous,  up
@section Behavioral Interface Specification

@cindex interface specification
@cindex behavioral interface specification language
@cindex interface, of a module
@cindex behavior
As a BISL,
JML describes two important aspects of a Java module:
@itemize @bullet
@item
its @dfn{interface}, which consists of the names and static information
found in Java declarations,
and

@item
its @dfn{behavior}, which tells how the module acts when used.
@end itemize

@cindex Wing
@cindex Leavens
@cindex Larch/C++
BISLs are inherently language-specific [Wing87],
because they describe interface details for clients written in a specific
programming language,
For example, a BISL tailored to C++, such as Larch/C++ [Leavens97c],
describes how to use a module in a C++ program.
A Larch/C++ specification cannot be implemented correctly in Java,
and a JML specification cannot be correctly implemented in C++
(except for methods that are specified as native code).

@cindex Luckham
@cindex von Henke
@cindex Rosenblum
@cindex Tan
@cindex annotations
JML specifications can either be written in separate files
or as annotations in Java program files.
To a Java compiler such annotations are comments that are ignored
[Luckham-vonHenke85] [Luckham-etal87] [Rosenblum95] [Tan94] [Tan95].
This allows JML specifications, such as the specification below,
to be embedded in Java program files.
Consider the following
simple example of a behavioral interface specification in JML,
written as annotations in a Java program file, @file{IntMathOps.java}.

@pindex @code{IntMathOps.java}
@pindex @code{isqrt}
@example
@group
@include local/IntMathOps.java.texinfo
@end group
@end example

@kindex @code{//}
@kindex @code{//@@}
@kindex @code{/*@@}
@kindex @code{@@*/}
The specification above describes a Java class, @code{IntMathOps}
that contains one static method (function member) named @code{isqrt}.
The single-line comments to the far right (which start with @code{//})
give the line numbers in this specification;
they are ignored by both Java and JML.
Comments with an immediately following at-sign, @code{//@@},
or, as on lines 3--10, C-style comments
starting with @code{/*@@}, are @dfn{annotations}.
Annotations are treated as comments by a Java compiler,
but JML processes the text of an annotation.
The text of an annotation is either the remainder of a line
following @code{//@@}
or the characters between the annotation markers @code{/*@@} and @code{@@*/}.
In the second form, at-signs (@code{@@}) at the beginning of lines
are ignored;
they can be used to help the reader see the extent of an annotation.

In the above specification,
interface information is declared in lines 1 and 11.
Line 1 declares a class named @code{IntMathOps},
and line 11 declares a method named @code{isqrt}.
Note that all of Java's declaration syntax is allowed in JML,
including, on lines 1 and 11, that the names declared are @code{public},
that the method is @code{static} (line 11),
that its return type is @code{int} (line 11),
and that it takes one @code{int} argument.

@cindex files, for annotations
Such interface declarations must be found in a Java module
that correctly implements this specification.
This is automatically the case in the file @file{IntMathOps.java}
shown above, since that file also contains the implementation.
In fact, when Java annotations are embedded in @file{.java} files,
the interface specification is the actual Java source code.

@cindex annotations, placement of
@kindex @code{normal_behavior}
@cindex client, specification for
@cindex @code{public} specification
To be correct, an implementation must have both the specified interface
and the specified behavior.
In the above specification,
the behavioral information is specified in the annotation text
on lines 3--10.@footnote{
In JML method specifications must be placed either before the method's
header, as shown above, or between the method's header and its body.
In this document, we always place the specification before the method header.
This convention is followed by many Java tools, in particular by Javadoc;
It has the advantage of working in all cases, even when the method has no body.
}
The keywords @code{public normal_behavior} are used to say that
the specification is intended for callers (hence ``public''),
and that when the precondition is satisfied
a call must return normally, without throwing an exception (hence ``normal'').
In such a public specification, only names with public visibility
may be used.@footnote{
In a protected specification,
both public and protected identifiers can be used.
In a specification with default (i.e., no) visibility specified,
which corresponds to Java's default visibility,
public and protected identifiers can be used, as well as identifiers
from the same package with default visibility.
A private specification can use any identifiers that are available.
The privacy level of a method specification
cannot allow more access than the method being specified.
Thus a public method may have a private specification,
but a private method may not have a public specification.
}
@cindex precondition
@kindex @code{requires}
@kindex @code{pre}, see @code{requires}
@cindex postcondition
@kindex @code{ensures}
@kindex @code{post}, see @code{ensures}
On line 4 is a precondition, which follows the keyword
@code{requires}.@footnote{
The keyword @code{pre} can also be used as a synonym for @code{requires}.}
On line 5 is frame condition, which says that this method, when called,
does not assign to any locations.
On lines 6--9 is a postcondition,
which follows the keyword @code{ensures}.@footnote{
The keyword @code{post} can also be used as a synonym for @code{ensures}.}
The precondition says what must be true about the arguments
(and other parts of the state);
if the precondition is true, then the method must terminate normally
in a state that satisfies the postcondition.
@cindex contract
@cindex Hoare
@cindex Jones
@cindex Jonkers
@cindex Guttag
@cindex Horning
@cindex Meyer
@cindex Morgan
This is a contract between the caller of the method and the implementor
[Hoare69] [Jones90] [Jonkers91] [Guttag-Horning93] [Meyer92a] [Meyer97] [Morgan94].
The caller is obligated to make the precondition true,
and gets the benefit of having the postcondition then be satisfied.
The implementor gets the benefit of being able to assume the precondition,
and is obligated to make the postcondition true in that case.

@cindex expressions, in assertions
@cindex assertions, expressions in
@kindex @code{\result}
In general, pre- and postconditions in JML are written using an
extended form of Java expressions.
In this case, the only extension visible is the keyword @code{\result},
which is used in the postcondition to denote the value returned by the method.
The type of @code{\result} is the return type of the method;
for example, the type of @code{\result} in @code{isqrt} is
@code{int}.
The postcondition says that the result is an integer approximation to the
square root of @code{y}.  The first conjunct on line 6,
@code{0 <= \result}
say that the result is non-negative.
The second and third conjuncts state that the result is an integer
approximation to the square root of the argument @code{y}.
The second conjunct, on line 7, says that the result squared is no
larger than the argument, @code{y}.
The third conjunct, on lines
8--9, is an implication; it has two expressions connected by
@code{==>}, which means implication in JML.
This implication says that if the result plus one squared is
non-negative, then the result plus one squared is strictly larger than
@code{y}.@footnote{
The result plus one squared will become negative if the result is
larger than 46340, due to integer overflow.
Patrice Chalin pointed out that in an earlier version of this
specification there were overflow problems [Chalin02].
In Java integer arithmetic, one plus the maximum integer is the
minimum integer. 
This specification deals with such problems by limiting the result to
be a positive integer and by the implication on lines 8-9.
See the specification of @code{IntMathOps2} below for another way to deal with
these problems.
}
Note that the behavioral specification does not give an algorithm for finding
the square root.

@cindex documentation comment, specification in
@cindex annotations, in documentation comments
@cindex javadoc comments
@kindex @code{<pre><jml>}
@kindex @code{<jml>}
@kindex @code{</jml>}
@kindex @code{</pre></jml>}
@kindex @code{<pre><esc>}
@kindex @code{<esc>}
@kindex @code{</esc>}
@kindex @code{</pre></esc>}
Method specifications may also be written in Java's documentation comments.
The following is an example.  The part that JML sees is enclosed within
the HTML ``tags'' @code{<jml>} and @code{</jml>}.@footnote{
Since HTML tags are not case sensitive, in this one place JML
is also not case sensitive.
That is, the syntax also permits the tags @code{<JML>}, @code{</JML>}.
For compatibility with ESC/Java, JML also supports the tags
@code{<esc>}, @code{</esc>}, @code{<ESC>}, and @code{</ESC>}.}
As in this example, one can use surrounding
tags @code{<pre>} and @code{</pre>} to tell javadoc to ignore what JML sees,
and to leave the formatting of it alone.  The @code{<pre>} and @code{</pre>}
tags are not 
required by JML tools (including jmldoc, which does a better job of formatting
specifications than does javadoc).

@pindex @code{IntMathOps4.java}
@example
@group
@include local/IntMathOps4.java.texinfo
@end group
@end example

@cindex .java files
@cindex .jml-refined files
@cindex refinement
Because we expect most of our users to write specifications in Java
code files, most of our examples will be given as annotations
in @file{.java} files as in the specifications above.
However, it is possible to use JML to write documentation in separate,
non-Java files,
such as the file @file{IntMathOps2.jml-refined} below.
Since these files are not Java program files,
JML requires the user to omit the code for concrete methods in such a
file (except that code for ``model'' methods can be present,
@pxref{Purity}).
The specification below shows how this is done, using a semicolon (@code{;}),
as in a Java abstract method declaration.

@pindex @code{IntMathOps2.jml-refined}
@example
@group
@include local/IntMathOps2.jmlrefined.texinfo
@end group
@end example

@cindex annotations
@cindex @file{.jml}
@cindex @file{.jml-refined}
@cindex @file{.spec}
@cindex @file{.spec-refined}
Besides files with suffixes of @file{.jml-refined} or @file{.jml},
JML also works with files with the suffixes @file{.spec}
and @file{.spec-refined}.
All these files use Java's syntax, and one must use annotation markers
just as in a @file{.java} file.
However, since these kinds of files files are not Java files,
in such a file one must also omit the code for concrete, non-model methods.

@cindex annotation markers
@kindex @code{spec_bigint_math}
The specification of @code{IntMathOps2} below
is written in @code{spec_bigint_math} mode [Chalin04].
This means that integer mathematics inside the specifications in the
class @code{IntMathOps2} are done in infinite precision arithmetic,
instead of the usual Java arithmetic.  This leads to a simpler
specification, especially in the ensures clause.@footnote{
@cindex @code{/*+@@} vs. @code{/*@@} annotations
Because the current ESC/Java2 tool does not
understand @code{spec_bigint_math} mode,
the specification uses uses annotation markers
@code{/*+@@} and @code{@@+*/}.
These markers are understood by the ISU JML tools, but are considered to
be comments by ESC/Java2.
}

@kindex @code{ensures}, multiple
@kindex postcondition, multiple
The above specification also demonstrates that ensures clauses can be
repeated in a specification.  In @code{IntMathOps2}'s specification of
@code{isqrt}, there are three ensures clauses; all of them must be
satisfied. Thus the meaning is the same as the conjunction of all of
the postconditions specified in the individual ensures clauses.
This specification is also more underspecified than the specifications
given previously, as it allows negative numbers to be returned as results.

@kindex @code{refine}
The above specification would be implemented
in the file @file{IntMathOps2.java},
which is shown below.
This file contains a @code{refine} clause,
which tells the reader of the @file{.java}
file what is being refined
and the file in which to find its specification.

@pindex @code{IntMathOps2.java}
@example
@group
@include local/IntMathOps2.java.texinfo
@end group
@end example

To summarize, a behavioral interface specification describes both the
interface details of a module, and its behavior.
The interface details are written in the syntax of the programming language;
thus JML uses the Java declaration syntax.
The behavioral specification uses pre- and postconditions.

@node Lightweight Specifications, Goals, Behavioral Interface Specification, Introduction
@c  node-name,  next,  previous,  up
@section Lightweight Specifications

@cindex heavyweight specification
@cindex lightweight specification
@cindex ESC/Java
Although we find it best to illustrate JML's features in this paper using
specifications that are detailed and complete, one
can use JML to write less detailed specifications.
In particular, one can use JML to write ``lightweight''
specifications (as in ESC/Java).  The syntax of JML allows one to write
specifications that consist of individual clauses, so that one can say
just what is desired.  More precisely, a @dfn{lightweight} specification
is one that does not use a behavior keyword  (like
@code{normal_behavior}).
By way of contrast, we call a specification a @dfn{heavyweight}
specification if it uses one of the behavior keywords.

For example, one might wish to specify just that @code{isqrt}
should be called only on positive arguments, but not want to be
bothered with saying anything formal about the locations
that can be assigned to by the method or about the result.
This could be done as shown below.
Notice that the only specification given below is
a single @code{requires} clause.
Since the specification of @code{isqrt} has no behavior keyword,
it is a lightweight specification.

@pindex @code{IntMathOps3.java}
@example
@group
@include local/IntMathOps3.java.texinfo
@end group
@end example

@cindex default privacy
@kindex @code{public}, omitted
@cindex omitted privacy in specification
What is the access restriction, or privacy level,
of such a lightweight specification?
The syntax for lightweight specifications does not
have a place to specify the privacy level,
so JML assumes that such a lightweight specification
has the same level of visibility as the method itself.
(Thus, the specification below is implicitly @code{public}.)
What about the omitted parts of the specification, such as the ensures clause?
JML assumes nothing about these.
In the example below when the precondition is met,
an implementation might either signal an
exception or terminate normally, so this specification technically
allows exceptions to be thrown. However, the gain in brevity often
outweighs the need for this level of precision.

@cindex default, for @code{requires} clause
@kindex @code{requires}
JML has a semantics that allows most clauses to be sensibly omitted
from a specification.  When the @code{requires} clause is omitted, for
example, it means that no requirements are placed on the caller.  When
the @code{assignable} clause is omitted, it means that nothing is
promised about what locations may not be assigned to by the method;
that is, the method may assign to all locations that it can otherwise
legally assign to.  When the @code{ensures} clause is omitted, it
means that nothing is promised about the state resulting from a method
call.  @xref{Specification Case Defaults}, for the default meanings of
various other clauses.

@node Goals, Tool Support, Lightweight Specifications, Introduction
@c  node-name,  next,  previous,  up
@section Goals

@cindex goals, of JML
As mentioned above,
the main goal of our research is to better understand
how to develop BISLs (and BISL tools)
that are practical and effective.
We are concerned with both technical requirements
and with other factors such as training and documentation,
although in the rest of this paper we will only be concerned with
technical requirements for the BISL itself.
The practicality and
effectiveness of JML will be judged by how well
it can document reusable class libraries, frameworks, and
Application Programming Interfaces (APIs).

We believe that to meet the overall goal of practical and effective
behavioral interface specification,
JML must meet the following subsidiary goals.
@itemize @bullet
@item
JML must be able to document the interfaces and behavior of existing software,
regardless of the analysis and design methods used to create it.

If JML were limited to only handling certain Java features,
certain kinds of software, or software designed according to certain
analysis and design methods,
then some APIs would not be amenable to documentation using JML.
This would mean that some existing software could not be documented
using JML.
Since the effort put into writing such documentation will have a proportionally
larger payoff for software that is more widely reused,
it is important to be able to document existing software components.

(However, it should be noted that we make some exceptions to this goal.
One is that JML requires that all subtypes be behavioral subtypes
[Dhara-Leavens96] [Leavens97c] [Wing87] of their supertypes.
This is done because otherwise one cannot reason modularly about
programs that use subtyping and dynamic dispatch.
Another is that we specify @code{Object}'s method @code{equals} as a
pure method, which prohibits even benevolent side effects in any
@code{equals} method that takes an @code{Object} as an argument.  This
is done to permit purity checking for collection classes that contain
objects as members and use @code{equals} to compare them, as in the
collection types found in @code{java.util}.)

@item
The notation used in JML should be readily understandable by Java programmers,
including those with only standard mathematical training.

@cindex Finney
@cindex Hayes
@cindex Spivey
@cindex Woodcock
@cindex Davies
@cindex Z, specification language
A preliminary study by Finney [Finney96] indicates that
graphic mathematical notations,
such as those found in Z [Hayes93] [Spivey92] [Woodcock-Davies96]
may make such specifications
hard to read, even for programmers trained in the notation.
This accords with our experience in teaching formal specification notations
to programmers.
Hence, our strategy for meeting this goal has been to shun most special-purpose
mathematical notations in favor of Java's own expression syntax.

@item
The language must be capable of being given a rigorous, formal semantics,
and must also be amenable to tool support.

This goal also helps ensure that the specification language does not suffer
from logical problems, which would make it less useful for
static analysis, prototyping, and testing tools.
@end itemize

@cindex Wahls
@cindex Leavens
@cindex Baker
@cindex prototyping from specifications
We also have in mind a long range goal of a specification compiler,
that would produce prototypes from specifications that happen to be 
constructive [Wahls-Leavens-Baker00].

@cindex Compaq SRC
@cindex University of Nijmegen
@cindex Nijmegen, University of
@cindex ESC/Java
Our partners at Compaq SRC and the
University of Nijmegen have other goals in mind.  At Compaq SRC, the
goal is to make static analysis tools for Java programs that can help
detect bugs.  At the University of Nijmegen, the goal is to be able to
do full program verification on Java programs.

@cindex Meyer
@cindex Wing
@cindex Larch
@cindex Eiffel
@cindex Guttag
@cindex Horning
@cindex Leavens
@cindex refinement calculus
@cindex Back
@cindex von Wright
@cindex Morgan
@cindex Vickers
As a general strategy for achieving these goals,
we have tried to blend the Eiffel [Meyer92a] [Meyer92b] [Meyer97],
Larch [Wing87] [Wing90a] [Guttag-Horning93] [LeavensLarchFAQ],
and refinement calculus
[Back88] [Back-vonWright98] [Morgan-Vickers94] [Morgan94]
approaches to specification.
From Eiffel we have taken the idea that assertions can be written in
a language that is based on Java expressions.
@kindex @code{\old}
We also adapt the ``@code{old}'' notation from Eiffel,
which appears in JML as @code{\old},
instead of the Larch-style annotation of names with state functions.
However, Eiffel specifications, as written by Meyer,
are typically not as detailed as model-based specifications
written, for example, in Larch BISLs or in
@cindex VDM-SL
@cindex Fitzgerald
@cindex Larsen
@cindex ISO
@cindex Jones
VDM-SL [Fitzgerald-Larsen98] [ISO96] [Jones90].
Hence, we have combined these approaches, by using syntactic ideas
from Eiffel and semantic ideas from model-based specification languages.

@cindex Eiffel
@cindex Sather
@cindex Sather-K
@cindex specification-only declaration
@cindex quantifiers
@cindex side-effects
JML also has some other differences from Eiffel
(and its cousins Sather and Sather-K).
The most important is the concept of specification-only
declarations.
These declarations allow more abstract and exact specifications of behavior
than is typically done in Eiffel;
they allow one to write specifications that are similar to the spirit of VDM
or Larch BISLs.
A major difference is that we have extended
the syntax of Java expressions with quantifiers and other constructs
that are needed for logical expressiveness, but which are not always
executable.
Finally, we ban side-effects
and other problematic features of code in assertions.

@cindex Larch/C++
@cindex model-based specification
On the other hand,
our experience with Larch/C++ has taught us to adapt
the model-based approach in two ways, with the aim of making it more
practical and easy to learn.
The first adaptation is again the use of specification-only
model variables.
An object will thus have (in general) several such @dfn{model fields},
which are used only for the purpose of describing, abstractly, the values
of objects.
This simplifies the use of JML, as compared with most Larch BISLs,
since specifiers (and their readers)
hardly ever need to know about algebraic-style specification.
It also makes designing a model for a Java class or interface similar,
in some respects, to designing an implementation data structure in Java.
We hope that this similarity
will make the specification language easier to understand.
(This kind of model also has some technical advantages
that will be described below.)

@cindex Larch
@cindex Wing
@cindex pure method
@cindex mathematical modeling
The second adaptation is hiding the details of mathematical
modeling behind a facade of Java classes.
In the Larch approach to behavioral interface specification [Wing87],
the mathematical notation used in assertions is presented directly
to the specifier.
This allows the same mathematical notation to be used in many different
specification languages.
However, it also means that the user of such a specification language has to
learn a notation for assertions that is different than their programming
language's notation for expressions.
In JML we use a compromise approach, hiding these details behind Java classes.
These classes have objects with many ``pure'' methods,
in the sense that they do not use side-effects
(at least not in any observable way).
Such classes are intended to present the underlying
mathematical concepts using Java syntax.
Besides insulating the user of JML from the details of the mathematical
notation, this compromise approach also insulates the design of JML
from the details of the mathematical logic used for theorem proving.

@cindex refinement calculus
@cindex Back
@cindex von Wright
@cindex Morgan
@cindex Vickers
@cindex B@"uchi
@cindex Weck
We have generally taken features wholesale from the refinement calculus
[Back88] [Back-vonWright98] [Morgan-Vickers94] [Morgan94].
Our adaptation of it consists in blending it with the idea
of interface specification and adding features for object-oriented programming.
We are using the adaptation of the refinement calculus by
B@"uchi and Weck [Buechi-Weck00],
which helps in specifying callbacks.
However, since the refinement calculus is mostly needed for advanced
specifications, in the remainder of this paper 
we do not discuss the JML features related to refinement,
such as model programs.

@node Tool Support, Outline, Goals, Introduction
@c  node-name,  next,  previous,  up
@section Tool Support

@cindex ESC/Java, goals
@cindex Compaq SRC
@cindex Leino
Our partners at
Compaq SRC have built a tool, ESC/Java, that does static analysis
for Java programs [Leino-etal00].
ESC/Java uses a subset of the JML specification syntax,
to help detect bugs in Java code.
@cindex Loop
@cindex University of Nijmegen
@cindex Nijmegen, University of
@cindex Huisman
@cindex Jacobs
At the University of Nijmegen the LOOP tool [Huisman01] [Jacobs-etal98] 
is being adapted to use JML
as its input language.  This tool would generate verification conditions
that could be checked using a theorem prover such as PVS or Isabelle/HOL.
@cindex Daikon invariant detector
@cindex Ernst
@cindex MIT
At the Massachusetts Institute of Technology (MIT),
the Daikon invariant detector project [Ernst-etal01]
is using a subset of JML to record invariants detected by runs of a program.
Recent work uses ESC/Java to validate the invariants that are found.

@cindex Iowa State, release of JML
@cindex release, of JML
@cindex checker
@cindex JML checker
@cindex tool support, for JML
In the rest of the section we concentrate on the tool support found in
the JML release from Iowa State.
Iowa State's JML release
has tool support for: static type checking of specifications,
run-time assertion checking, generation of HTML pages,
and generation of unit testing harnesses.
Use a web browser on the @file{JML.html} file in the Iowa State JML release
to access more detailed documentation on these tools.

@menu
* Type Checking Specifications::  
* Generating HTML Documentation::  
* Run Time Assertion Checking::  
* Unit Testing with JML::       
@end menu

@node Type Checking Specifications, Generating HTML Documentation, Tool Support, Tool Support
@c  node-name,  next,  previous,  up
@subsection Type Checking Specifications

@cindex type checking, of specifications
@cindex checker, for JML
@cindex JML checker
@cindex @code{jml} script
@cindex command for checking JML files
Details on how to run the JML checker can be found in its manual page,
which is part of the JML release.
Here we only indicate the most basic uses of the
checker.  Running the checker with filenames as arguments will perform
type checking on all the specifications contained in the given files.
For example, one could check the specifications in the file
@file{UnboundedStack.java} by executing the following command.

@example
   jml UnboundedStack.java
@end example

One can also pass several files to the checker.
For example, the following shows a handy pattern to catch all of the JML
files in the current directory.

@example
   jml *.*j* *.*spec*
@end example

@cindex directory, argument to jml script
One can also pass directories to the JML checker, for example
the following will check all the specifications in the current directory.

@example
   jml .
@end example

@cindex -R option to jml script
By default, the checker does not recurse into subdirectories, but this
can be changed by using the -R option.  For example, the following
checks specifications in the current directory and all subdirectories.
@example
   jml -R .
@end example

@cindex filename suffixes
@cindex suffixes, of filenames
@cindex @file{.refines-java}
@cindex @file{.refines-spec}
@cindex @file{.refines-jml}
@cindex @file{.java}
@cindex @file{.spec}
@cindex @file{.jml}
@cindex @file{.java-refined}
@cindex @file{.spec-refined}
@cindex @file{.jml-refined}
@cindex @file{refines-java} filename suffix
@cindex @file{refines-spec} filename suffix
@cindex @file{refines-jml} filename suffix
@cindex @file{java} filename suffix
@cindex @file{spec} filename suffix
@cindex @file{jml} filename suffix
@cindex @file{java-refined} filename suffix
@cindex @file{spec-refined} filename suffix
@cindex @file{jml-refined} filename suffix
To allow specifications to be split into several files and to allow
documentation of code without changing existing files,
the checker recognizes several filename suffixes.
The checker recognizes several filename suffixes.
The following are considered to be ``active'' suffixes:
@file{.refines-java}, @file{.refines-spec}, @file{.refines-jml},
@file{.java}, @file{.spec}, and @file{.jml};
There are also three ``passive'' suffixes:
@file{.java-refined}, @file{.spec-refined}, and @file{.jml-refined}.
Files with passive suffixes can be used in refinements
(@pxref{Behavioral Interface Specification})
but should not normally be passed explicitly to the checker
on its command line.
Graphical user interface tools for JML should, by default,
only present the active suffixes for selection.
Among files in a directory with the same prefix,
but with different active suffixes, the one whose suffix appears first
in the list of active suffixes above should be considered primary
by such a tool.

@kindex @code{refines}
Files with different suffixes should be connected to each other using
@code{refines} clauses.  We give several examples in the remainder
of this paper.

@node Generating HTML Documentation, Run Time Assertion Checking, Type Checking Specifications, Tool Support
@c  node-name,  next,  previous,  up
@subsection Generating HTML Documentation

@cindex HTML documentation
@cindex hypertext, generation from JML specifications
@cindex @code{jmldoc} script
@cindex @code{javadoc}
To generate HTML documentation that can be browsed on the web, 
one uses the @code{jmldoc} tool.@footnote{ 
The @code{jmldoc} tool is generously provided by David Cok; thanks David!.}
This tool is a replacement for @code{javadoc} that understands JML
specifications.
In addition to generating web pages for JML files and for JML
annotated Java files,
@code{jmldoc} also generates the indexes and other HTML files that
surround these and provide access, in the same way that @code{javadoc} does.

For example, here is how we use @code{jmldoc} to generate the HTML pages for
the MultiJava project. 
@example
rm -fr $HOME/MJ/javadocs
jmldoc -Q -private -d $HOME/MJ/javadocs \
  -link file:/cygwin/usr/local/jdk1.4/docs/api \
  -link file:/cygwin/usr/local/antlr/javadocs \
  --sourcepath $HOME/MJ  \
  org.multijava.dis org.multijava.javadoc org.multijava.mjc \
  org.multijava.mjdoc org.multijava.util org.multijava.util.backend \
  org.multijava.util.classfile org.multijava.util.compiler \
  org.multijava.util.jperf org.multijava.util.lexgen \
  org.multijava.util.msggen org.multijava.util.optgen \
  org.multijava.util.optimize org.multijava.util.testing
@end example

The options used in the above invocation of @code{jmldoc} make jmldoc be
quiet (@code{-Q}), document all members (including private ones) of classes and
interfaces (@code{-private}),  write the HTML files relative to
@file{$HOME/MJ/javadocs} (@code{-d}), link
to existing HTML files for the JDK and for ANTLR (@code{-link}),
and find listed packages relative to @file{$HOME/MJ}
(@code{--sourcepath}).
More details on running @code{jmldoc} are available from its manual
page, which is part of the JML release.

@node Run Time Assertion Checking, Unit Testing with JML, Generating HTML Documentation, Tool Support
@c  node-name,  next,  previous,  up
@subsection Run Time Assertion Checking

@cindex run-time assertion checking
@cindex runtime assertion checking
@cindex dynamic, assertion checking
@cindex assertion checking
@cindex invariant checking
@cindex precondition checking
@cindex postcondition checking
@cindex @code{jmlc} script
The JML runtime assertion checking compiler is called @code{jmlc}.
It type checks assertions (so there is no need to run @code{jml}
separately), and then generates a class file with the executable parts
of the specified assertions, invariants, preconditions, and postconditions
(and other JML constructs)
checked at run-time.
Its basic usage is similar to a Java compiler, as shown in
the following example.

@example
   jmlc TestUnboundedStack.java UnboundedStack.java
@end example

This will produce output telling what the compiler is doing, as well
as class files
@file{TestUnboundedStack.class} and @file{UnboundedStack.class}.

@cindex @code{jmlrac} script
To run or test a program compiled with @code{jmlc}, you should use the 
script @code{jmlrac}.  The @code{jmlrac} script
runs the resulting code with a @code{CLASSPATH}
that includes various JAR files containing code needed for run-time assertion
checking. The following is an example.

@example
   jmlrac org.jmlspecs.samples.stacks.TestUnboundedStack
@end example

Using the @code{jmlrac} script is necessary.
If you do not use @code{jmlrac} to run the program, you will
get errors, since the code that @code{jmlc} compiles expects various
runtime library classes to be available.

@cindex Cheon, Yoonsik
More details on invoking @code{jmlc} and @code{jmlrac} are available
from their manual pages, which are available in the JML release.
See also the @file{README.html} file in the JML release for more
details and troubleshooting tips.
Details on the implementation of @code{jmlc} are found in a paper by
Cheon and Leavens [Cheon-Leavens02b].

@node Unit Testing with JML,  , Run Time Assertion Checking, Tool Support
@c  node-name,  next,  previous,  up
@subsection Unit Testing with JML

@cindex @code{jmlunit} script
@cindex JUnit
@cindex unit testing, with JML
The run time assertion checker is also integrated with a tool, @code{jmlunit}
that can write out a JUnit [Beck-Gamma98]
test oracle class for given Java files.
For example, to generate the classes
@code{UnboundedStack_JML_Test} and 
@code{UnboundedStack_JML_TestData}
from @code{UnboundedStack},
one would execute the following.

@example
   jmlunit UnboundedStack.java
@end example

@cindex test oracle
The file @file{UnboundedStack_JML_Test.java} will then contain code
for an abstract class to drive the tests.  This class uses the runtime
assertion checker to decide test success or failure. (Tests are only
as good as the quality of the specifications; hence the specifications
must be reasonably complete to permit reasonably complete testing.)

@cindex test data
@cindex @code{jml-junit} script
The file @file{UnboundedStack_JML_TestData.java} will contain code for
the superclass of @code{UnboundedStack_JML_Test}
that can be used to fill in test data for such testing.  You need to fill in
the test data in the code for this subclass, as described in the
comments.  The file @file{UnboundedStack_JML_TestData.java} is
produced automatically the first time you run @code{jmlunit} as
described above. However, subsequent runs of @code{jmlunit} never
overwrite or change an @file{_JML_TestData.java} file such as this if
it exists.  Hence it is safe to edit the file to add test data (and
even additional test methods if you wish).

To run the test use the script @code{jml-junit}, as in the following example.

@example
   jml-junit org.jmlspecs.samples.stacks.UnboundedStack_JML_TestData
@end example

More details on invoking these tools can be found in their manual
pages which ship with the JML release.
More discussion on this integration of JML and JUnit are explained
in the ECOOP 2002 paper by Cheon and Leavens [Cheon-Leavens02].

@cindex @code{jtest} script
JML also provides a tool, @code{jtest}, that combines both @code{jmlc}
and @code{jmlunit}.
The @code{jtest} tool both compiles a class
with run-time assertion checks enabled using @code{jmlc},
and also generates the test oracle and test data classes, using
@code{jmlunit}.

@node Outline,  , Tool Support, Introduction
@c  node-name,  next,  previous,  up
@section Outline

In the next sections we describe more about JML
and its semantics.
@xref{Class and Interface Specifications},
for examples that show how Java classes and interfaces are specified;
this section also briefly describes the semantics of subtyping and refinement.
@xref{Extensions to Java Expressions},
for a description of the expressions
that can be used in specifications.
@xref{Conclusions}, for conclusions from our
preliminary design effort.
See the @cite{JML Reference Manual} [Leavens-etal-JMLRef]
for details on the syntax of JML.

@c ------ chapter Class and Interface Specifications --------
@node Class and Interface Specifications, Extensions to Java Expressions, Introduction, Top
@c  node-name,  next,  previous,  up
@chapter Class and Interface Specifications

@cindex class specification
@cindex interface specification
In this section we give some examples of JML class
specifications that illustrate the basic features of JML.

@menu
* Abstract Models::             
* Data Groups::                 
* Types For Modeling::          
* Use of Pure Classes::         
* Composition for Container Classes::  
* Behavioral Subtyping::        
@end menu

@node Abstract Models, Data Groups, Class and Interface Specifications, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Abstract Models

@cindex abstract models
@cindex abstract data types
@cindex ADT, specification of
A simple example of an abstract class specification is the ever-popular
@code{UnboundedStack} type,
which is presented below.
It would appear in a file named @file{UnboundedStack.java}.

@pindex @code{UnboundedStack.java}
@example
@include stacks/UnboundedStack.java.texinfo
@end example

The above specification contains the declaration of a model field, an
invariant, and some method specifications.  These are described below.

@menu
* Model Fields::                
* Invariants::                  
* Method Specifications::       
* Models and Lightweight Specifications::  
@end menu

@node Model Fields, Invariants, Abstract Models, Abstract Models
@c  node-name,  next,  previous,  up
@subsection Model Fields

@cindex model field
@kindex @code{model}
In the fourth non-blank line of @file{UnboundedStack.java},
a model data field, @code{theStack},
is declared.
Since it is declared using the JML modifier @code{model},
such a field is not part of the Java implementation, and must appear
in an annotation;
however, for purposes of the specification we treat it much like any other
Java field (i.e., as a variable location).
That is, we imagine that each instance of the class @code{UnboundedStack}
has such a field.

@cindex @code{org.jmlspecs.models} package
@cindex model classes
@kindex @code{model import}
@cindex model declaration
The type of the model field @code{theStack}
is a type designed for mathematical modeling,
@code{JMLObjectSequence}.
Objects of this type are sequences of objects.
This type is provided by JML in the package @code{org.jmlspecs.models},
which is imported in the second non-blank line of the figure.
Note that this @code{import} declaration is not part of
the Java implementation, since it is modified by the keyword
@code{model}.
Such model imports must also appear in annotation comments.
In general, any declaration form in Java can have the @code{model} modifier,
with the same meaning.  That is, a model declaration is only
used for specification purposes, and does not have to appear in
an implementation.

@kindex @code{initially}
@cindex RESOLVE
@cindex Ogden
@cindex Back
@cindex von Wright
@cindex Morgan
@cindex Vickers
@cindex Hoare
@cindex Wing
@cindex data type induction
At the end of the model field's declaration
above
is an @code{initially} clause.
(Such clauses are adapted from RESOLVE [Ogden-etal94]
and the refinement calculus
[Back88] [Back-vonWright98] [Morgan-Vickers94] [Morgan94].)
Model fields cannot be explicitly initialized (and thus cannot be
final), because there is no storage directly associated with them.
However, one can use an @code{initially} clause to describe an
abstract initialization for a model field.
Initially clauses can be attached to any field declaration, including
non-model fields, and permit one to constrain the initial values
of such fields.
Knowing something about the initial value of the field
permits data type induction [Hoare72a] [Wing83]
for abstract classes and interfaces.
The @code{initially} clause must be true
of the field's starting value.
That is,
all reachable objects of the type @code{UnboundedStack}
must have been created
as empty stacks and subsequently modified using the type's methods.

@node Invariants, Method Specifications, Model Fields, Abstract Models
@c  node-name,  next,  previous,  up
@subsection Invariants

@kindex @code{invariant}
@cindex publicly visible state
@cindex non-null
@kindex @code{helper}
Following the model field declaration is an invariant.
An invariant does not have to hold during the execution
of an object's methods,
but it must hold, for each reachable object
in each @dfn{publicly visible state};
i.e., for each state outside of a public method or constructor's execution,
and at the beginning and end of each public method's
execution.@footnote{
In JML invariants also apply to non-public methods as well.  The only
exception is that a private method or constructor may 
be marked with the @code{helper} modifier; such methods cannot assume
and do not need to establish the invariant.
}
The figure's invariant just says that the value of @code{theStack}
should never be @code{null}.

@node Method Specifications, Models and Lightweight Specifications, Invariants, Abstract Models
@c  node-name,  next,  previous,  up
@subsection Method Specifications

@cindex method specification
Following the invariant are the specifications of
the methods @code{pop}, @code{push}, and @code{top}.
We describe the new aspects of these specifications below.

@menu
* The Assignable Clause::       
* Old Values::                  
* Reference Semantics::         
* Correct Implementation::      
@end menu

@node The Assignable Clause, Old Values, Method Specifications, Method Specifications
@c  node-name,  next,  previous,  up
@subsubsection The Assignable Clause

@kindex @code{assignable}
@kindex @code{modifiable}, see @code{assignable}
@kindex @code{modifies}, see @code{assignable}
@cindex ESC/Java
@cindex Leino
@cindex modifies clause
@cindex assignable clause
@cindex frame axiom, see assignable clause
The use of the @code{assignable}@footnote{ For historical reasons, one
can also use the keyword @code{modifiable} as a synonym for
@code{assignable}.  Also, for compatibility with (older versions of)
ESC/Java [Leino-etal00], in JML, one can also use the keyword
@code{modifies} as a synonym for @code{assignable}.  In the
literature, the most common keyword for such a clause is
@code{modifies}, and what JML calls the ``assignable clause'' is
usually referred to as a ``modifies clause''.  However, in JML,
``assignable'' most closely corresponds to the technical meaning, so
we use that throughout this document.  Users of JML may write
whichever they prefer, and may mix them if they please.}  clauses in
the behavioral specifications of @code{pop} and @code{push}
@cindex Eiffel
is interesting (and another difference from Eiffel).
@cindex Borgida
@cindex Mylopoulos
@cindex Reiter
These clauses give frame conditions [Borgida-Mylopoulos-Reiter95].
@cindex assignable clause, semantics of
In JML, the frame condition given by a method's assignable clause
only permits the method to assign to a location, @i{loc}, if:
@itemize @bullet
@item
@i{loc} is mentioned in the method's @code{assignable} clause,

@item
@i{loc} is a member of a data group mentioned in the 
method's @code{assignable} clause (@pxref{Data Groups}),

@item
@i{loc} was not allocated when the method started execution, or

@item
@i{loc} is local to the method (i.e., a local variable, including the
method's formal parameters).
@end itemize
For example, @code{push}'s specification says that it may only assign
to @code{theStack} (and locations in @code{theStack}'s data group).
This allows @code{push} to assign to @code{theStack} (and the members
of its data group), or to call some other method that makes such an
assignment.  Furthermore, @code{push} may assign to the formal
parameter @code{x} itself, even though that location is not listed in
the @code{assignable} clause, since @code{x} is local to the method.
However, @code{push} may not assign to fields not mentioned in the
@code{assignable} clause; in particular it may not assign to fields of
its formal parameter @code{x},@footnote{Assuming that @code{x} is not
the same object as @code{this}!}  or call a method that makes such an
assignment.

@cindex assignable clause, checks
The design of JML is intended to allow tools to statically check the
body of a method's implementation to determine whether its
@code{assignable} clause is satisfied.  This would be done by checking
each assignment statement in the implementation to see if what is
being assigned to is a location that some @code{assignable} clause
permits.  It is an error to assign to any other allocated, non-local
location.  However, to do this, a tool must conservatively track
aliases and changes to objects containing the locations in question.
Also, arrays can only be dynamically checked, in general.@footnote{
Thanks to Erik Poll for discussions on checking of assignable
clauses.}  Furthermore, JML will flag as an error a call to a method
that would assign to locations that are not permitted by the calling
method's @code{assignable} clause.  It can do this using the
@code{assignable} clause of the called method.

@cindex modified
@cindex pre-state
@cindex post-state
In JML, a location is @dfn{modified} by a method when it is allocated
in both the pre-state of the method, reachable in the post-state, and
has a value that is different in these two states.  The
@dfn{pre-state} of a method call is the state just after the method is
called and parameters have been evaluated and passed, but before
execution of the method's body.  The @dfn{post-state} of a method call
is the state just before the method returns or throws an exception; in
JML we imagine that @code{\result} and information about exception
results is recorded in the post-state.

@kindex @code{new}
@cindex allocation, vs. modification
Since modification only involves objects allocated in the pre-state,
allocation of an object, using Java's @code{new} operator, does not
itself cause any modification.  Furthermore, since the fields of new
objects are locations that were not allocated when the method started
execution, they may be assigned to freely.

@cindex local variables, and assignable clause
@cindex formal parameters, and assignable clause
The reason assignments to local variables are permitted by the
assignable clause is that a JML specification takes the client's
(i.e., the caller's) point of view.  From the client's point of view,
the local variables in a method are newly-allocated, and thus
assignments to such variables are invisible to the client.  Hence, in
JML, it is an error to list the locations corresponding to formal
parameters in the @code{assignable} clause.
However, the locations corresponding to fields or array elements of
such formal parameters can be sensibly mentioned in 
the @code{assignable} clause.
Furthermore, when formal
parameters are used in a postcondition, JML interprets these as
meaning the value initially given to the formal in the pre-state,
since assignments to the formals within the method do not matter to
the client.

@cindex temporary side effects
@cindex benevolent side effect
@cindex Ruby
@cindex Leavens
@cindex Leino
JML's interpretation of the assignable clause does not permit
either temporary side effects or benevolent side effects.
A method with a @dfn{temporary side effect} assigns to a location,
does some work, and then assigns the original value back to that location.
In JML, a method may not have temporary side effects
on locations that it is not permitted to modify
[Ruby-Leavens00].
A method has a @dfn{benevolent side effect}
if it assigns to a location in a way that is not observable by clients.
In JML, a method may not have benevolent side effects on locations
that it is not permitted to modify  [Leino95] [Leino95a].

@cindex modify, locations a method can
@cindex assign to, locations a method can
Because JML's assignable clauses give permission
to assign to locations, it is safe for clients to assume that
only the listed locations (and locations of their data group members)
may have their values modified.
Because locations listed in the @code{assignable} clause are the only
ones that can be modified, we often speak of what locations a method can
``modify,'' instead of the more precise ``can assign to.''

@cindex model variables, modification of
@cindex assignment, to model variables
@cindex modification, of model variables
What does the assignable clause say about the modification of locations?
In particular, although the ``location'' for a model field
or model variable cannot be directly assigned to in JML,
its value is determined by the concrete fields and variables
that it (ultimately) depends on, specifically the members of its 
data group. 
That is, a model field or variable can be modified by assignments
to the concrete members of its data group (@pxref{Data Groups}). 
Thus, a method's assignable clause only
permits the method to modify a location if the location:
@itemize @bullet
@item
is mentioned in the method's @code{assignable} clause,

@item
is a member of a data group mentioned in the @code{assignable} 
clause (@pxref{Data Groups}),

@item
was not allocated when the method started execution, or

@item
is local to the method.
@end itemize

@kindex @code{\nothing}
@kindex @code{assignable}
@cindex frame axiom
@cindex omitted, assignable clause
@cindex Larch, differences from
In the specification of @code{top},
the assignable clause says that a call to @code{top} that satisfies
the precondition cannot assign to any locations.
It does this by using the @var{store-ref} ``@code{\nothing}.''
Unlike some formal specification languages (including Larch BISLs and
older versions of JML),
when the @code{assignable} clause is omitted in a heavyweight
specification, the default @var{store-ref} for the assignable 
clause is @code{\everything}. 
Thus an omitted assignable clause in JML means that the method can assign 
to all locations (that could otherwise be assigned to by the method). 
Such an assignable clause plays havoc with formal
reasoning, and thus if one cares about verification, one should give
an assignable clause explicitly if the method is not pure
(@pxref{Purity}).

@node Old Values, Reference Semantics, The Assignable Clause, Method Specifications
@c  node-name,  next,  previous,  up
@subsubsection Old Values

@cindex old values
@kindex @code{\old}
@cindex Eiffel
When a method can modify some locations, they may have different
values in the pre-state and post-state of a call.
Often the post-condition must refer to the values held
in both of these states.
JML uses a notation similar to Eiffel's to refer
to the pre-state value of a variable.
In JML the syntax is @code{\old(}@i{E}@code{)}, where @i{E} is an expression.
(Unlike Eiffel, we use parentheses following @code{\old}
to delimit the expression to be evaluated in the pre-state explicitly.
JML also uses backslashes (@code{\\}) to mark the keywords it uses in
expressions; this avoids interfering with Java program identifiers,
such as ``@code{old}''.)

@cindex @code{\old}, semantics of
@cindex @code{\old}, pitfalls of
The meaning of @code{\old(}@i{E}@code{)} is as if @i{E} were evaluated
in the pre-state and that value is used in place of
@code{\old(}@i{E}@code{)} in the assertion.
It follows that, an expression like @code{\old(myVar).theStack}
may not mean what is desired,
since only the old value of @code{myVar} is saved;
access to the field @code{theStack} is done in the post-state.
If it is the field, @code{theStack}, not the variable, @code{myVar},
that is changing, then probably
what is desired is @code{\old(myVar.theStack)}.
To avoid such problems, it is good practice to have the expression @i{E}
in @code{\old(}@i{E}@code{)}
be such that its type is either the type of a primitive value,
such as an @code{int}, or a type with immutable objects,
such as @code{JMLObjectSequence}.

As another example, in @code{pop}'s postcondition
the expression @code{\old(theStack.trailer())}
has type @code{JMLObjectSequence}, so it is immutable.
The value of @code{theStack.trailer()} is computed
in the pre-state of the method.

@node Reference Semantics, Correct Implementation, Old Values, Method Specifications
@c  node-name,  next,  previous,  up
@subsubsection Reference Semantics

@cindex reference semantics
@cindex reference types, and equality tests
@cindex @code{==}, vs. equals
@cindex equals, vs. @code{==}
Note also that, since @code{JMLObjectSequence} is a reference type,
one must use @code{equals} instead of @code{==} to compare
instances of this type for equality of values.  For example, in
the postcondition of the @code{pop} method, we use @code{equals}
to compare @code{theStack} and @code{\old(theStack.trailer())},
as these may yield different objects.
Using @code{==} would be a mistake, since it would only compare them
for object identity.

@cindex @code{==}, vs equals
@cindex equals, vs. @code{==}
@cindex equality, guidelines for comparing
@cindex reference types
@cindex reference semantics, and equality
As in Java itself, most types are reference types, and hence many expressions
yield references (i.e., object identities or addresses),
as opposed to primitive values.
This means that @code{==}, except when used to compare
pure values of primitive types such as @code{boolean} or @code{int},
is reference equality.
As in Java,
to get value equality for reference types one uses the
@code{equals} method in assertions.
For example, the predicate
@code{myString == yourString}, is only true if
the objects denoted by @code{myString} and @code{yourString} are the
same object (i.e., if the names are aliases);
to compare their values one must write
@code{myString.equals(yourString)}.

@node Correct Implementation,  , Reference Semantics, Method Specifications
@c  node-name,  next,  previous,  up
@subsubsection Correct Implementation

@cindex correctness
@cindex correct implementation
@cindex satisfaction, see correct implementation
@cindex Poetzsch-Heffter
@cindex finiteness constraints
@kindex @code{normal_behavior}
@kindex @code{requires}
@kindex @code{assignable}
@kindex @code{ensures}
@cindex normal termination
@cindex termination, normal
@cindex error, in Java virtual machine
@cindex Java, failures in virtual machine
The specification of @code{push} does not have a @code{requires}
clause.
This means that the method imposes no obligations on the caller.
(The meaning of an omitted @code{requires} clause
is that the method's precondition is @code{true}, which
is satisfied by all states, and hence imposes no obligations on the caller.)
This seems to imply that the implementation must provide
a literally unbounded stack, which is surely impossible.
We avoid this problem, by following Poetzsch-Heffter [Poetzsch-Heffter97]
in releasing implementations from their obligations
to fulfill the postcondition when Java runs out of storage.
In general, a method specified with @code{normal_behavior}
has a correct implementation if,
whenever it is called in a state that satisfies
its precondition, either
@itemize @bullet
@item
the method terminates normally in a state that satisfies its postcondition,
having assigned to only the locations permitted by its @code{assignable}
clause, or

@item
Java signals an error,
by throwing an exception that inherits from @code{java.lang.Error}.
@end itemize
We discuss the specification of methods with exceptions in the next
subsection.

@node Models and Lightweight Specifications,  , Method Specifications, Abstract Models
@c  node-name,  next,  previous,  up
@subsection Models and Lightweight Specifications

@cindex lightweight specifications
@kindex @code{spec_public}
@kindex @code{spec_protected}
@cindex desugaring for @code{spec_public} and @code{spec_protected}
In specifying existing code, one often does not want to introduce new
model fields or think up new names for them.  And sometimes,
especially for fields with simple, atomic values, the field name
itself is so ``natural'' that it would be difficult to think up a second
good name for a model field that would be an abstraction of it.
Thus JML provides two modifiers, @code{spec_public} and
@code{spec_protected} that can used to make existing fields public or
protected, for purposes of specification.

For example, consider the (lightweight) specification of the class
@code{Point2D} below.  In this specification the private fields,
@code{x} and @code{y} are specified as @code{spec_public}, which
allows them to be used in the public invariant clause and in the
(implicitly public) specifications of the constructors and methods of
@code{Point2D}. 

@pindex @code{Point2D.java}
@example
@include local/Point2D.java.texinfo
@end example

Note that these specifications would be illegal without the use of
@code{spec_public}, since JML requires that public specifications only
mention publicly-visible names
(@pxref{Behavioral Interface Specification}).

@cindex @code{spec_public}, as a model field shorthand
@cindex model fields, from @code{spec_public}
@cindex @code{spec_protected}, as a model field shorthand
@cindex model fields, from @code{spec_protected}
However, @code{spec_public} is more than just a way to change the
visibility of a name for specification purposes.  When applied to
fields it can be considered to be shorthand for the declaration of a
model field with the same name.  That is, the declaration of @code{x}
in @code{Point2D} can be thought of as equivalent to the following
declarations, together with a rewrite of the Java code that uses @code{x} to
use @code{_x} instead (where we assume @code{_x} is not used elsewhere).

@example
  //@@ public model int x;
  private int _x; //@@ in x;
  //@@ private represents x <- _x;
@end example

@noindent
So in this way of thinking @code{spec_public} is not
just an access modifier, but shorthand for declaration of a model
field.  This model field declaration is a commitment to readers that
they can understand the specification using these model fields, even
if the underlying private fields are changed, just as if the model
field were declared explicitly.
The model fields that are implicit allow such changes to be made without
affecting the readers of the specification.

For example, suppose one wanted to change the implementation of
@code{Point2D}, to use polar coordinates.
To do that while keeping the public specification
unchanged, one would declare the model fields @code{x} and @code{y}
explicitly.  One would then declare other fields for the polar and
rectangular coordinates (and perhaps additional model fields as well).
One would then also need to give explicit declarations that the new
concrete fields are members of the model fields data groups, and give
appropriate represents clauses.  
(@xref{Data Groups and Represents Clauses}, for more on data group
membership and represents clauses.)
All of this is exactly analogous to what is done implicitly in the the
desugaring described above. 

Similar remarks apply to @code{spec_protected}.  The
@code{spec_public} and @code{spec_protected} shorthands were borrowed
from ESC/Java, but the desugaring described above is novel with JML.

@node Data Groups, Types For Modeling, Abstract Models, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Data Groups

@cindex data groups
@kindex @code{assignable}
@cindex model fields, relating to concrete
@cindex concrete fields, relating to models
@cindex fields, of an ADT
In this subsection we present two example specifications.
The two example specifications,
@code{BoundedThing} and @code{BoundedStackInterface},
are used to describe how model (and concrete) fields can be related
to one another, and how dependencies among them affect the meaning
of the @code{assignable} clause.
Along the way we also demonstrate how to specify methods
that can throw exceptions and other features of JML.

@menu
* Specification of BoundedThing::  
* Specification of BoundedStackInterface::  
@end menu

@node Specification of BoundedThing, Specification of BoundedStackInterface, Data Groups, Data Groups
@c  node-name,  next,  previous,  up
@subsection Specification of BoundedThing

@cindex abstract model
The specification in the file @file{BoundedThing.java},
shown below, is an interface specification
with a simple abstract model.
In this case, there are two model fields @code{MAX_SIZE}
and @code{size}.

@pindex @code{BoundedThing.java}
@example
@include stacks/BoundedThing.java.texinfo
@end example

After discussing the model fields, we describe the other parts
of the specification below.

@menu
* Model Fields in Interfaces::  
* Invariants and History Constraint::  
* Details of the Method Specifications::  
* Adding to Method Specifications::  
* Specifying Exceptional Behavior::  
@end menu

@node Model Fields in Interfaces, Invariants and History Constraint, Specification of BoundedThing, Specification of BoundedThing
@c  node-name,  next,  previous,  up
@subsubsection Model Fields in Interfaces

@cindex model fields, in interfaces
@kindex @code{instance}
In the specification above,
the fields @code{MAX_SIZE} and @code{size} 
are both declared using the modifier @code{instance}.
Because of the use of the keyword @code{instance},
these fields are thus treated as normal model fields,
i.e., as an instance variable in each object that implements this interface.
By default, as in Java, fields are static in interfaces,
and so if @code{instance} is omitted, the field declarations
would be treated as class variables.
The @code{instance} keyword tells the reader
that the variable being declared is not
static, but has a copy in each instance of a class that implements this
interface.

Java does not allow non-static fields to be declared in interfaces.
However,  JML allows non-static model (and ghost) fields in interfaces
when one uses @code{instance}.
The reason for this extension is that such fields
are essential for defining the abstract values and behavior of
the objects being specified.@footnote{
Furthermore, static model fields must have concrete implementations
in the interfaces in which they are declared, if they are to have
any representation at all.
@xref{Data Groups and Represents Clauses}, for more on this subject.
}

In specifications of interfaces that extend
or classes that implement this interface,
these model fields are inherited.
Thus, every object that has a type that is a subtype of the
@code{BoundedThing} interface is thought of, abstractly,
as having two fields, @code{MAX_SIZE} and @code{size},
both of type @code{int}.

@node Invariants and History Constraint, Details of the Method Specifications, Model Fields in Interfaces, Specification of BoundedThing
@c  node-name,  next,  previous,  up
@subsubsection Invariants and History Constraint

@kindex @code{invariant}
Three pieces of class-level specification come after the abstract model
in the above specification.

@cindex instance, invariant
@cindex static, invariant
The first two are @code{invariant} clauses.
Writing several invariant clauses in a specification, like this
is equivalent to writing one invariant clause which is their
conjunction.
Both of these invariants are instance invariants,
because they use the @code{instance} modifier.
By default, in interfaces, invariants and history constraints are
static, unless marked with the @code{instance} modifier.
Static invariants may only refer to static fields, while instance
invariants can refer to both instance and static fields.

The first invariant in the figure says that in every publicly visible state,
every reachable object that is a @code{BoundedThing}
must have a positive @code{MAX_SIZE} field.
The second invariant says that, in each publicly visible state,
every reachable object that is a @code{BoundedThing} must have a size
field that is non-negative and less than or equal to @code{MAX_SIZE}.

@cindex history constraint
@kindex @code{constraint}
@cindex Liskov
@cindex Wing
@cindex subtype
@cindex supertype, specification of
@cindex instance, history constraint
@cindex static, history constraint
Following the invariants is a history constraint [Liskov-Wing94].
Like the invariants, it uses the modifier @code{instance},
because it refers to instance fields.
A history constraint is used to say how values can change between earlier
and later publicly-visible states, 
such as a method's pre-state and its post-state.
This prohibits subtype objects from making certain state changes, even
if they implement more methods than are specified in a given class.
The history constraint in the specification above
says that the value of @code{MAX_SIZE} cannot change,
since in every pre-state and post-state, its value in the post-state,
written @code{MAX_SIZE}, must equal its value in the pre-state,
written @code{\old(MAX_SIZE)}.

@node Details of the Method Specifications, Adding to Method Specifications, Invariants and History Constraint, Specification of BoundedThing
@c  node-name,  next,  previous,  up
@subsubsection Details of the Method Specifications

@cindex method specification
@cindex specification, of methods
@kindex @code{@@}, in annotations
Following the history constraint are the interfaces and specifications
for four public methods.  Notice that, if desired,
the at-signs (@code{@@}) may be omitted from the left sides
of intermediate lines, as we do in this specification.

@kindex @code{==}, to compare values
@kindex @code{<==>}
The use of @code{==} in the method specifications
is okay, since in each case, the things being compared are primitive values,
not references.
The notation @code{<==>} can be read ``if and only if''.  It has the same
meaning for Boolean  values as @code{==}, but has a lower precedence.
Therefore, the expression ``@code{\result <==> size == 0}''
in the postcondition of the @code{isEmpty} method means the same
thing as ``@code{\result == (size == 0)}''.

@node Adding to Method Specifications, Specifying Exceptional Behavior, Details of the Method Specifications, Specification of BoundedThing
@c  node-name,  next,  previous,  up
@subsubsection Adding to Method Specifications

@cindex adding, to method specification
@cindex method specification, addition to
@cindex overriding, and method specifications
@kindex @code{also}
@cindex inheritance, of method specifications
@cindex @code{clone}
The specification of the last method of @code{BoundedThing},
@code{clone}, is interesting.
Note that it begins with the keyword @code{also}.
This form is intended to tell the reader that the specification given is
in addition to any specification that might have been given in the superclass
@code{Object}, where @code{clone} is declared as a protected
method.
A form like this must be used whenever a specification is given for a
method that overrides a method in a superclass, or that implements a
method from an implemented interface.

@node Specifying Exceptional Behavior,  , Adding to Method Specifications, Specification of BoundedThing
@c  node-name,  next,  previous,  up
@subsubsection Specifying Exceptional Behavior

@kindex @code{behavior}, vs. @code{normal_behavior}
@kindex @code{signals}
@kindex @code{exsures}, see @code{signals}
@cindex exceptions, specification of
@cindex specification of exceptions
The specification of @code{clone}
also uses @code{behavior} instead of @code{normal_behavior}.
In a specification that starts this way, one can describe
not just the case where the execution returns normally, but also
executions where exceptions are thrown.
In such a specification, the conditions under
which exceptions can be thrown can be described by the predicate in the
@code{signals} clauses,@footnote{
The keyword ``@code{exsures}'' can also be used in place of @code{signals}.}
and the conditions under which the method may return without throwing
an exception are described by the @code{ensures} clause. 
In this specification, the @code{clone}
method may always throw the exception, because it only needs to make
the predicate ``@code{true}'' true to do so.
When the method returns normally, it must make the given postcondition
true.

@cindex Raghavan
@cindex Leavens
In JML, a @code{normal_behavior} specification can be thought of as a
syntactic sugar for a @code{behavior} specification to which the
following clause is added [Raghavan-Leavens05].

@example
     signals (java.lang.Exception) false;
@end example

@noindent
This formalizes the idea that a method with a @code{normal_behavior}
specification may not throw an exception
when the specification's precondition is satisfied.

@kindex @code{exceptional_behavior}
@cindex Raghavan
@cindex Leavens
JML also has a specification form @code{exceptional_behavior},
which can be used to specify when a method may not return normally.
A specification that uses @code{exceptional_behavior} can be thought of as a
syntactic sugar for a @code{behavior} specification to which the
following clause is added [Raghavan-Leavens05].

@example
     ensures false;
@end example

@noindent
This formalizes the idea that a method with an @code{exceptional_behavior}
specification may not return normally
when the specification's precondition is satisfied.
Thus, when the precondition of such a specification case holds,
some exception must be thrown (unless the execution encounters an
error or is permitted to not return to the caller).

@kindex @code{behavior}, when to use
Since, in the specification of @code{clone}, we want to allow the
implementation to make a choice between either returning normally or
throwing an exception, and we do not wish to distinguish the
preconditions under which each choice must be made,
we cannot use either of the more specialized
forms @code{normal_behavior} or @code{exceptional_behavior}.
Thus the specification of @code{clone}
demonstrates the somewhat unusual case when
the more general form of a @code{behavior} specification is needed.

@kindex @code{signals}
@cindex exceptions, semantics of @code{signals} clauses
@cindex semantics of @code{signals} clauses
@cindex exceptions, prohibiting others
The specification of @code{clone} also illustrates the
@code{signals_only} clause.
The @code{signals_only} clause in the example says that the method may
only throw an exception that is a subtype of
@code{CloneNotSupportedException} when the exceptional behavior's
precondition is true.  This says the same thing as the following,
more verbose, signals clause.

@example
     signals (Exception e) e instanceof CloneNotSupportedException;
@end example

The signals clause itself only describes what must be true when
the exceptions it applies to are thrown; it does not constrain a
method's behavior with respect to exceptions that are not subtypes of
the exceptions named.  For example, a @code{signals} clause of the
form

@example
    signals (CloneNotSupportedException) true;
@end example

@noindent
would only say that a @code{CloneNotSupportedException} can always be thrown;
it would not prohibit other exceptions
that are not subtypes of @code{CloneNotSupportedException} from being
thrown.
For example, if @code{clone} were specified with such a signals
clause, then an implementation could legally throw a
@code{NullPointerException}.  To prevent such a possibility, in many
cases it is preferable to use a @code{signals_only} clause to limit
what exceptions may be thrown. 

@cindex Leavens
@cindex Wing
@cindex protection, in method specification
@cindex undefinedness, protection from
Finally note that in the specification of @code{clone},
the normal postcondition says that the result will be a @code{BoundedThing}
and that its size will be the same as the model field @code{size}.
The use of the cast in this postcondition is necessary,
since the type of @code{\result} is @code{Object}.
(This also adheres to our goal of using Java syntax and
semantics to the extent possible.)
Note also that the conjunct @code{\result instanceof BoundedThing}
``protects'' the next conjunct [Leavens-Wing97a]
since if it is false the meaning of the cast does not matter.

@node Specification of BoundedStackInterface,  , Specification of BoundedThing, Data Groups
@c  node-name,  next,  previous,  up
@subsection Specification of BoundedStackInterface

@cindex inheritance, of instance fields
@kindex @code{instance}
@cindex abstract model, adding to
@cindex adding, to abstract model
@cindex model fields, inheritance of
The specification in the file @file{BoundedStackInterface.java} below
gives an interface for bounded stacks
that extends the interface for @code{BoundedThing}.
Note that this specification can refer to the instance fields
@code{MAX_SIZE} and @code{size} inherited from the
@code{BoundedThing} interface.

@pindex @code{BoundedStackInterface.java}
@example
@include stacks/BoundedStackInterface.java.texinfo
@end example

The abstract model for @code{BoundedStackInterface} adds to the inherited
model by declaring a model instance field named @code{theStack}.
This field is typed as a @code{JMLObjectSequence}.

In the following we describe how the new model instance field,
@code{theStack}, is related to @code{size} from @code{BoundedThing}.
We also use this example to explain more JML features.

@menu
* Data Groups and Represents Clauses::  
* Redundant Specification::     
* Multiple Specification Cases::  
* Pitfalls in Specifying Exceptions::  
* Redundant Ensures Clauses::   
@end menu

@node Data Groups and Represents Clauses, Redundant Specification, Specification of BoundedStackInterface, Specification of BoundedStackInterface
@c  node-name,  next,  previous,  up
@subsubsection Data Groups and Represents Clauses

@kindex @code{in}
@kindex @code{maps}
@kindex @code{represents}
@cindex represents clause
@cindex maps-into clause
@cindex in clause
@cindex abstraction function, see represents clause
@cindex abstraction relation, see represents clause
@cindex inheritance
@cindex ADT, implementation of
@cindex abstract data type, implementation of
The @code{in} and @code{represents} clauses
that follow the declaration of @code{theStack}
are an important feature in modeling
with layers of model fields.@footnote{
Of course, one could specify @code{BoundedStackInterface} without
separating out the interface @code{BoundedThing},
and in that case, these layers would be unnecessary.
We have made this separation partly to demonstrate more advanced features
of JML, and partly to make the parts of the example smaller.}
They also play a crucial role in relating model fields
to the concrete fields of objects,
which can be considered to be the final layer of detail in a design.

@cindex data group
@cindex data group membership
@cindex Leino
@cindex Poetzsch-Heffter
@cindex Zhou
When a model field is declared, a data group with the same name is 
automatically created; 
furthermore, this field is always a @dfn{member of} the group it creates.
A @dfn{data group} is a set of fields (locations) referenced by 
a specific name, i.e., the name of the model field that created it
[Leino98] [Leino-Poetzsch-Heffter-Zhou02].

@cindex assignable clauses, and data groups
@cindex modifies clauses, and data groups
@cindex data groups, and modifies clauses
@cindex data groups, and assignable clauses
@cindex data groups, and frame axioms
@cindex frame axioms, and data groups
@kindex @code{in}
@kindex @code{assignable}
When a data group (or field) is mentioned in the @code{assignable} clause 
for a method @code{M}, then all members (i.e., fields) in that group 
can be assigned to in the body of @code{M}. 
Fields can become a @dfn{member of} a data group through the 
data group clauses (i.e., the @code{in} and @code{maps-into} clauses) that 
come immediately after the field declaration, in this case 
the @code{in} clause. 
The @code{in} clause in @code{BoundedStackInterface}
says that @code{theStack} is a member of the group created by 
the declaration of model field @code{size};
this means that @code{theStack} 
might change its value whenever @code{size} changes.
However, another way of looking at this is that,
if one wants to change @code{size}, this can be done by
changing @code{theStack}.
We also say that @code{theStack} is a @dfn{member of} @code{size}.

@kindex @code{maps}
@kindex @code{\into}
The @var{maps-into} clause is another way of adding members to a data 
group; it allows the fields of an object to 
be included in an existing data group.
For example, if a field @code{F} is a reference or an array type, 
then the fields or array elements of @code{F} can be included in a 
data group using the @var{maps-into} clause.  
The following are examples.
@example
@group
  protected ArrayList elems;
  //@@             maps elems.theList \into theStack;
@end group
@group
  protected java.lang.Object[] theItems;
  //@@             maps theItems[*] \into theStack;
@end group
@end example

In the first example, the @code{maps-into} clause says that 
@code{theList} field of 
@code{elems} is a member of @code{theStack} data group. 
Field @code{elems} is a @dfn{concrete} field of the type 
(i.e., it is not a model field and thus is part of the implementation).  
This allows model field @code{theList} of @code{elems} to change when 
@code{theStack} changes.  
Since @code{theList} is a model field and data group, this also allows
concrete fields of @code{elems} to change as @code{theStack} changes.  
Similarly, the second example says that the elements of the array,
@code{theItems}, can change when @code{theStack} changes.  

Data groups have the same visibility as the model field that declared it, 
i.e, public, protected, private, or package visibility. 
A field cannot be a member of a group that is less visible than it is. 
For example, a public field cannot be a member of a 
protected group.  

@cindex assignable clause, and data groups
@cindex data groups, and assignable clause
@cindex Leino
@cindex information hiding
@cindex hiding concrete fields, in specifications
@cindex data abstraction
@kindex @code{private}
@cindex M@"uller
The @code{in} and @var{maps-into} clauses are important in ``loosening up'' 
the @code{assignable} clause, for example to permit the fields of an object
that implement the abstract model to be changed
[Leino95] [Leino95a].
This ``loosening up'' also applies to model fields
that are members of other groups.
For example, since @code{theStack} is a member of @code{size}, 
whenever @code{size} is mentioned in an @code{assignable} clause,
then @code{theStack} is implicitly allowed to be modified.@footnote{
Note that the permission to assign a field goes from the more abstract
field to the one in its group (which in this case is also abstract).
M@"uller points out that
this direction is necessary for information hiding,
because concrete fields are often hidden (e.g., they may
be @code{private}), and as such cannot appear in public specifications,
so the public specification has to mention the more abstract field,
which give assignment rights to its members [Mueller02].}
Thus it is only for rhetorical purposes that
we mention both @code{size} and @code{theStack}
in the assignable clauses of @code{pop} and @code{push}.
Note, however, that just mentioning @code{theStack} would not permit
@code{size} to be modified, because @code{size} is not a member of 
@code{theStack}'s group. 
Furthermore, it is redundant to mention @code{theStack} when 
@code{size} has already been mentioned (although this can help clarify 
the @code{assignable} clause, i.e., clarify which fields can be changed). 

@cindex represents clause, and reasoning
The @code{represents} clause in @code{BoundedStackInterface}
says how the value of @code{size} is related
to the value of @code{theStack}.
It says that the value of @code{size} is @code{theStack.length()}.

@cindex Hoare
A represents clause gives additional facts that can be used
in reasoning about the specification.
It serves the same purpose as an abstraction function in various
proof methods for abstract data types (such as [Hoare72a]).

One can only use a represents clause to state facts about a field
and its data group members.
To state relationships among concrete data fields
or on fields that are not related by a data group membership,
one should use an invariant.

@node Redundant Specification, Multiple Specification Cases, Data Groups and Represents Clauses, Specification of BoundedStackInterface
@c  node-name,  next,  previous,  up
@subsubsection Redundant Specification

@cindex invariant, redundant
@kindex @code{redundantly}, suffix on keywords
@kindex @code{invariant_redundantly}
@cindex checkable redundancy
@cindex redundancy
@cindex Leavens
@cindex Tan
@cindex implications, of a specification
@cindex rhetorical points
The second @code{invariant} clause
that follows the @code{represents} clause
in the specification of @code{BoundedStackInterface} above
is our first example of checkable redundancy in a specification
[Leavens-Baker99] [Tan94] [Tan95].
This concept is signaled in JML by the use of the suffix @code{_redundantly}
on a keyword (as in @code{ensures_redundantly}).
It says both that the stated property is specified to hold
and that this property is believed to follow from the other
properties of the specification.
In this case the redundant invariant follows from the given invariant,
the invariant inherited from the specification of @code{BoundedThing},
and the fact stated in the @code{represents} clause.
Even though this invariant is redundant,
it is sometimes helpful to state such properties, to bring them
to the attention of the readers of the specification.

@cindex redundancy, checking
@cindex debugging, specifications
Checking that such claimed redundancies really do follow from
other information is also a good way to make sure that what is being specified
is really what is intended.
Such checks could be done manually, during reviews, or with the aid
of a theorem prover.
JML's runtime assertion checker can also check such redundant
specifications, but, of course, can only find examples where they do
not hold.

@node Multiple Specification Cases, Pitfalls in Specifying Exceptions, Redundant Specification, Specification of BoundedStackInterface
@c  node-name,  next,  previous,  up
@subsubsection Multiple Specification Cases

@cindex specification cases, multiple
@kindex @code{also}
@cindex multiple specification cases
After the redundant invariant of @code{BoundedStackInterface}
are the specifications of
the @code{pop}, @code{push}, and @code{top} methods.
These are interesting for several new features that they present.
Each of these has both a normal and exceptional behavior specified.
The meaning of such multiple @dfn{specification cases} is that,
when the precondition of one of them is satisfied,
the rest of that specification case must also be obeyed.

@cindex Dhara
@cindex Leavens
@cindex Wing
@cindex Wills
@cindex Raghavan
@cindex Leavens
@kindex @code{normal_behavior}, desugaring
@kindex @code{exceptional_behavior}, desugaring
@kindex @code{behavior}, use in desugaring
@kindex @code{implies_that}
@cindex implications section, of method specification
A specification with several specification cases
is shorthand for one in which the
separate specifications are combined
[Dhara-Leavens96] [Leavens97c] [Wing83] [Wills94].
The desugaring can be thought of as proceeding in two steps
(see [Raghavan-Leavens05] for more details).
First, the @code{public normal_behavior} and @code{public exceptional_behavior}
cases are converted into @code{public behavior} specifications as explained above.
This would produce a specification for @code{pop} as shown below.
The use of @code{implies_that} introduces a redundant specification
that can be used, as is done here,
to point out consequences of the specification to the reader.
@kindex @code{refine}
In this case the specification in question is the one mentioned in the
@code{refine} clause.
Note that in the second specification case of the figure below, 
the default signals clause has been added.
This clause was omitted from the original specification, since no
particular details of the exception object were important to the specifier.

@pindex @code{BoundedStackInterface.jml}
@example
@include stacks/BoundedStackInterface.jml.texinfo
@end example

@kindex @code{also}
@kindex @code{if}
The second step of the desugaring is shown
below.
As can be seen from this example,
@code{public behavior} specifications that are joined together using @code{also}
have a precondition that is the disjunction of the preconditions
of the combined specification cases.
The @code{assignable} clause for the expanded specification
is the union of all the assignable clauses for the cases.
To compensate for this, the predicate @code{\not_assigned}, is used in
the exceptional behavior specification cases to prohibit assignment to
the locations (those in the data groups of @code{size} and @code{theStack})
that are now part of the assignable clause.
The ensures clauses of the second desugaring step correspond to
the ensures clauses for each specification case;
they say that whenever the precondition for that specification case held
in the pre-state, its postcondition must also hold.
As can be seen in the specification below,
in logic this is written using an implication between
@code{\old} wrapped around the case's precondition and its postcondition.
@cindex multiple clauses
@cindex clauses, multiple
@cindex method specification, multiple clauses in
@cindex ensures clause, meaning of multiple
Having multiple ensures clauses is equivalent to writing
a single ensures clause that has as its postcondition the conjunction
of the given postconditions.
Similarly, the signals clauses in the desugaring correspond to
those in the given specification cases;
as for the ensures clauses, each has a predicate that
says that signaling that exception can only happen
when the predicate in that case's precondition holds.

@pindex @code{BoundedStackInterface.refines-java}
@example
@include stacks/BoundedStackInterface.refinesjava.texinfo
@end example

In the file @file{BoundedStackInterface.refines-java} above,
the precondition of @code{pop} reduces to @code{true}.
However, the precondition shown is the general form of the expansion.
Similar remarks apply to other predicates.

@cindex exceptions, specifying details of
@cindex signals clauses, detailed
Finally, note how, as in the specification of @code{top},
one can specify more details about the exception object thrown.
The exceptional behavior for @code{top} says that the exception object
thrown, @code{e}, must be freshly allocated, non-null, and have the
given message.

@node Pitfalls in Specifying Exceptions, Redundant Ensures Clauses, Multiple Specification Cases, Specification of BoundedStackInterface
@c  node-name,  next,  previous,  up
@subsubsection Pitfalls in Specifying Exceptions

@cindex exceptions, specification of
@cindex specification of exceptions
@kindex @code{exceptional_behavior}
@kindex @code{signals}
@cindex signals clause
@cindex multiple, exceptions
@cindex pitfalls, in specifying exceptions
A particularly interesting example of multiple specification cases occurs
in the specification of the @code{BoundedStackInterface}'s @code{push} method.
Like the other methods, this example has two specification cases;
one of these is a @code{normal_behavior}
and one is an @code{exceptional_behavior}.
However, the exceptional behavior of @code{push} is interesting
because it specifies more than one exception that may be thrown.
The requires clause of the exceptional behavior says that
an exception must be thrown when either the stack cannot grow larger,
or when the argument @code{x} is null.
The first signals clause says that, if a @code{BoundedStackException}
is thrown, then the stack cannot grow larger,
and the second signals clause says that, if a @code{NullPointerException}
is thrown, then @code{x} must be null.
The specification is written in this way because it may be that
@emph{both} conditions occur;
when that is the case, the specification allows the implementation to choose
(even nondeterministically) which exception is thrown.

@cindex Poll, Erik
@cindex simultaneous exceptions
@cindex nondeterminism in exception specifications
Specifiers should be wary of such situations, where two different
signals clauses may both apply simultaneously, because it is impossible in
Java to throw more than one exception from a method call.  Thus, for
example, if the specification of @code{push} had been written as
follows, it would not be implementable.@footnote{
Thanks to Erik Poll for pointing this out.}
The problem is that both exceptional preconditions may be true,
and in that case an implementation cannot throw an exception that is
an instance of both a @code{BoundedStackException} and a
@code{NullPointerException}.

@example
  /*@@   public normal_behavior
    @@     requires theStack.length() < MAX_SIZE && x != null;
    @@     assignable size, theStack;
    @@     ensures theStack.equals(\old(theStack.insertFront(x)));
    @@     ensures_redundantly theStack != null && top() == x
    @@              && theStack.length() == \old(theStack.length()+1);
    @@ also
    @@   public exceptional_behavior
    @@     requires theStack.length() >= MAX_SIZE;
    @@     assignable \nothing;
    @@     signals (Exception e) e instanceof BoundedStackException;
    @@ also                                   // this is wrong!
    @@   public exceptional_behavior
    @@     requires x == null;
    @@     assignable \nothing;
    @@     signals (Exception e) e instanceof NullPointerException;
    @@*/
  public void push(Object x )
         throws BoundedStackException, NullPointerException;
@end example

One could fix the example above by writing one of the requires clauses
in the two exceptional behaviors to exclude the other, although this
would make the specification deterministic about which exception
would be thrown when both exceptional conditions occur.  In general, it
seems best to avoid this pitfall by writing signals clauses
that do not exclude other exceptions from being thrown whenever there
are states in which multiple exceptions may be thrown.
That is, instead of using multiple @code{signals_only} clauses or
using multiple @code{signals} clauses like:
@example
   signals (Exception e) e instanceof BoundedStackException;
@end example
which only allows a @code{BoundedStackException} to be thrown when the
precondition is true, one can write a signals clause like:
@example
   signals (BoundedStackException);
@end example
which says nothing about what happens when other exceptions are thrown
(@pxref{Specifying Exceptional Behavior} for more details).

@node Redundant Ensures Clauses,  , Pitfalls in Specifying Exceptions, Specification of BoundedStackInterface
@c  node-name,  next,  previous,  up
@subsubsection Redundant Ensures Clauses

@cindex redundant, ensures clauses
@kindex @code{ensures_redundantly}
@cindex implication
@cindex Meyer
Finally, there is more redundancy in the specifications of @code{push}
in the original specification of @code{BoundedStackInterface} above,
which has a redundant @code{ensures} clause in its normal behavior.
For an @code{ensures_redundantly} clause,
what one checks is that the conjunction
of the precondition, the meaning of the @code{assignable} clause, and the
(non-redundant) postcondition together imply the redundant postcondition.
It is interesting to note that,
for @code{push}, the specifications for stacks written in
Eiffel (see page 339 of [Meyer97]) expresses just what we specify
in @code{push}'s redundant postcondition.
This conveys strictly less information than the non-redundant
postcondition for @code{push}'s normal behavior,
since it says little about the elements of the stack.@footnote{
Meyer's second specification and implementation of stacks
(see page 349 of [Meyer97]) is no better in this respect,
although, of course, the implementation does keep track of the elements
properly.}

In summary, using types like @code{JMLObjectSequence} for modeling can
help the specifier give more precise specifications.  We describe more
about such types in the next section.

@node Types For Modeling, Use of Pure Classes, Data Groups, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Types For Modeling

@cindex @code{org.jmlspecs.models} package
@cindex model classes
@cindex abstract modeling classes
@cindex model types
@cindex types for mathematical modeling
JML comes with a suite of types with immutable objects and pure
methods, that can be used for defining abstract models.
These are found in the package
@code{org.jmlspecs.models},
which includes both collection and non-collection types
(such as @code{JMLInteger})
and a few auxiliary classes (such as exceptions and enumerators).

@cindex value, vs. object model types
@cindex model types, value vs. object
The collection types in this package can hold either objects or values;
this distinction determines the notion of equality used on their
elements and whether cloning is done on the elements.
The object collections, such as @code{JMLObjectSet}
and @code{JMLObjectBag}, use @code{==} and do not clone.
The value collections, such as @code{JMLValueSet}
and @code{JMLValueBag}, use @code{.equals} to compare elements,
and clone the objects added to and returned from them.
The objects in a value collection are representatives of equivalence
classes (under @code{.equals}) of objects; their values matter, but not
their object identities.  By contrast an object container contains
object identities, and the values in these objects do not matter.

@cindex model types, for collections
@cindex collection model types
Simple collection types include
the set types, @code{JMLObjectSet} and @code{JMLValueSet},
and sequence types @code{JMLObjectSequence} and @code{JMLValueSequence}.
The binary relation and map types can independently have objects in their
domain or range.
The binary relation types are named
@code{JMLObjectToObjectRelation}, @code{JMLObjectToValueRelation},
and so on.
For example, @code{JMLObjectToValueRelation} is a type of binary
relations between objects (not cloned and compared using @code{==})
and values (which are cloned and compared using @code{.equals}).
The four map types are similarly named according to the scheme
@code{JML...To...Map}.

@cindex modeling types, defining your own
@cindex immutable types, defining your own
@kindex @code{pure}
Users can also create their own types with pure methods for
mathematical modeling if desired.
Since pure methods may be used in assertions,
they must be declared with the modifier @code{pure}
and pass certain conservative checks that make sure there is no
possibility of observable side-effects from their use.
We discuss purity and give several examples of such types below.

@menu
* Purity::                      
* Money::                       
* MoneyComparable and MoneyOps::  
* MoneyAC::                     
* MoneyComparableAC::           
* USMoney::                     
@end menu

@node Purity, Money, Types For Modeling, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection Purity


@cindex pure method
@cindex method, pure
We say a method
is @dfn{pure} if it is either specified with
the modifier @code{pure} or is a method that
appears in the specification of a @code{pure} interface or class.
Similarly, a constructor is pure if it is either specified with
the modifier @code{pure} or appears in the specification of a @code{pure}
class.

A @dfn{pure method}, that is not a constructor,
implicitly has a specification that does not allow any side-effects.
That is, its specification
has the clauses
@example
@group
           diverges false;
           assignable \nothing;
@end group
@end example
@noindent
added to each specification case; if the method has no specification
given explicitly, then these clauses are added as a lightweight specification.
For this reason, if one is writing a pure method, it is not necessary
to otherwise specify an assignable clause
(@pxref{The Assignable Clause}), although doing so may improve the
specification's clarity.

@cindex pure constructor
@cindex constructor, pure
A @dfn{pure constructor} has the clauses
@example
@group
           diverges false;
           assignable this.*;
@end group
@end example
@noindent
added to each specification case; if the constructor has no specification
given explicitly, then these clauses are added as a lightweight specification.
This specification allows the constructor to assign to the non-static
fields of the class in which it appears (including those inherited
from its superclasses and model and ghost instance fields from the interfaces
that it implements).

@cindex Salcianu
@cindex Rinard
Implementations of pure methods and constructors
will be checked to see that they meet these conditions; i.e., that
pure methods do not assign to locations that exist in the pre-state, and
that pure constructors only assign to pre-existing locations that
are fields of the @code{this} object.
To make such checking modular, some JML tools prohibit a pure method
or constructor implementation from calling methods or constructors
that are not pure.  However, more sophisticated tools could more
directly check the intended semantics [Salcianu-Rinard05].

@cindex termination, of pure methods
A pure method or constructor must also be provably terminating.
Although JML does not force users to make such proofs of termination,
users writing pure methods and constructors are supposed to make pure
methods total in the sense that whenever, a pure method is called it either
returns normally or throws some exception.
This is supposed to lessen the possibility that assertion evaluation
could loop forever, help make pure methods more like mathematical functions,
and help the runtime assertion checker.
The runtime assertion checker turns
exceptions into arbitrary values of the appropriate result type
[Cheon03] [Cheon-Leavens05];
it cannot do anything with infinite loops.

@cindex pure, implicit verification condition for termination
Furthermore, a pure method is supposed to always either terminate
normally or throw an exception, even for calls that do not satisfy its
precondition.  Static verification
tools for JML should enforce this condition, by requiring a proof
that a pure method implementation satisfies the following
specification
@example
@group
   private behavior
     requires true;
     diverges false;
     assignable \nothing;
@end group
@end example
(and similarly for constructors, except that the assignable clause
becomes @code{assignable this.*;} for constructors).

However, this implicit verification condition is a
specification, and is thus cannot be used in reasoning about
calls to the method, even calls from within the class itself and recursive
calls from within the implementation.
For this reason we recommend writing the method or constructor
specification in such a way that the effective precondition of the
method is ``true,'' making the proof of the above implicit verification
condition trivial, and allowing the
termination behavior of the implementation to be relied upon by all clients.

@cindex recursion, and pure methods
Recursion is permitted, both in the implementation of pure methods
and the data structures they manipulate, and in the specifications of
pure methods.
When recursion is used in a specification,
the proof of well-formedness for the specification
involves the use of JML's @code{measured_by} clause.

Since a pure method may not go into an infinite loop,
if it has a non-trivial precondition, it should throw an exception
when its normal precondition is not met.
This exceptional behavior does not have to be specified or programmed
explicitly, but technically there is an obligation to meet the specification
that the method never loops forever.

@cindex purity, and determinism
@cindex deterministic, pure method
Furthermore, a pure method must be deterministic, in
the sense that when called in a given state, it must always return the
same value.  Similarly a pure constructor should be deterministic in
the sense that when called in a given state, it always initializes the
object in the same way.

A pure method can be declared in any class or interface,
and a pure constructor can be declared in any class.
JML will specify the pure methods and constructors
in the standard Java libraries as pure.

@cindex pure interface
As a convenience, instead of writing @code{pure} on each
method declared in a class and interface,
one can use the modifier @code{pure} on classes and
interfaces.
This simply means that each non-static method and each constructor
declared in such a class or interface is @code{pure}.
Note that this does not mean that all methods inherited (but not
declared in and hence not overridden in) the class or interface are
pure.
For example, every class inherits ultimately from
@code{java.lang.Object},
which has some methods, such as @code{notify} and @code{notifyAll}
that are manifestly not pure.
Thus each class will have some methods that are not pure.
Despite this, it is convenient to refer to classes and interfaces declared
with the @code{pure} modifier as @dfn{pure}.

@cindex model methods, vs. pure methods
@cindex pure methods, vs. model methods
In JML the modifiers @code{model} and @code{pure}
are orthogonal.  (Recall something declared with
the modifier @code{model} does not have to be
implemented, and is used purely for specification purposes.)
Therefore, one can have a model method
that is not pure (these might be useful in JML's model programs);
conversely, a Java method can be pure (and thus not a model method).
Nevertheless, usually a model method (or constructor) should be pure,
since there is no way to use non-pure methods in an assertion,
and model methods cannot be used in normal Java code.

@cindex model classes, vs. pure classes
@cindex pure classes, vs. model classes
By the same reasoning, model classes should, in
general, also be pure.
Model classes cannot be used in normal Java code, and hence their
methods are only useful in assertions (and JML's model programs).
Hence it is typical, although not required, that a model class also be
a pure class.
We give some examples of pure interfaces, abstract classes, and classes below.

@node Money, MoneyComparable and MoneyOps, Purity, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection Money

The following example begins a specification of money
that would be suitable for use in abstract models.
Our specification is rather artificially broken up into pieces
to allow each piece to have a specification that fits on a page.
This organization is not necessarily something we would recommend,
but it does give us a chance to illustrate more features of JML.

Consider first the interface @code{Money}
specified below.
The abstract model here is a single field
of the primitive Java type @code{long},
which holds a number of pennies.
Note that the declaration of this field, @code{pennies},
again uses the JML keyword @code{instance}.

@pindex @code{Money.java}
@example
@include local/Money.java.texinfo
@end example

@cindex history constraint, example of
This interface has a history constraint, which says that the number
of pennies in an object cannot change.@footnote{
There is no use of @code{initially} in this interface,
so data type induction cannot assume any particular starting value.
But this is desirable, since if a particular starting value was
specified, then by the history constraint, all objects would have
that value.}

The following explain more aspects of JML related to the above specification.

@menu
* Redundant Examples::          
* JMLType and Informal Predicates::  
@end menu

@node Redundant Examples, JMLType and Informal Predicates, Money, Money
@c  node-name,  next,  previous,  up
@subsubsection Redundant Examples

@kindex @code{for_example}
@cindex examples, in method specifications
@cindex specification of examples
@cindex redundant examples
@cindex redundancy
The interesting aspect of @code{Money}'s method specifications is another kind of redundancy.
This new form of redundancy is examples,
which follow the keyword ``@code{for_example}''.

@kindex @code{normal_example}
@kindex @code{example}
@kindex @code{exceptional_example}
Individual examples
are given by @code{normal_example} clauses
(adapted from our previous work on Larch/C++ [Leavens96b] [Leavens-Baker99]).
Any number of these@footnote{
One may also give @code{exceptional_example} clauses,
which are analogous to @code{exceptional_behavior} specifications,
and @code{example} clauses, which are analogous to @code{behavior}
specifications. 
There is also a lightweight form of example, this is
similar to the @code{example} form, except that the introductory keywords
``@code{public example}'' are omitted.} 
can be given in a specification.
In the specification of @code{Money} above
there are three normal examples given for @code{dollars}
and two in the specification of @code{cents}.

@cindex examples, checking
The specification in each example should be such that:
@itemize @bullet
@item
the example's precondition implies
the precondition of the expanded meaning of the specified behaviors,

@item
the example's assignable clause
specifies a subset of the locations that are assignable
according to the expanded meaning of the specified behaviors, and

@item
assuming the example's assignable clause,
the conjunction of:
@itemize @bullet
@item
the example's precondition (wrapped by @code{\old()}),

@item
the precondition of the expanded meaning of the specified behaviors
(also wrapped by @code{\old()}),
and

@item
the postcondition of the expanded meaning of the specified behaviors
@end itemize
should be equivalent to the example's postcondition.
@end itemize
Requiring equivalence to the example's postcondition
means that it can serve as a test oracle for the
inputs described by the example's precondition.
If there is only one specified @code{public normal_behavior} clause
and if there are no preconditions and assignable clauses,
then the example's postcondition should the equivalent to
the conjunction of the example's precondition
and the postcondition of the @code{public normal_behavior} specification.
Typically, examples are concrete, and serve to make various rhetorical
points about the use of the specification to the reader.
(Exercise: check all the examples given!)

@node JMLType and Informal Predicates,  , Redundant Examples, Money
@c  node-name,  next,  previous,  up
@subsubsection JMLType and Informal Predicates

@kindex @code{also}
@cindex specification, of overriding method
@cindex overriding, specification of
@cindex @code{clone}
The interface @code{Money} is specified to extend the interface
@code{JMLType}.
This interface is given below.
Classes that implement this interface must
have pure @code{equals} and @code{clone} methods
with the specified behavior.
The methods specified override methods in the class
@code{Object}, and so they use the form of specification
that begins with the keyword ``@code{also}''.

@pindex @code{JMLType.java}
@example
@group
@include models/JMLType.java.texinfo
@end group
@end example

@cindex Leavens
@cindex informal predicates
@cindex informality
@cindex formality, escape from
@kindex @code{(*}
@kindex @code{*)}
The specification of @code{JMLType} 
is noteworthy in its use of informal predicates [Leavens96b].
In JML these start with an open parenthesis and an asterisk (`@code{(*}')
and continue until a matching asterisk and closing parenthesis (`@code{*)}').
In the public specification of @code{equals},
the @code{normal_behavior}'s @code{ensures} clause
uses an informal predicate as an escape from formality.
The use of informal predicates avoids the delicate issues of saying
formally what observable aliasing means,
and what equality of values means in general.@footnote{
@dfn{Observable aliasing}
is a sharing relation between objects that can be detected by a program.
Such a program, might, for example modify one object and read a changed value
from the shared object.
Formalizing this in general is beyond the scope of this paper,
and probably beyond what JML can describe.
}

@kindex @code{implies_that}, example of
@cindex case analysis, nested
@cindex specification case, nested
@kindex @code{also}
@kindex @code{@{|}
@kindex @code{|@}}
@cindex @code{equals}
In the @code{implies_that} section of the specification of the
@code{equals} method is a nested case analysis, between @code{@{|}
and @code{|@}}. The meaning of this is that each pre- and postcondition
pair has to be obeyed.  The first of these nested pairs is essentially
saying that @code{equals} has to be symmetric.  The second of these is
saying that it has to be reflexive.

The @code{implies_that} section of the @code{clone} method states
some implications of the specification given that are useful for 
ESC/Java.  These repeat, from the first part of @code{clone}'s
specification, that the result must not be null, and that
the result's dynamic type, @code{\typeof(\result)},
must be a subtype of (written @code{<:}) the type @code{JMLType}.

@node MoneyComparable and MoneyOps, MoneyAC, Money, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection MoneyComparable and MoneyOps

The type @code{Money} lacks some useful operations.
The extensions below
provide specifications of comparison operations and arithmetic, respectively.

@cindex Leavens
@cindex Wing
@cindex protection, of precondition
@cindex undefinedness, protection from
The specification in file @file{MoneyComparable.java} is interesting because
each of the specified preconditions protects the postcondition from
undefinedness in the postcondition [Leavens-Wing97a].
For example, if the argument @code{m2} in the @code{greaterThan}
method were @code{null}, then the expression @code{m2.pennies} would
not be defined.

@pindex @code{MoneyComparable.java}
@example
@include local/MoneyComparable.java.texinfo
@end example

@kindex @code{pure}, example of
@cindex pure model method, example of
@cindex model method, example of
@kindex @code{old}
The interface specified in the file @file{MoneyOps.java}
below extends the interface specified above.
@code{MoneyOps} is interesting for
the use of its pure model methods: @code{inRange},
@code{can_add}, and @code{can_scaleBy}.
These methods cannot be invoked by Java programs;
that is, they would not appear in the Java implementation.
When, for example @code{inRange} is called in a predicate, it is
equivalent to using some correct implementation of its specification.
The specification of @code{inRange} also makes use of a local specification
variable declaration, which follows the keyword ``@code{old}''.
Such declarations allow one to abbreviate long expressions, or,
to make rhetorical points by naming constants,
as is done with @code{epsilon}.
These @code{old} declarations are treated as locations
that are initialized to the pre-state value of the given expression.
Model methods can be normal (instance) methods
as well as static (class) methods. 

@pindex @code{MoneyOps.java}
@example
@include local/MoneyOps.java.texinfo
@end example

Note also that JML uses the Java semantics for mixed-type expressions.
For example in the ensures clause of the above specification of @code{plus},
@code{m2.pennies} is implicitly coerced to a double-precision floating point number,
as it would be in Java.

@node MoneyAC, MoneyComparableAC, MoneyComparable and MoneyOps, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection MoneyAC

@kindex @code{in}, example of
@kindex @code{represents}, example of
@cindex correctness, of ADT implementation
@cindex ADT, correctness of implementation
@cindex type, correctness of implementation
@cindex implementation, correctness of
@cindex Hoare
@cindex Leino
The key to proofs that an implementation of a class or interface
specification is correct lies in the use of @code{in}, @code{maps-into},
and @code{represents} clauses [Hoare72a] [Leino95].

Consider, for example, the abstract class
specified in the file @file{MoneyAC.java} below.
This class is abstract and has no constructors.
The class declares a concrete field @code{numCents},
which is related to the model instance field @code{pennies}
by the @code{represents} clause.@footnote{
This @code{represents} clause is implicitly an instance, as opposed to
a static, represents clause, because it appears in a class
declaration.
}
The represents clause states that the value of @code{pennies}
is the value of @code{numCents}.
This allows relatively trivial proofs of the correctness of the
@code{dollars} and @code{cents} methods, and is key to the proofs
of the other methods.

@pindex @code{MoneyAC.java}
@example
@include local/MoneyAC.java.texinfo
@end example

@node MoneyComparableAC, USMoney, MoneyAC, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection MoneyComparableAC

The straightforward implementation of the pure abstract subclass
@code{MoneyComparableAC} is given below.
Besides extending the class @code{MoneyAC},
it implements the interface @code{MoneyComparable}.
Note that the model and concrete fields are both inherited
by this class.

@pindex @code{MoneyComparableAC.java}
@example
@include local/MoneyComparableAC.java.texinfo
@end example

@cindex assertion, embedded
@kindex @code{assert}
@cindex assertions, in Java vs. JML
@cindex Java vs. JML assertions
@cindex JML vs. Java assertions
An interesting feature of the class @code{MoneyComparableAC}
is the protected static method named @code{totalCents}.
For this method, we give its code with an embedded assertion,
written following the keyword @code{assert}.@footnote{
As of JDK 1.4, @code{assert} is also a reserved word in Java.
One can thus write assert statements either in standard Java or in
JML annotations.
If one writes an assert statement as a JML annotation,
all of the JML extensions to the Java expression syntax 
@pxref{Extensions to Java Expressions for Predicates}
for the predicate can be used,
but no side-effects are allowed in this predicate.
Such a JML @var{assert-statement} may also refer to model and ghost variables.
In a Java assert statement, i.e., in an @var{assert-statement} that
is not in an annotation, one cannot use JML's extensions for assertions,
because such assertions must compile with a Java compiler.
}

@cindex model method, example of
Note that the model method, @code{inRange} is not implemented,
and does not need to be implemented to make this class correctly implement
the interface @code{MoneyComparable}.

@node USMoney,  , MoneyComparableAC, Types For Modeling
@c  node-name,  next,  previous,  up
@subsection USMoney

Finally, a concrete class implementation
is given in the file @file{USMoney.java} shown below.
The class @code{USMoney} implements the interface @code{MoneyOps}.
Note that specifications as well as code are given for the constructors.

@pindex @code{USMoney.java}
@example
@include local/USMoney.java.texinfo
@end example

@cindex constructors, and the assignable clause
@cindex assignable clause, and constructors
@cindex initialization, in constructors
@kindex @code{new}
@kindex @code{assignable}
The constructors each mention the fields that they initialize
in their @code{assignable} clause.
This is because the constructor's job is to initialize these fields.
One can think of a @code{new} expression in Java as executing
in two steps: allocating an object, and then calling the constructor.
Thus the specification of a constructor needs to mention the fields
that it can initialize in the @code{assignable} clause.

@cindex redundancy, in assignable clause
@cindex assignable clause, redundancy in
@kindex @code{assignable_redundantly}
The first constructor's specification also illustrates that redundancy
can also be used in an @code{assignable} clause.
A redundant @code{assignable} clause follows 
if the meaning of the set of locations named is a subset of the
ones denoted by the non-redundant clause for the same specification case.
In this example
the redundant assignable clause follows from the given assignable
clause and the meaning of the @code{in} clause inherited from the
superclass @code{MoneyAC}.

@cindex informal predicate, example of
@cindex Leavens
The second constructor above is noteworthy in that there is a redundant
ensures clause that uses an informal predicate [Leavens96b].
In this instance, the informal predicate is used as a comment
(which could also be used).
Recall that informal predicates allow
an escape from formality when
one does not wish to give part of a specification in formal detail.

@cindex Back
@cindex Mikhajlova
@cindex von Wright
@cindex Leino
@cindex ESC/Java
@kindex @code{assume}
The @code{plus} and @code{minus} methods use @code{assume} statements;
these are like assertions, but are intended to impose obligations
on the callers [Back-Mikhajlova-vonWright98].
The main distinction between a @code{assume} statement and a @code{requires}
clause is that the former is a statement and can be used within code.
These may also be treated differently by different tools.  
For example, ESC/Java [Leino-etal00]
will require callers to satisfy the requires clause of a method,
but will not enforce the precondition if it is stated as an assumption.

@node Use of Pure Classes, Composition for Container Classes, Types For Modeling, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Use of Pure Classes

@cindex pure classes, use in modeling
@cindex classes, pure, use of
Since @code{USMoney} is a pure class,
it can be used to make models of other classes.
An example is the abstract class specified in the file
@file{Account.jml} below.
The first model field in this class has the type @code{USMoney},
which was specified above.
(Further explanation follows the specification below.)

@pindex @code{Account.jml}
@example
@include local/Account.jml.texinfo
@end example

@cindex protection, from undefinedness
@kindex @code{null}, protection from
@cindex Leavens
@cindex Wing
@cindex invariant, example of
The specification of @code{Account} makes good use of examples.
It also demonstrates the various ways of protecting predicates used
in the specification from undefinedness [Leavens-Wing97a].
The principal concern here, as is often the case when using reference
types in a model, is to protect against the model fields being
@code{null}.
As in Java, fields and variables of reference types can be @code{null}.
In the specification of @code{Account}, the invariant states that these fields
should not be null.
Since implementations of public methods must preserve the invariants,
one can think of the invariant as conjoined to the precondition
and postcondition of each public method, and the postcondition of each
public constructor.
Hence, for example, method pre- and postconditions do not have
to state that the fields are not null.
However, often other parts of the specification must be written
to allow the invariant to be preserved, or established by a constructor.
For example, in the specification of @code{Account}'s constructor,
this is done by requiring @code{amt} and @code{own} are not null,
since, if they could be null, then the invariant and the postcondition
could not be established.

@node Composition for Container Classes, Behavioral Subtyping, Use of Pure Classes, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Composition for Container Classes

@cindex modeling, for ADTs, example of
@cindex ADT, modeling
The following specifications lead to
the specification of a class @code{Digraph} (directed graph).
This gives a more interesting example of how
more complex models can be composed in JML from
other classes.
In this example we use model classes
and the pure containers provided in the package
@code{org.jmlspecs.models}.

@menu
* NodeType::                    
* ArcType::                     
* Digraph::                     
@end menu

@node NodeType, ArcType, Composition for Container Classes, Composition for Container Classes
@c  node-name,  next,  previous,  up
@subsection NodeType

@cindex interface, pure
@cindex pure interface
The file @file{NodeType.java}
contains the specification of an interface @code{NodeType}.
We also declare this interface to be @code{pure},
since we want to use its methods in the specifications of other
classes.
(This is appropriate, since all the methods of @code{NodeType} are
side-effect free.)

@pindex @code{NodeType.java}
@example
@include digraph/NodeType.java.texinfo
@end example

@node ArcType, Digraph, NodeType, Composition for Container Classes
@c  node-name,  next,  previous,  up
@subsection ArcType

@cindex class for modeling, example of
@cindex pure class, example of
@cindex class, model
@cindex model class
@code{ArcType} is specified as a
pure class in the file @file{ArcType.jml} shown below.
In theory, this class could have been declared with the @code{model} modifier,
since it does not appear in the interface
to @code{Digraph}.  However, we specify it as a normal Java class for
simplicity, and because model classes do not currently work in JML's
runtime assertion checker.
We declare @code{ArcType} to be a pure class
so that its methods can be used in assertions.
The two model fields for @code{ArcType},
@code{from} and @code{to}, are both
of type @code{NodeType}.
We specify the @code{equals} method so that two references
to objects of type @code{ArcType} are equal if and only if they have equal
values in the @code{from} and @code{to} model fields.
Thus, @code{equals} is specified using @code{NodeType.equals}.
We also specify that @code{ArcType}
has a public @code{clone} method,
fulfilling the obligations of a type that implements
@code{JMLType}.
@code{ArcType} must implement @code{JMLType} so that
its objects can be placed in a @code{JMLValueSet}.
We use such a set for one of the model fields of @code{Digraph}.

@pindex @code{ArcType.jml}
@example
@include digraph/ArcType.jml.texinfo
@end example

@kindex @code{also}
@cindex specification cases
The use of @code{also} in the specification of
@code{ArcType}'s @code{equals} method is interesting.
It separates two cases of the normal behavior for that method.
This is equivalent to using two @code{public normal_behavior} clauses,
one for each case.
That is, when the argument is an instance of @code{ArcType},
the method must return true just when 
@code{this} and @code{o} have the same @code{from} and @code{to} fields.
And when @code{o} is not an instance of @code{ArcType},
the @code{equals} method must return false.

@node Digraph,  , ArcType, Composition for Container Classes
@c  node-name,  next,  previous,  up
@subsection Digraph

@cindex container classes, in JML models directory
@cindex JMLValueSet
Finally, the specification of the class @code{Digraph}
is given in the file @file{Digraph.jml} shown below.
This specification
demonstrates how to use container classes,
like @code{JMLValueSet}, combined with
appropriate invariants, to specify models that are compositions of
other classes.
In this specification, the container class @code{JMLValueSet} is used
as the type of the model fields @code{nodes} and @code{arcs}.
Since JML currently only works with a non-generic version of Java,
the first invariant clause restricts
@code{nodes} so that every object in @code{nodes} is, in fact, of type
@code{NodeType}.
Similarly, the next invariant clause we restrict @code{arcs} to be
a set of @code{ArcType} objects. In both cases, since the type is
@code{JMLValueSet}, membership is determined by
the @code{equals} method for the
type of the elements (rather than reference equality).

@pindex @code{Digraph.jml}
@example
@include digraph/Digraph.jml.texinfo
@end example

@cindex case analysis, nested, example of
@kindex @code{@{|}
@kindex @code{|@}}
@kindex @code{measured_by}
@cindex termination function, for methods
@cindex recursion, in model methods
An interesting use of pure model methods appears at the end of
the specification of @code{Digraph} in the pure model method @code{reachSet}.
This method constructively defines the set of all nodes
that are reachable from the nodes in the argument @code{nodeSet}.
This specification uses a nested case analysis, between @code{@{|}
and @code{|@}}.  The meaning of this is again that each pre- and postcondition
pair has to be obeyed, but by using nesting, one can avoid duplication of the
requires clause that is found at the beginning of the specification.
The @code{measured_by} clause is needed because this specification is
recursive; the measure given allows one to describe a termination argument,
and thus ensure that the specification is well-defined. 
This clause defines an integer-valued measure that must always
be at least zero; furthermore, the measure for a call and recursive
uses in the specification must strictly decrease [Owre-etal95].
The recursion in the specification builds up the entire set
of reachable nodes by, for each recursive reference, adding the nodes
that can be reached directly (via a single arc) from the nodes in
@code{nodeSet}. 

@node Behavioral Subtyping,  , Composition for Container Classes, Class and Interface Specifications
@c  node-name,  next,  previous,  up
@section Behavioral Subtyping

@cindex Dhara
@cindex Leavens
@cindex supertype
@cindex subtype
@cindex subtyping, behavioral
@cindex inheritance, of specifications
@cindex behavioral subtyping
@kindex @code{also}
As in Java, a subtype inherits members (fields and methods) from its
supertypes.  A subtype also inherits all the class
level-specifications associated with fields and all method
specifications for public and protected instance methods.
This specification inheritance
has the effect of making the subtype a behavioral subtype [Liskov-Wing94],
in the sense that instances of the subtype obey the specifications its
supertype(s) [Dhara-Leavens96] [Leavens-Weihl95].

@cindex invariant, and inheritance
@cindex history constraint, and inheritance
@cindex initially, and inheritance
@cindex data groups, and inheritance
Class-level specifications associated with fields include include
invariants and history constraints (@pxref{Invariants and History Constraint}),
as well as @code{initially} clauses (@pxref{Model Fields})
data group declarations (@pxref{Data Groups}),
and represents clauses (@pxref{Data Groups and Represents Clauses}).
Inheritance of invariants means that
each supertype's invariants must also hold in the subtype.
Similarly, every history constraint specified in each supertype must
be obeyed in the subtype. And all initially clauses specified
for supertype fields must also be obeyed in all subtypes.
Fields declared in a supertype retain their data group
membership when inherited.  Their represents clauses are also
inherited.
@c [[[Should cite the Mueller-Leino ETAPS submission.]]]

@cindex Ruby
@cindex Leavens
@cindex field, private
@cindex visibility, and inheritance
@cindex invariant, private
As in Java, private fields are inherited by a subtype but not visible
to it.  Similarly, default privacy (i.e., package
visibility) fields are not accessible if the subtype is declared in a
different package than the supertype declaring the field.
As in Java, these fields are present in the
objects of the subtype, but not accessible to code written in the
subtype.
In the same way, class level specifications associated with such
fields must still be obeyed by objects of the subtype.
Various restrictions to JML that ensure that this is always possible
are being investigated [Ruby-Leavens00].

Specifications for instance methods
are also inherited in the sense that public and
protected specification cases must
be obeyed by all overriding methods [Dhara-Leavens96] [Leavens97c].
This inheritance of method specifications
ensures that a client's reasoning about a method call will still
be valid, even if the method is overridden
[America87] [America91] [Leavens-Weihl95],
and thus that a subclass is a behavioral subtype of its
supertypes [Dhara-Leavens96].
Note that private and default (package) visibility specification cases
are not visible to subtypes, and hence do not have to be obeyed by
them; not inheriting such specification cases does not cause clients
reasoning problems, as these specification cases are not
visible to clients making method calls (in general).@footnote{
When such private and default visibility specification cases are
visible to callers, they may only be 
used in verification of a method call if the call can be shown to be
executing that method, as opposed to some override.
}
Furthermore, specifications are @emph{not} inherited for constructors or for
static methods, since they are not involved in dynamic dispatch.

@cindex textual copying, and inheritance
Inheritance of method specifications can be thought of textually.
For each instance method, @i{m} specified in a class @i{C},
one can imagine copying into the specification of @i{m} the public and protected 
specification cases for @i{m} given in all of @i{C}'s ancestors
and in all the interfaces @i{C} implements;
these specification cases would be combined using
@code{also} [Dhara-Leavens96] [Raghavan-Leavens05].@footnote{
However, textual copying shouldn't be taken literally;
if a subclass declares a field that hides the fields of its superclass,
renaming must be done to prevent name capture.}
(This is the reason for the use of @code{also} at the beginning
of specifications in overriding methods.)
By the semantics of method combination using @code{also},
these behaviors must all be satisfied by the method,
in addition to any explicitly specified behaviors.

@cindex specification, of subtypes
@cindex subtype, specification
@cindex model, for a subtype
@cindex subtype, adding to supertype's model
@cindex adding, to supertype's model
For example, consider the class @code{PlusAccount},
specified in file @file{PlusAccount.jml} shown below.
It is specified as a subclass of @code{Account}
(@pxref{Use of Pure Classes}).
Thus it inherits the fields of @code{Account},
and @code{Account}'s public invariants, history constraints,
and method specifications.
(The specification of @code{Account} given above
does not have any @code{protected} specification information.)
Since it inherits the fields of its superclass,
a textual copy of the method specification cases of @code{Account}
would still be meaningful in the context of @code{PlusAccount}.
Thinking of such textual copies works if one adds new (model) fields to
specify the subclass and relates them to the existing ones.
If instead one tried to respecify the fields of a supertype
with invariants and history constraints
that violated the (inherited) specification of that supertype, then
the resulting specification would be contradictory, and hence not be
correctly implementable. 

@pindex @code{PlusAccount.jml}
@example
@include local/PlusAccount.jml.texinfo
@end example

Similarly, if one tried to respecify a method in a way that violated
an (inherited) specification case, then the method would have to obey
both specifications, and would not be correctly implementable. Thus,
specification inheritance guarantees that all subtypes are behavioral
subtypes in JML, and trying to avoid behavioral subtyping results in
unimplementable specifications @cite{Dhara-Leavens96}.

@cindex represents clause
@cindex abstraction relations
@kindex @code{<-}
@kindex @code{\such_that}
Note that in the represents clause below,
instead of a left-facing arrow, @code{<-},
the connective ``@code{\such_that}''
is used to introduce a relationship predicate.
This form of the represents clause allows one to specify abstraction relations,
instead of abstraction functions.

@c ------ chapter Extensions to Java Expressions --------
@node Extensions to Java Expressions, Conclusions, Class and Interface Specifications, Top
@c  node-name,  next,  previous,  up
@chapter Extensions to Java Expressions

@cindex Java, additions to expressions
@cindex expressions, additions to Java
JML makes extensions to the Java expression syntax for two purposes.
The main set of extensions are used in predicates.
But there are also some extensions used in
@var{store-ref}s, which are themselves used in the @code{assignable}
and @code{represents} clauses.

We give an overview of these extensions in this section.  However, we
only describe the most important and useful extensions here.
See the @cite{JML Reference Manual} [Leavens-etal-JMLRef]
for more extensions and for more detail.


@menu
* Extensions to Java Expressions for Predicates::  
* Extensions to Java Expressions for Store-Refs::  
@end menu

@node Extensions to Java Expressions for Predicates, Extensions to Java Expressions for Store-Refs, Extensions to Java Expressions, Extensions to Java Expressions
@c  node-name,  next,  previous,  up
@section Extensions to Java Expressions for Predicates

@cindex predicates, additions to Java expressions for
@cindex assertions, additions to Java expressions for
@cindex predicates, Java expressions prohibited in
@cindex assertions, Java expressions prohibited in
@cindex Java, expressions prohibited in assertions
The expressions that can be used as predicates in JML are an extension
to the side-effect free Java expressions.
Since predicates are required to be side-effect free,
the following Java operators are @emph{not} allowed within predicates:
@itemize @bullet
@item
@cindex assignment
@kindex @code{=}, prohibited in assertions
@kindex @code{+=}, prohibited in assertions
@kindex @code{-=}, prohibited in assertions
assignment (@code{=}),
and the various assignment operators (such as @code{+=}, @code{-=}, etc.)

@item
@kindex @code{++}, prohibited in assertions
@kindex @code{--}, prohibited in assertions
all forms of increment and decrement operators
(@code{++} and @code{--}),

@item
calls to methods that are not pure, and

@item
@kindex @code{new}, and assertions
any use of operator @code{new} that would call a constructor that is not pure.
@end itemize

@kindex @code{super}, prohibited in assertions
Furthermore, within method specifications that are not model programs,
one cannot use @code{super} to call a pure superclass method,
because it is confusing in combination with JML's specification inheritance.@footnote{
Suppose @i{A} is the superclass of @i{B}, and @i{B} is the superclass of @i{C}.
Suppose @i{B}'s specification used @code{super} to call a method of @i{A}.
The problem is that when this specification is inherited by @i{C},
if we imagine copying @i{B}'s specification to @i{C},
then this use of @i{super} no longer refers to @i{A}, but to @i{B}.
Thanks to Arnd Poetzsch-Heffter for pointing out this problem.
}

We allow the allocation of storage (e.g., using operator @code{new}
and pure constructors)
in predicates, because such storage
can never be referred to after the evaluation of the predicate,
and because such pure constructors have no side-effects other than initializing
the new objects so created.

JML adds the following new syntax to the Java expression syntax,
for use in predicates
(see the @cite{JML Reference Manual} [Leavens-etal-JMLRef]
for syntactic details such as precedence):
@itemize @bullet
@item
@cindex informal descriptions
@kindex @code{(*}
@kindex @code{*)}
Informal descriptions, which look like

@example
        (* some text describing a Boolean-valued predicate *)
@end example

@noindent
have type @code{boolean}.
Their meaning is either @code{true} or @code{false},
but is entirely determined by the reader.
Since informal descriptions are not-executable, they may be treated
differently by different tools in different situations.

@item
@kindex @code{==>}
@kindex @code{<==}
@cindex implication, see @code{==>}
@cindex reverse implication, see @code{<==}
@cindex logical implication, see @code{==>}
@code{==>} and @code{<==} for logical implication and reverse implication.
For example, the formula @code{raining ==> getsWet} is true if either
@code{raining} is false or @code{getsWet} is true.
The formula @code{getsWet <== raining} means the same thing.
The @code{==>} operator associates to the right, but
the @code{<==} operator associates to the left.
The expressions on both sides of these operators must be of type
@code{boolean}, and the type of the result is also @code{boolean}.

@item
@kindex @code{<==>}
@kindex @code{<=!=>}
@cindex iff, see @code{<==>}
@cindex if and only if, see @code{<==>}
@cindex equivalence, see @code{<==>}
@cindex logical equivalence, see @code{<==>}
@cindex inequivalence, see @code{<=!=>}
@kindex @code{!=}, for booleans
@kindex @code{==}, for booleans
@code{<==>} and @code{<=!=>} for logical equivalence
and logical inequivalence, respectively.
The expressions on either side of these operators must be of type
@code{boolean}, and the type of the result is also @code{boolean}.
Note that @code{<==>} means the same thing as @code{==}
for expressions of type @code{boolean},
and @code{<=!=>} means the same thing as @code{!=} for boolean expressions;
however, @code{<==>} and @code{<=!=>} have a much lower precedence,
and are also associative and symmetric.

@item
@kindex @code{\forall}
@kindex @code{\exists}
@cindex universal quantifier, see @code{\forall}
@cindex existential quantifier, see @code{\exists}
@cindex quantifiers
@code{\forall} and @code{\exists},
which are universal and existential quantifiers (respectively);
for example,

@example
  (\forall int i,j; 0 <= i && i < j && j < 10; a[i] < a[j])
@end example

@noindent
says that @code{a} is sorted at indexes between 0 and 9.
@cindex range predicate, in quantifier
@cindex quantifier, range predicate in
@kindex @code{;}, in quantifiers
The quantifiers range over all potential values of the variables declared
which satisfy the @dfn{range} predicate, given between the semicolons
(@code{;}).  If the range predicate is omitted, it defaults to @code{true}.
Since a quantifier quantifies over all potential values of the
variables,
when the variables declared are reference types,
they may be null, or may refer to objects not constructed by the program;
one should use a range predicate to eliminate such cases
if they are not desired.
The type of a universal and existential quantifier is @code{boolean}.

@item
@kindex @code{\max}
@kindex @code{\min}
@kindex @code{\product}
@kindex @code{\sum}
@cindex product, see @code{\product}
@cindex summation, see @code{\sum}
@cindex quantified addition, see @code{\sum}
@cindex quantified multiplication, see @code{\product}
@cindex addition, quantified see @code{\sum}
@cindex multiplication, quantified, see @code{\product}
@cindex maximum, see @code{\max}
@cindex minimum, see @code{\min}
@cindex quantified maximum, see @code{\max}
@cindex quantified minimum, see @code{\min}
@cindex quantifier, generalized
@cindex generalized quantifier
@cindex body of a quantifier
@cindex quantifier, body
@cindex Cohen
@code{\max}, @code{\min}, @code{\product}, and @code{\sum},
which are generalized quantifiers that return the maximum, minimum,
product, or sum of the values of the expressions given,
where the variables satisfy the given range.
The range predicate must be of type @code{boolean}.
The expression in the body must be a built-in numeric type,
such as @code{int} or @code{double}; the type of the quantified expression
as a whole is the type of its body.
The @dfn{body} of a quantified expression is the last top-level expression
it contains; it is the expression following the range predicate,
if there is one.
As with the universal and existential quantifiers, 
if the range predicate is omitted, it defaults to @code{true}.
For example, the following equations are all true (see chapter 3 of [Cohen90]):
@example
  (\sum int i; 0 <= i && i < 5; i) == 0 + 1 + 2 + 3 + 4
  (\product int i; 0 < i && i < 5; i) == 1 * 2 * 3 * 4
  (\max int i; 0 <= i && i < 5; i) == 4
  (\min int i; 0 <= i && i < 5; i-1) == -1
@end example

For computing the value of a sum or product, Java's arithmetic is used.
The meaning thus depends on the type of the expression.  For example,
in Java, floating point numbers use the IEEE 754 standard,
and thus when an overflow occurs, the appropriate positive or negative
infinity is returned.  However, Java integers wrap on overflow.
Consider the following examples.
@example
  (\product float f; 1.0e30f < f && f < 1.0e38f; f)
    == Float.POSITIVE_INFINITY

  (\sum int i; i == Integer.MAX_VALUE || i == 1; i)
    == Integer.MAX_VALUE + 1
    == Integer.MIN_VALUE
@end example


@cindex empty range
@cindex range predicate, not satisfiable
When the range predicate is not satisfiable,
the sum is 0 and the product is 1; for example:
@example
  (\sum int i; false; i) == 0
  (\product double d; false; d*d) == 1.0
@end example

When the range predicate is not satisfiable for @code{\max}
the result is the smallest number with the type of the expression in the body;
for floating point numbers, negative infinity is used.
Similarly, when the range predicate is not satisfiable for @code{\min},
the result is the largest number with the type of the expression in the body.

@item
@cindex @code{\num_of}
@cindex numerical quantifier, see @code{\num_of}
@cindex Cohen
@code{\num_of}, which is ``numerical quantifier.'' It returns the number
of values for its variables for which the range and the expression in its
body are true.  Both the range predicate and the body must have type @code{boolean}, and the entire quantified expression has type @code{long}.
The meaning of this quantifier is defined by the following equation
(see p. 57 of [Cohen90]).

@example
  (\num_of T x; R(x); P(x)) == (\sum T x; R(x) && P(x); 1L)
@end example

@item
@cindex set comprehension
@kindex @code{@{|@}}
@cindex comprehensions, for sets
@cindex JMLObjectSet
@cindex JMLValueSet
@kindex @code{new @{|@}}
Set comprehensions, which can be used to succinctly define sets;
for example, the following is the @code{JMLObjectSet}
that is the subset of non-null @code{Integer} objects
found in the set @code{myIntSet}
whose values are between 0 and 10, inclusive.

@example
  new JMLObjectSet @{Integer i | myIntSet.has(i)
                                && i != null && 0 <= i.getInteger()
                                && i.getInteger() <= 10 @}
@end example

@noindent
The syntax of JML 
(see the @cite{JML Reference Manual} [Leavens-etal-JMLRef] for details)
limits set comprehensions so that following
the vertical bar (`@code{|}') is always an invocation of the @code{has}
method of some set on the variable declared.
@cindex Russell's paradox
@cindex Russell
@cindex Whitehead
(This restriction is used to avoid Russell's paradox
[Whitehead-Russell25].)
In practice, one either starts from some relevant set at hand,
or one can start from the sets containing the objects of primitive types
found in @code{org.jmlspecs.models.JMLModelObjectSet}
and (in the same Java package) @code{JMLModelValueSet}.
The type of such an expression is the type named following
@code{new}, which must be @code{JMLObjectSet} or @code{JMLValueSet}.

@item
@kindex @code{\elemtype}
@cindex element type, see @code{\elemtype}
@code{\elemtype}, which returns the most-specific static type
shared by all elements of its array argument [Leino-Nelson-Saxe00].
For example, @code{\elemtype(\type(int[]))} is @code{\type(int)}.
The argument to @code{\elemtype} must be an expression of type
@code{\TYPE}, which JML considers to be the same as @code{java.lang.Class},
and its result also has type @code{\TYPE}.  If the argument is not an
array type, the result is @code{null}.

@item
@kindex @code{\fresh}
@cindex fresh predicate
@code{\fresh}, which asserts that objects were freshly allocated;
for example, @code{\fresh(x,y)} asserts that
@code{x} and @code{y} are not null
and that the objects bound to these identifiers
were not allocated in the pre-state.
The arguments to @code{\fresh} can have any reference type,
and the type of the overall expression is @code{boolean}.@footnote{
Note that it is wrong to use @code{\fresh(this)} in the specification
of a constructor, because Java's @code{new} operator allocates storage
for the object; the constructor's job is just to initialize that
storage.
}

@item
@kindex @code{\nonnullelements}
@cindex non-null elements, of an array
@cindex array, specifying elements are non-null
@code{\nonnullelements},
which can be used to assert that an array and its elements are all non-null.
For example, @code{\nonnullelements(myArray)}, is equivalent to
[Leino-Nelson-Saxe00]

@example
  myArray != null &&
  (\forall int i; 0 <= i && i < myArray.length;
                  myArray[i] != null)
@end example

@item
@kindex @code{\old}
@cindex old values
@code{\old}, which can be used to refer to values in the pre-state;
e.g., @code{\old(myPoint.x)} is the value of the @code{x}
field of the object @code{myPoint} in the pre-state.
The type of such an expression is the type of the expression it
contains;
for example the type of @code{\old(myPoint.x)}
is the type of @code{myPoint.x}.
The keyword @code{\old}
can only be used in an @var{ensures-clause}, a @var{signals-clause},
or a @var{history-constraint};
it cannot be used, for example, in preconditions.
@c [[[Need to talk about quantifiers and purity]]]

@item
@kindex @code{\result}
@cindex result, of a method
@cindex method, result of
@code{\result}, which, in an @code{ensures} clause
is the value or object that is being returned by a method.
Its type is the return type of the method; hence it is a type error to
use @code{\result} in a void method or in a constructor.
The keyword @code{\result} can only be used in an @var{ensures-clause};
it cannot be used, for example, in preconditions or in signals clauses.

@item
@kindex @code{\typeof}
@cindex typeof operator
@cindex dynamic type of an expression
@code{\typeof}, which returns the most-specific dynamic type of an
expression's value [Leino-Nelson-Saxe00].
The meaning of @code{\typeof(}@i{E}@code{)} is unspecified if @i{E} is null.
If @i{E} has a static type that is a reference type,
then @code{\typeof(}@i{E}@code{)} means the same thing as
@i{E}@code{.getClass()}.
For example, if @code{c} is a variable of static type
@code{Collection} that holds an object of class @code{HashSet},
then @code{\typeof(c)} is @code{HashSet.class}, which is the same
thing as @code{\type(HashSet)}.
If @i{E} has a static type that is not a reference type,
then @code{\typeof(}@i{E}@code{)} means the instance of @code{java.lang.Class}
that represents its static type.
For example, @code{\typeof(true)} is @code{Boolean.TYPE}, which is the
same as @code{\type(boolean)}.
Thus an expression of the form @code{\typeof(}@i{E}@code{)} has
type @code{\TYPE}, which JML considers to be the same as
@code{java.lang.Class}.

@item
@kindex @code{<:}
@cindex subtype relation
@cindex types, comparing
@cindex @code{isAssignableFrom}, method of @code{java.lang.Class}
@code{<:}, which compares two reference types and returns true
when the type on the left is a subtype of the type on the right
[Leino-Nelson-Saxe00].
Although the notation might suggest otherwise,
this operator is also reflexive;
a type will compare as @code{<:} with itself.
In an expression of the form @i{E1} @code{<:} @i{E2},
both @i{E1} and @i{E2} must have type @code{\TYPE};
since in JML @code{\TYPE} is the same as @code{java.lang.Class}
the expression @i{E1} @code{<:} @i{E2} means the same thing as the expression
@i{E2}@code{.isAssignableFrom(}@i{E1}@code{)}.

@item
@kindex @code{\type}
@cindex types, marking in expressions
@cindex reflection in assertions
@cindex @code{java.lang.Class}, vs. @code{\type()}
@code{\type}, which can be used to mark types in expressions.
An expression of the form @code{\type(T)} has the type @code{\TYPE}.
Since in JML @code{\TYPE} is the same as @code{java.lang.Class},
an expression of the form @code{\type(}@i{T}@code{)}
means the same thing as @i{T}@code{.class}.
For example, in

@example
   \typeof(myObj) <: \type(PlusAccount)
@end example

@noindent
the use of @code{\type(PlusAccount)} is used to introduce 
the type @code{PlusAccount} into this expression context.
@end itemize

@cindex constructor, and preconditions
@cindex preconditions, and constructors
@cindex requires clauses, and constructors
@cindex blank final, and constructor specifications
To avoid referring to the value of uninitialized locations,
a constructor's precondition can only refer
to locations in the object being constructed that are not assignable.
This allows a constructor to refer to instance fields
of the object being constructed if they are not made assignable by the
constructor's assignable clause, for example,
if they are declared with initializers.
In particular, the precondition of a constructor may not mention a
``blank final'' instance variable that it must assign.

@cindex purity
@cindex side effects, freedom from in assertions
@cindex Gifford
@cindex Lucassen
@cindex Nielson
@cindex Amtoft
@cindex Talpin
@cindex Jouvelot
@cindex Wright
Since we are using Java expressions for predicates, there
are some additional problems in mathematical modeling.
We are excluding the possibility of side-effects by limiting the syntax
of predicates, and by using type checking
[Gifford-Lucassen86] [Lucassen87] [Lucassen-Gifford88]
[Nielson-Nielson-Amtoft97] [Talpin-Jouvelot94] [Wright92]
to make sure that only pure
methods and constructors may be called in predicates.

@cindex exceptions, in expressions
@cindex undefinedness, in expressions
@cindex partiality
@cindex assertions, semantics of
@cindex logic, undefinedness in
@cindex Gries
@cindex Schneider
Exceptions in expressions are particularly important,
since they may arise in type casts.
JML deals with exceptions
by having the evaluation
of predicates substitute an arbitrary expressible value of the 
normal result type when an exception is thrown during evaluation.
When the expression's result type is a reference type,
an implementation would have to return @code{null}
if an exception is thrown while executing such a predicate.
This corresponds to a mathematical model in which partial functions
are mathematically modeled by underspecified total functions
[Gries-Schneider95].
However, tools sometimes only approximate this semantics.
In tools, instead of fully catching exceptions for all subexpressions,
many tools only catch exceptions for the smallest boolean-valued subexpression
that may throw an exception (and for entire expressions used
in JML's @var{measured-clause} and @var{variant-function}).

JML will check that errors (i.e., exceptions that inherit from Error)
are not explicitly thrown by pure methods.
This means that they can be ignored during mathematical modeling.
When executing predicates, errors will cause run-time errors.

@node Extensions to Java Expressions for Store-Refs,  , Extensions to Java Expressions for Predicates, Extensions to Java Expressions
@c  node-name,  next,  previous,  up
@section Extensions to Java Expressions for Store-Refs

@cindex store-references, additions to Java for
@cindex assignable clause
@cindex represents clause
@cindex assignable clause
The grammatical production @var{store-ref}
(see the @cite{JML Reference Manual} [Leavens-etal-JMLRef] for the exact syntax)
is used to name locations
in the @code{assignable} and @code{represents} clauses. 
A @var{store-ref} names a location, not an object;
a location is either a field of an object, or an array element.
Besides the Java syntax of names and field and array references,
JML supports the following syntax for @var{store-ref}s.
See the @cite{JML Reference Manual} [Leavens-etal-JMLRef] for more
details on the syntax. 

@itemize @bullet
@item
@cindex array ranges
@kindex @code{..}
Array ranges, of the form @i{A}@code{[}@i{E1}@code{ .. }@i{E2}@code{]},
denote the locations in the array @i{A} between the value of @i{E1}
and the value of @i{E2} (inclusive).
For example, the clause

@example
    assignable myArray[3 .. 5]
@end example

@noindent
can be thought of an abbreviation for the following.

@example
    assignable myArray[3], myArray[4], myArray[5]
@end example

@item
@cindex array range
@kindex @code{*}, in array range
One can also name all the indexes in an array @i{A} by writing,
@i{A}@code{[*]}, which is shorthand for
@i{A}@code{[0 .. }@i{A}@code{.length-1]}.

@item
@cindex fields of an object
Two notations allow one to refer to the fields in some particular object.
@itemize -
@item
The syntax @i{x}@code{.*}
names all of the non-static fields of the object referred to by @i{x}.
For example, if @code{p} is a @code{Point} object with two fields,
@code{x} and @code{y} of type @code{BigInteger},
then @code{p.*} names the fields @code{p.x} and @code{p.y}.
Notice that the fields of the @code{BigInteger} objects are not named.
Also, @code{p.*.*} is not allowed. 

@item
If @code{a} is an array of type @code{Rocket []},
then the @var{store-ref} @code{a[*].*} means all of the 
non-static fields of each @code{Rocket} 
object referred to by the elements of array @code{a}.
@end itemize
@end itemize

@c ------ chapter Conclusions --------
@node Conclusions, Specification Case Defaults, Extensions to Java Expressions, Top
@c  node-name,  next,  previous,  up
@chapter Conclusions

@cindex future work
@cindex concurrency
@cindex Rodriguez
One area of future work for JML is concurrency.
Some recent work by Rodriguez @emph{et al.} [Rodriguez-etal05]
has investigated the use of atomicity for specifying multi-threaded
Java programs.
However, these ideas are not yet implemented in most of the JML tools,
and their use has not been fully explored.

@cindex URL, for JML
@cindex JML, web page
@cindex web page, for JML
JML has also been used as
a research vehicle in a wide variety of other studies various papers
on these ideas can be found through the JML web page 
@file{http://www.jmlspecs.org/}.

@cindex conclusions
JML is an expressive behavioral interface specification language for Java.
It combines the best features of the Eiffel and Larch approaches to
specification.  It allows one to write specifications that are quite precise
and detailed, but also allows one to write lightweight specifications.
It has examples and other forms of redundancy to allow for debugging
specifications and for making rhetorical points.
It supports behavioral subtyping by specification inheritance.

@cindex URL, for JML
@cindex JML, downloading
@cindex JML, web page
@cindex web page, for JML
@cindex downloading, JML
More information on JML, including software to aid in working with JML
specifications,
can be obtained from @file{http://www.jmlspecs.org/}.
The JML web site also includes an up-to-date version of this document
with a table of contents and an index.

@heading Acknowledgments

@cindex acknowledgments
@cindex NSF
@cindex Rockwell International Corporation
The work of Leavens and Ruby was supported in part by
a grant from Rockwell International Corporation
and by NSF grant CCR-9503168.
Work on JML by Leavens, Baker, and Ruby was also supported in part by
NSF grant CCR-9803843.
Work on JML by Leavens, Ruby, and others is supported in part by 
NSF grants CCR-0097907,CCR-0113181, CCF-0428078, and CCF-0429567.

Many people have helped with the semantics and design of JML,
and on this document.
@cindex Jacobs
@cindex Leino
@cindex M@"uller
@cindex Poll
@cindex van den Berg
@cindex Stata
@cindex Bhorkar
@cindex Boyland
@cindex B@"uchi
@cindex Cok
@cindex Cheon
@cindex Clifton
@cindex Poetzsch-Heffter
Thanks to Yoonsik Cheon, David Cok, Bart Jacobs, Rustan Leino, Peter
M@"uller, Erik Poll, Arnd Poetzsch-Heffter,
and Joachim van den Berg,
for many discussions about the semantics of JML specifications.
Thanks to Raymie Stata for
spear-heading an effort at Compaq SRC to unify JML and ESC/Java, and to
Rustan and Raymie for many interesting ideas and discussions that have
profoundly influenced JML.
@cindex Chalin
@cindex Chan
For comments on earlier drafts and
discussions about JML thanks to Yoonsik, Bart, Rustan, Peter, Eric, Joachim,
Raymie, Abhay Bhorkar, Patrice Chalin, Curtis Clifton, John Boyland,
Martin B@"uchi, Peter Chan, David Cok, 
@cindex Daugherty
@cindex Docxx
@cindex Dooren
@cindex Edwards
@cindex Ernst
@cindex Fleck
@cindex Hoech
@cindex Huisman
@cindex Ganapathy
@cindex Lea
@cindex Marche
@cindex Mertens
@cindex Namara
@cindex Oltes
@cindex Poetzsch-Heffter
@cindex Potts
@cindex Raghavan
@cindex Salcianu
@cindex Saxe
@cindex Scherbring
Gary Daugherty, Jan Docxx, Marko van Dooren, Stephen Edwards, Michael Ernst,
Arthur Fleck, Karl Hoech,
Marieke Huisman, 
Anand Ganapathy, Doug Lea, Claude Marche, Kristof Mertens,
Yogy Namara, Sevtap Oltes,
Arnd Poetzsch-Heffter,
Jim Potts, Arun Raghavan,
Alexandru D. Salcianu,
Jim Saxe, Tammy Scherbring,
@cindex Wahls
@cindex Weck
@cindex Iowa, University of
Tim Wahls, Wolfgang Weck, and others we may have forgotten.
@cindex Cok
@cindex Cheon
@cindex Chalin
@cindex Rioux
@cindex Clifton
@cindex Bhorkar
@cindex Boysen
@cindex Chen
@cindex Dietel
@cindex van Dooren
@cindex Ganapathy
@cindex Namara
@cindex Millstein
@cindex Raghavan
@cindex Tan
Thanks to David Cok, Yoonsik Cheon, Curtis Clifton, Patrice Chalin,
Abhay Bhorkar, Kristina Boysen, Tongjie Chen, Kui Dai, Werner Dietel,
Marko van Dooren, Anand Ganapathy, Yogy Namara, Todd Millstein,
Arun Raghavan, Frederic Rioux, Roy Tan, and Hao Xi
for their work on the
JML checker and tools used to check and manipulate
the specifications in this document.
@cindex Becker
@cindex Shilling
@cindex Thomas
@cindex Seagren
Thanks to Katie Becker, Kristina Boysen, Brandon Shilling, Elizabeth Seagren,
Ajani Thomas, and Arthur Thomas for help 
with case studies and specifications in JML.
@cindex Cheon
@cindex Clifton
@cindex Cok
@cindex Kiniry
@cindex Boysen
@cindex Chan
@cindex Chan Wai Ting
@cindex Dai
@cindex da Costa Gomez
@cindex Kiniry
@cindex Tan
@cindex Vermillard
Thanks to David Cok, Joe Kiniry, Yoonsik Cheon, Kristina Boysen,
Curtis Clifton, Judy Chan Wai Ting, Peter Chan, Marko
van Dooren, Kui Dai, Fermin da Costa Gomez, Joseph Kiniry, Roy Patrick Tan,
and Julien Vermillard
for bug reports about JML tools.
@cindex University of Iowa, 22C:181
@cindex ISU, Com S 362
@cindex Iowa State University, Com S 362
Thanks to the students in 22C:181 at the University of Iowa in Spring
2001, and in Com S 362 at Iowa State University
for suggestions and comments about JML.

@c ------ chapter Specification Case Defaults --------
@node Specification Case Defaults, Bibliography, Conclusions, Top
@c  node-name,  next,  previous,  up
@appendix Specification Case Defaults

@cindex defaults, for omitted clauses in method specifications
@cindex omitted clauses in method specifications
@cindex method specifications, defaults for clauses
@cindex lightweight specifications
@cindex heavyweight specifications
As noted above (@pxref{Lightweight Specifications}),
specifications in JML do not need to be as detailed
as most of the examples given in this document.
If a @var{spec-case} 
does not use one of the behavior keywords
(@code{behavior}, @code{normal_behavior}, or @code{exceptional_behavior}),
or if an @var{example}
does not use one of the example keywords
(@code{example}, @code{normal_example},
@code{exceptional_example}),
then it is called a @dfn{lightweight} specification or example.
Otherwise it is a @dfn{heavyweight} specification or example.

@kindex @code{\not_specified}
@cindex @code{requires}, default for
@cindex @code{when}, default for
@cindex @code{working_space}, default for
@cindex @code{duration}, default for
@cindex @code{measured_by}, default for
@cindex @code{assignable}, default for
@cindex @code{ensures}, default for
@cindex @code{signals}, default for
@cindex @code{diverges}, default for
When the various clauses of a @var{spec-case}
or @var{example} are omitted, they have
the defaults given in the table below.  The table distinguishes between
lightweight and heavyweight specifications and examples.  In most cases
the default for the lightweight form is that
no assumption is made about the omitted clause.  There are only two
exceptions to this rule.  The first is that for an omitted
@code{diverges} clause defaults to @code{false}.  The second is that
an omitted @code{signals_only} has a default that depends on the
exceptions declared in the method.

@display
   @t{                                Default}
   @t{Omitted clause  lightweight                 heavyweight} 
   @t{___________________________________________________________}
   @t{requires        \not_specified              true} 
   @t{diverges        false                       false}
   @t{measured_by     \not_specified              \not_specified}
   @t{assignable      \not_specified              \everything} 
   @t{when            \not_specified              true} 
   @t{working_space   \not_specified              \not_specified}
   @t{duration        \not_specified              \not_specified}
   @t{ensures         \not_specified              true}
   @t{signals_only    @i{see text}                    @i{see text}}
   @t{signals         \not_specified              (Exception) true} 
@end display

However, in a heavyweight
specification or example, the specifier is assumed to be giving a complete
specification or example.  Therefore, in a heavyweight specification the
meaning of an omitted clause is given a definite default.
For example, the meaning of an omitted @code{assignable} clause
is that all locations (that can otherwise be legally assigned to)
can be assigned.
@kindex @code{diverges}
Furthermore, in a non-lightweight specification, the meaning of an
omitted diverges clause is that the method may not diverge in that case.
(The @code{diverges} clause is almost always omitted; it can be used
to say what should be true, of the pre-state, when the specification
is allowed to loop forever or signal an error.)

The defaults for omitted @code{signals_only} and @code{signals} clauses do
not apply to @code{normal_behavior} specification cases, since
@code{normal_behavior} specification cases cannot contain these clauses.

@cindex @code{signals_only}, default for
The default for the @code{signals_only} clause is the same in both
heavyweight and lightweight specifications, but depends on the list of
exceptions declared in the method.  If the method declares no
exceptions, then the default clause is @code{signals_only \nothing;}
(which means that the method cannot throw any exceptions).
However, if the method header declares that the method may throw
exceptions @i{DE1}, @dots{}, @i{DEn}, then the default
@code{signals_only} clause is as follows.
@example
   signals_only @i{DE1}, @dots{}, @i{DEn}
@end example
@noindent
This default applies whenever the @code{signals_only} clause is
omitted from a specification case, even if the method has a
@code{signals} clause.  If this default is too strong, the effect can
be changed by either writing an explicit @code{signals_only} clause,
or by declaring further exceptions in the method's header.
Note that although Java allows runtime exceptions (subtypes of
@code{java.lang.RuntimeException}) to be thrown 
without being declared in a method's header, JML does not take make a
special case for these.

@cindex omitted specification, meaning of
@cindex method specification, omitted
@cindex constructor, default, specification of
@cindex default constructor, specification of
@cindex overriding method, meaning of omitted specification for
A completely omitted specification is taken to be a lightweight
specification.
If the default (zero-argument) constructor of a class is omitted
because its code is omitted,  then its specification defaults to
an assignable clause that allows all the locations that the
default (zero-argument) constructor of its superclass assigns --- in
essence a copy of the superclass's default constructor's assignable clause.
If some other frame is desired, then one has to write the specification,
or at least the code, explicitly.

@cindex completely omitted specification
@cindex specification, completely omitted
@kindex @code{non_null}
@kindex @code{pure}
A method or constructor with code present has a
@dfn{completely omitted} specification if it has no
@var{specification-case}s and does not use 
annotations like @code{non_null} or @code{pure} that add implicit
specifications.

If a method or constructor has code, has a completely omitted
specification, and does not override another method, then 
its meaning is taken as the lightweight specification
@code{diverges \not_specified;}. 
Thus, its meaning can be read
from the lightweight column of table above, except that the diverges
clause is not given its usual default.
This is done so that the default
specification when no specification is given truly says nothing about
the method's behavior.
However, if a method with code and a completely omitted
specification overrides some other method, then its meaning is taken
to be the lightweight specification @code{also requires false;}.  This somewhat
counter-intuitive specification is the unit under specification
conjunction with @code{also}; it is used so as not to
change the meaning of the inherited specification.

If the code is annotated with keywords like @code{non_null} or
@code{pure} that add implicit specifications, then these implicit
specifications are used instead of the default.  Code with such
annotations is considered to have an implicit specification.

@kindex @code{\not_specified}
It is intended that the meaning of @code{\not_specified} may vary
between different uses of a JML specification.
For example, a static checker might treat a @code{requires} clause 
that is @code{\not_specified} as if it were @code{true},
while a verification logic might treat it as if it were @code{false}.
However, a reasonable default for the interpretation for @code{\not_specified}
in a lightweight specification is the most liberal possible
(i.e., the one that permits the most correct implementations); this is
generally the same as the heavyweight default, except for the
@code{diverges} clause (where the most liberal interpretation would be
@code{true}).

@cindex @code{continues}, default for
@cindex @code{breaks}, default for
@cindex @code{returns}, default for
Note that specification statements
(see the @cite{JML Reference manual} [Leavens-etal-JMLRef] for details)
cannot be lightweight.  In addition, a @var{spec-statement} can specify
abrupt termination.  The additional clauses possible in a @var{spec-statement}
have the following defaults.  These are not liberally interpreted, but
instead prohibit the statement from having abrupt behavior by default.

@display
   @t{               Default}
   @t{Omitted clause (heavyweight)} 
   @t{____________________________}
   @t{continues      false}
   @t{breaks         false} 
   @t{returns        false}
@end display


@node Bibliography, Example Index, Specification Case Defaults, Top
@comment  node-name,  next,  previous,  up
@unnumbered Bibliography

@table @asis
@item [Arnold-Gosling-Holmes00]
Ken Arnold, James Gosling, and David Holmes.
@cite{The Java Programming Language Third Edition}.
The Java Series. Addison-Wesley, Reading, MA, 2000.

@item [America87]
Pierre America.
Inheritance and subtyping in a parallel object-oriented language.
In Jean Bezivin et al., editors,
@cite{ECOOP '87, European Conference on Object-Oriented Programming, Paris, France}, pages 234--242, New York, NY,
  June 1987. Springer-Verlag.
@cite{Lecture Notes in Computer Science}, volume 276.

@item [America91]
Pierre America.
Designing an object-oriented programming language with behavioural subtyping.
In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors,
@cite{Foundations of Object-Oriented Languages, REX School/Workshop,
Noordwijkerhout, The Netherlands, May/June 1990}, volume 489 of
@cite{Lecture Notes in Computer Science}, pages 60--90.
Springer-Verlag, New York, NY, 1991.

@item [Back88]
R. J. R. Back.
A calculus of refinements for program derivations.
@cite{Acta Informatica}, 25(6):593--624, August 1988.

@item [Back-vonWright89a]
R. J. R. Back and J. von Wright.
Refinement Calculus, Part I: Sequential Nondeterministic Programs.
In J. W. de Bakker, et al, (eds.),
@cite{Stepwise Refinement of Distributed Systems,
Models, Formalisms, Correctness, REX Workshop}, Mook, The Netherlands,
May/June 1989, pages 42-66.
Volume 430 of @cite{Lecure Notes Computer Science},
Spring-Verlag, 1989.

@item [Back-Mikhajlova-vonWright98]
Ralph Back, Anna Mikhajlova, and Joakim von Wright.
Modeling component environments and interactive programs using
  iterative choice.
Technical Report 200, Turku Centre for Computer Science, September
  1998.@*
  @file{http://www.tucs.abo.fi/publications/techreports/TR200.html}.

@item [Back-vonWright98]
Ralph-Johan Back and Joakim von Wright.
@cite{Refinement Calculus: A Systematic Introduction}.
Springer-Verlag, 1998.

@item [Beck-Gamm98]
Kent Beck and Erich Gamma.
Test infected: Programmers love writing tests.
@cite{Java Report}, 3(7), July 1998.

@item [Buechi-Weck00]
Martin B@"uchi and Wolfgang Weck.
The Greybox Approach: When Blackbox Specifications Hide Too Much.
Technical Report 297, Turku Centre for Computer Science, August 1999.@*
  @file{http://www.tucs.abo.fi/publications/techreports/TR297.html}.

@item [Borgida-Mylopoulos-Reiter95]
Alex Borgida, John Mylopoulos, and Raymond Reiter.
On the frame problem in procedure specifications.
@cite{IEEE Transactions on Software Engineering}, 21(10):785--798,
  October 1995.

@item [Chalin02]
Back to Basics: Language Support and Semantics of Basic Infinite
Integer Types in JML and Larch Technical Report CU-CS 2002-003.2,
Computer Science Department, Concordia University, October
2002. Updated March 2003, which is available from the URL@*
@file{http://www.cs.concordia.ca/~chalin/papers/TR-2002-003.pdf}.

@item [Chalin04]
Patrice Chalin.
JML Support for Primitive Arbitrary Precision Numeric Types:
Definition and Semantics. 
@cite{Journal of Object Technology}, 3(6):57-79, June 2004.  

@item [Cheon03]
Yoonsik Cheon.
A runtime assertion checker for the Java Modeling Language.
Technical Report 03-09, Department of Computer Science, Iowa State
University, Ames, IA, April 2003.
The author's Ph.D. dissertation, which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR03-09/TR.pdf}.

@item [Cheon-Leavens02]
Yoonsik Cheon and Gary T. Leavens.
A Simple and Practical Approach to Unit Testing: The JML and JUnit Way.
In @cite{ECOOP 2002 -- Object-Oriented Programming,
16th European Conference, Malaga, Spain}, pages 231--255.
Springer-Verlag, June 2002.
Also
Department of Computer Science, Iowa State University,
TR #01-12a, November 2001, revised March 2002
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR01-12/TR.pdf}.

@item [Cheon-Leavens02b]
Yoonsik Cheon and Gary T. Leavens.
A Runtime Assertion Checker for the Java Modeling Language (JML).
In Hamid R. Arabnia and Youngsong Mun (eds.),
@cite{Proceedings of the International Conference on Software
Engineering Research and Practice (SERP '02), Las Vegas, Nevada, USA},
pages 322--328. 
CSREA Press, June 2002.
Also
Department of Computer Science, Iowa State University,
TR #02-05, March 2002
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR02-05/TR.pdf}.

@item [Cheon-Leavens05]
Yoonsik Cheon and Gary T. Leavens.
A contextual interpretation of undefinedness for runtime assertion checking.
In @cite{AADEBUG 2005, Proceedings of the Sixth International
Symposium on Automated and Analysis-Driven Debugging, Monterey, California,
September 19--21, 2005}, pages 149--157. ACM Press, September 2005.

@item [Cohen90]
Edward Cohen.
@cite{Programming in the 1990s: An Introduction to the Calculation of Programs}.
Springer-Verlag, New York, N.Y., 1990.

@item [Chalin02]
Patrice Chalin.
Back to Basics: Language Support and Semantics
of Basic Infinite Integer Types in JML and Larch.
Computer Science Department, Concordia University,
Technical Report CU-CS 2002-003.1.  Available in
@file{http://tinyurl.com/e5q6g},
October, 2002.
                 
@item [Dhara-Leavens96]
Krishna Kishore Dhara and Gary T. Leavens.
Forcing behavioral subtyping through specification inheritance.
In @cite{Proceedings of the 18th International Conference on Software
  Engineering, Berlin, Germany}, pages 258--267. IEEE Computer Society Press,
  March 1996.
An extended version is
Department of Computer Science, Iowa State University,
TR #95-20b, December 1995,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR95-20/TR.ps.Z}.

@item [Ernst-etal01]
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin
Dynamically Discovering Likely Program Invariants to Support Program Evolution
@cite{IEEE Transactions on Software Engineering}, 27(2):1--25, February 2001.

@item [Finney96]
Kate Finney.
Mathematical notation in formal specification: Too difficult for the
  masses?
@cite{IEEE Transactions on Software Engineering}, 22(2):158--159,
  February 1996.

@item [Fitzgerald-Larsen98]
John Fitzgerald and Peter Gorm Larsen.
@cite{Modelling Systems: Practical Tools and Techniques in Software Development}.
Cambridge University Press, Cambridge, UK, 1998.

@item [Gifford-Lucassen86]
David K. Gifford and John M. Lucassen.
Integrating functional and imperative programming.
In @cite{ACM Conference on LISP and Functional Programming}, pages
  28--38. ACM, August 1986.

@item [Gosling-Joy-Steele96]
James Gosling, Bill Joy, and Guy Steele.
@cite{The Java Language Specification}.
The Java Series. Addison-Wesley, Reading, MA, 1996.

@item [Gosling-etal00]
James Gosling, Bill Joy, Guy Steele, and Gilad Bracha.
@cite{The Java Language Specification Second Edition}.
The Java Series. Addison-Wesley, Boston, MA, 2000.

@item [Gries-Schneider95]
David Gries and Fred B. Schneider.
Avoiding the Undefined by Underspecification.
In Jan van Leeuwen, editor,
@cite{Computer Science Today: Recent Trends and Developments},
volume 1000 of @cite{Lecture Notes in Computer Science}, pages 366--373.
Springer-Verlag, New York, N.Y., 1995.

@item [Guttag-Horning93]
John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M.
  Wing.
@cite{Larch: Languages and Tools for Formal Specification}.
Springer-Verlag, New York, N.Y., 1993.

@item [Hayes93]
I. Hayes, editor.
@cite{Specification Case Studies}.
International Series in Computer Science. Prentice-Hall, Inc., second
  edition, 1993.

@item [Hoare69]
C. A. R. Hoare.
An axiomatic basis for computer programming.
@cite{Communications of the ACM}, 12(10):576--583, October 1969.

@item [Hoare72a]
C. A. R. Hoare.
Proof of correctness of data representations.
@cite{Acta Informatica}, 1(4):271--281, 1972.

@item [Huisman01]
Marieke Huisman. 
Reasoning about JAVA programs in higher order logic with PVS and Isabelle.
IPA dissertation series, 2001-03.
Ph.D. dissertation, University of Nijmegen, 2001.

@item [ISO96]
International Standards Organization.
@cite{Information Technology - Programming Languages, Their
Environments and System Software Interfaces - 
Vienna Development Method - Specification Language - Part 1: Base language}.
International Standard ISO/IEC 13817-1, December, 1996.

@item [Jacobs-etal98]
Bart Jacobs, Joachim van den Berg, Marieke Huisman
Martijn van Berkum, Ulrich Hensel, and Hendrik Tews.
Reasoning about Java Classes (Preliminary Report).
In @cite{OOPSLA '98 Conference Proceedings}, volume 33, number 10
  of @cite{ACM SIGPLAN Notices}, pages 329--340.
  October 1998.

@item [Jones90]
Cliff B. Jones.
@cite{Systematic Software Development Using VDM}.
International Series in Computer Science. Prentice Hall, Englewood
  Cliffs, N.J., second edition, 1990.

@item [Jonkers91]
H. B. M. Jonkers.
Upgrading the pre- and postcondition technique.
In S. Prehn and W. J. Toetenel, editors, @cite{VDM '91 Formal Software
  Development Methods 4th International Symposium of VDM Europe
  Noordwijkerhout, The Netherlands, Volume 1: Conference Contributions}, volume
  551 of @cite{Lecture Notes in Computer Science}, pages 428--456.
  Springer-Verlag, New York, N.Y., October 1991.

@item [Lano-Haughton94]
K. Lano and H. Haughton, editors.
@cite{Object-Oriented Specification Case Studies}.
The Object-Oriented Series. Prentice Hall, New York, N.Y., 1994.

@item [Leavens96b]
Gary T. Leavens.
An overview of Larch/C++: Behavioral specifications for C++ modules.
In Haim Kilov and William Harvey, editors, @cite{Specification of
  Behavioral Semantics in Object-Oriented Information Modeling}, chapter 8,
  pages 121--142. Kluwer Academic Publishers, Boston, 1996.
An extended version is TR #96-01d, Department of Computer Science,
  Iowa State University, Ames, Iowa, 50011.

@item [Leavens97c]
Gary T. Leavens.
@cite{Larch/C++ Reference Manual}.
Version 5.14. Available in@*
@file{http://www.eecs.ucf.edu/~leavens/larchc++.html}, October 1997.

@item [LeavensLarchFAQ]
Gary T. Leavens.
Larch frequently asked questions.
Version 1.110. Available in
  @file{http://www.eecs.ucf.edu/~leavens/larch-faq.html}, May 2000.

@item [Leavens-etal-JMLRef]
Gary T. Leavens, Erik Poll, Curtis Clifton, Yoonsik Cheon, 
Clyde Ruby, David Cok, Peter M@"uller, and Joseph Kiniry.
@cite{JML Reference Manual}.
Available from
  @file{http://www.jmlspecs.org/}.

@item [Leavens-Baker99]
Gary T. Leavens and Albert L. Baker.
Enhancing the pre- and postcondition technique for more expressive
  specifications.
In Jeannette M. Wing, Jim Woodcock, and Jim Davies, editors, @cite{
  FM'99 --- Formal Methods: World Congress on Formal Methods in the
  Development of Computing Systems, Toulouse, France, September 1999,
  Proceedings}, volume 1709 of @cite{Lecture Notes in Computer Science}, pages
  1087--1106. Springer-Verlag, 1999.

@item [Leavens-Baker-Ruby99]
Gary T. Leavens, Albert L. Baker, and Clyde Ruby.
JML: a Notation for Detailed Design.
In Haim Kilov, Bernhard Rumpe, and Ian Simmonds (editors),
  @cite{Behavioral Specifications for Businesses and Systems},
  chapter 12, pages 175-188.

@item [Leavens-Weihl95]
Gary T. Leavens and William E. Weihl.
Specification and verification of object-oriented programs using
supertype abstraction.
@cite{Acta Informatica}, 32(8):705--778, November 1995.

@item [Leavens-Wing97a]
Gary T. Leavens and Jeannette M. Wing.
Protective interface specifications.
In Michel Bidoit and Max Dauchet, editors, @cite{TAPSOFT '97: Theory
  and Practice of Software Development, 7th International Joint Conference
  CAAP/FASE, Lille, France}, volume 1214 of @cite{Lecture Notes in Computer
  Science}, pages 520--534. Springer-Verlag, New York, N.Y., 1997.

@item [Ledgard80]
Henry. F. Ledgard.
A human engineered variant of BNF.
@cite{ACM SIGPLAN Notices}, 15(10):57--62, October 1980.

@item [Leino95a]
K. Rustan M. Leino.
A myth in the modular specification of programs.
Technical Report KRML 63, Digital Equipment Corporation, Systems
  Research Center, 130 Lytton Avenue Palo Alto, CA 94301, November 1995.
Obtain from the author, at leino@@microsoft.com.

@item [Leino95]
K. Rustan M. Leino.
@cite{Toward Reliable Modular Programs}.
PhD thesis, California Institute of Technology, 1995.
Available as Technical Report Caltech-CS-TR-95-03.

@item [Leino98]
K. Rustan M. Leino.
Data groups: Specifying the modification of extended state.
In @cite{OOPSLA '98 Conference Proceedings}, pp. 144-153.
Volume 33, number 10 of @cite{ACM SIGPLAN Notices}, October, 1998.


@item [Leino-Nelson-Saxe00]
K. Rustan M. Leino, Greg Nelson, and James B. Saxe.
ESC/Java User's Manual. Compaq SRC Technical Note 2000-02, October, 2000.

@item [Leino-Poetzsch-Heffter-Zhou02]
Using Data Groups to Specify and Check Side Effects.
@cite{Proceedings of the ACM SIGPLAN 2002 Conference on
      Programming Language Design and Implementation (PLDI '02)},
 pp. 246-257.
Volume 37, number 5 of @cite{ACM SIGPLAN Notices}, June, 2002.

@item [Leino-etal00]
K. Rustan M. Leino, Mark Lillibridge, Greg Nelson,
James B. Saxe, and Raymie Stata.
Extended Static Checking. Web page at@*
  @file{http://research.compaq.com/SRC/esc/Esc.html}.

@item [Lerner91]
Richard Allen Lerner.
Specifying objects of concurrent systems.
Ph.D. Thesis CMU-CS-91-131, School of Computer Science, Carnegie
  Mellon University, May 1991.

@item [Liskov-Wing94]
Barbara Liskov and Jeannette Wing.
A behavioral notion of subtyping.
@cite{ACM Transactions on Programming Languages and Systems},
  16(6):1811--1841, November 1994.

@item [Lucassen87]
John M. Lucassen.
Types and effects: Towards the integration of functional and
  imperative programming.
Technical Report TR-408, Massachusetts Institute of Technology,
  Laboratory for Computer Science, August 1987.

@item [Lucassen-Gifford88]
John M. Lucassen and David K. Gifford.
Polymorphic effect systems.
In @cite{Conference Record of the Fifteenth Annual ACM Symposium on
  Principles of Programming Languages, San Diego, Calif.}, pages 47--57. ACM,
  January 1988.

@item [Luckham-vonHenke85]
David Luckham and Friedrich W. von Henke.
An overview of Anna - a specification language for Ada.
@cite{IEEE Software}, 2(2):9--23, March 1985.

@item [Luckham-etal87]
David Luckham, Friedrich W. von Henke, Bernd Krieg-Br@"uckner, and Olaf Owe.
@cite{ANNA - A Language for Annotating Ada Programs}, volume 260
  of @cite{Lecture Notes in Computer Science}.
Springer-Verlag, New York, N.Y., 1987.

@item [Meyer92a]
Bertrand Meyer.
Applying ``design by contract''.
@cite{Computer}, 25(10):40--51, October 1992.

@item [Meyer92b]
Bertrand Meyer.
@cite{Eiffel: The Language}.
Object-Oriented Series. Prentice Hall, New York, N.Y., 1992.

@item [Meyer97]
Bertrand Meyer.
@cite{Object-oriented Software Construction}.
Prentice Hall, New York, N.Y., second edition, 1997.

@item [Morgan94]
Carroll Morgan.
@cite{Programming from Specifications: Second Edition}.
Prentice Hall International, Hempstead, UK, 1994.

@item [Morgan-Vickers94]
Carroll Morgan and Trevor Vickers, editors.
@cite{On the refinement calculus}.
Formal approaches of computing and information technology series.
  Springer-Verlag, New York, N.Y., 1994.

@item [Morris87]
Joseph M. Morris.
A theoretical basis for stepwise refinement and the programming calculus.
@cite{Science of Computer Programming}, 9(3):287--306, December 1987.

@item [Mueller02]
Peter M@"uller.
Modular Specification and Verification of Object-Oriented Programs.
Volume 2262 of @cite{Lecture Notes in Computer Science},
Springer-Verlag, 2002.

@item [Nielson-Nielson-Amtoft97]
H. R. Nielson, F. Nielson, and T. Amtoft.
Polymorphic subtyping for effect analysis: The static semantics.
In M. Dam, editor, @cite{Proceedings of the Fifth LOMAPS Workshop},
  number 1192 in @cite{Lecture Notes in Computer Science}. Springer-Verlag, 1997.

@item [Ogden-etal94]
William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. Zweben.
Part I: The RESOLVE framework and discipline --- a research
  synopsis.
@cite{ACM SIGSOFT Software Engineering Notes}, 19(4):23--28, Oct 1994.

@item [Owre-etal95]
Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke.
Formal verification for fault-tolerant architectures: Prolegomena to
  the design of PVS.
@cite{IEEE Transactions on Software Engineering}, 21(2):107--125,
  February 1995.

@item [Poll-Jacobs00]
E. Poll and B.P.F. Jacobs.
A Logic for the Java Modeling Language JML.
Computing Science Institute Nijmegen, Technical Report CSI-R0018.
Catholic University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen,
November 2000.

@item [Poetzsch-Heffter97]
Arnd Poetzsch-Heffter.
Specification and verification of object-oriented programs.
Habilitation thesis, Technical University of Munich, January 1997.

@item [Raghavan-Leavens05]
Arun D. Raghavan and Gary T. Leavens.
Desugaring JML Method Specifications.
Technical Report 00-03e, Department of Computer Science, Iowa State
  University, Ames, Iowa, 50011, revised May 2005.
Available in@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR00-03/TR.ps.gz}.

@item [Rosenblum95]
David S. Rosenblum.
A practical approach to programming with assertions.
@cite{IEEE Transactions on Software Engineering}, 21(1):19--31,
  January 1995.

@item [Ruby-Leavens00]
Clyde Ruby and Gary T. Leavens.
Safely Creating Correct Subclasses without Seeing Superclass Code.
In @cite{OOPSLA 2000 Conference on Object-Oriented Programming,
  Systems, Languages, and Applications, Minneapolis, Minnesota}, pp. 208-228.
Volume 35, number 10 of @cite{ACM SIGPLAN Notices}, October, 2000.
Also technical report 00-05d, Department of Computer Science, Iowa State
  University, Ames, Iowa, 50011. April 2000, revised April, June, July 2000.
Available in@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR00-05/TR.ps.gz}.

@item [Salcianu-Rinard05]
Alexandru Salcianu and Martin Rinard.
Purity and Side Effect Analysis for Java Programs.
In Proceedings of the 6th International Conference on Verification,
Model Checking and Abstract Interpretation. Paris, France January 2005.
Available in@*
  @file{http://www.mit.edu/~salcianu/publications/vmcai05-purity.pdf}

@item [Sivaprasad95]
Gowri Sivaprasad.
Larch/CORBA: Specifying the behavior of CORBA-IDL interfaces.
Technical Report 95-27a, Department of Computer Science, Iowa State
  University, Ames, Iowa, 50011, December 1995.

@item [Spivey92]
J. Michael Spivey.
@cite{The Z Notation: A Reference Manual}.
International Series in Computer Science. Prentice-Hall, New York,
  N.Y., second edition, 1992.

@item [Talpin-Jouvelot94]
Jean-Pierre Talpin and Pierre Jouvelot.
The type and effect discipline.
@cite{Information and Computation}, 111(2):245--296, June 1994.

@item [Tan94]
Yang Meng Tan.
Interface language for supporting programming styles.
@cite{ACM SIGPLAN Notices}, 29(8):74--83, August 1994.
Proceedings of the Workshop on Interface Definition Languages.

@item [Tan95]
Yang Meng Tan.
@cite{Formal Specification Techniques for Engineering Modular C
  Programs}, volume 1 of @cite{Kluwer International Series in Software
  Engineering}.
Kluwer Academic Publishers, Boston, 1995.

@item [Wahls-Leavens-Baker00]
Tim Wahls, Gary T. Leavens, and Albert L. Baker.
Executing Formal Specifications with Concurrent Constraint Programming.
@cite{Automated Software Engineering}, 7(4):315-343, December, 2000.

@item [Watt91]
David A. Watt.
@cite{Programming Language Syntax and Semantics}.
Prentice Hall International Series in Computer Science.
  Prentice-Hall, New York, N.Y., 1991.

@item [Whitehead-Russell25]
A. N. Whitehead and B. Russell.
@cite{Principia Mathematica}.
Cambridge University Press, London, second edition. edition, 1925.

@item [Wills94]
Alan Wills.
Refinement in Fresco.
In Lano and Houghton [Lano-Haughton94], chapter 9, pages
  184--201.

@item [Wing87]
Jeannette M. Wing.
Writing Larch interface language specifications.
@cite{ACM Transactions on Programming Languages and Systems},
  9(1):1--24, January 1987.

@item [Wing90a]
Jeannette M. Wing.
A specifier's introduction to formal methods.
@cite{Computer}, 23(9):8--24, September 1990.

@item [Wing83]
Jeannette Marie Wing.
A two-tiered approach to specifying programs.
Technical Report TR-299, Massachusetts Institute of Technology,
  Laboratory for Computer Science, 1983.

@item [Woodcock-Davies96]
Jim Woodcock and Jim Davies.
@cite{Using Z: Specification, Refinement, and Proof}.
Prentice Hall, International Series in Computer Science, 1996.

@item [Wright92]
Andrew K. Wright.
Typing references by effect inference.
In Bernd Krieg-Bruckner, editor, @cite{ESOP '92, 4th European
  Symposium on Programming, Rennes, France, February 1992, Proceedings}, volume
  582 of @cite{Lecture Notes in Computer Science}, pages 473--491.
  Springer-Verlag, New York, N.Y., 1992.
@end table

@node Example Index, Concept Index, Bibliography, Top
@c node-name, next, previous, up
@unnumbered Example Index

@printindex pg

@node Concept Index,  , Example Index, Top
@c node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye
