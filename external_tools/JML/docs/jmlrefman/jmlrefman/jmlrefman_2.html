<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 20  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>JML Reference Manual: Fundamental Concepts</TITLE>

<META NAME="description" CONTENT="JML Reference Manual: Fundamental Concepts">
<META NAME="keywords" CONTENT="JML Reference Manual: Fundamental Concepts">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC8"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_1.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_3.html#SEC24"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 2. Fundamental Concepts </H1>
<!--docid::SEC8::-->
<P>

<A NAME="IDX232"></A>
<A NAME="IDX233"></A>
This chapter discusses fundamental concepts that are used in
explaining the semantics of JML.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC9">2.1 Types can be Classes and Interfaces</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC10">2.2 Model and Ghost</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC11">2.3 Lightweight and Heavyweight Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC13">2.5 Instance vs. Static</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC14">2.6 Locations and Aliasing</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC15">2.7 Expression Evaluation and Undefinedness</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC16">2.8 Null is Not the Default</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC17">2.9 Language Levels</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Types can be Classes and Interfaces"></A>
<HR SIZE="6">
<A NAME="SEC9"></A>
<H2> 2.1 Types can be Classes and Interfaces </H2>
<!--docid::SEC9::-->
<P>

<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
In this manual we use <EM>type</EM> to mean either a class, interface, or
primitive value type in Java.  (Primitive value types include
<CODE>boolean</CODE>, <CODE>int</CODE>, etc.)
</P><P>

<A NAME="IDX236"></A>
A <EM>reference type</EM> is a type that is not a primitive value type,
that is either a class or interface.  When it is not necessary to
emphasize that primitive value types are not included, we often shorten
"reference type" to just "type".
</P><P>

<A NAME="Model and Ghost"></A>
<HR SIZE="6">
<A NAME="SEC10"></A>
<H2> 2.2 Model and Ghost </H2>
<!--docid::SEC10::-->
<P>

<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>
<A NAME="IDX241"></A>
In JML one can declare various names with the modifier <CODE>model</CODE>; for
example one can declare model fields, methods, and even types.
One can also declare some fields as <CODE>ghost</CODE> fields.
JML also has a <CODE>model import</CODE> directive (see section <A HREF="jmlrefman_5.html#SEC32">5. Compilation Units</A>).
</P><P>

<A NAME="IDX242"></A>
The meaning of a feature declared with <CODE>model</CODE> is that it is only
present for specification purposes.  For example a model field is an
imaginary field that is only used for specifications and is not
available for use in Java code outside of annotations.
Similarly, a model method is a method that can be used in annotations,
but cannot be used in ordinary Java code.  A model import directive
imports names that can be used only within annotations.
</P><P>

<A NAME="IDX243"></A>
<A NAME="IDX244"></A>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
<A NAME="IDX247"></A>
<A NAME="IDX248"></A>
The most common and useful model declarations are model fields.
A model field should be thought of as the abstraction of one or more
non-model (i.e., Java or <EM>concrete</EM>) fields <A HREF="jmlrefman_27.html#BIB16">[Cheon-etal05]</A>.
(By contrast, some authors refer to what JML calls model fields as
"abstract fields" <A HREF="jmlrefman_27.html#BIB73">[Leino98]</A>.)
The value of a model field is determined by the concrete fields it
abstracts from; in JML this relationship is specified by a
<CODE>represents</CODE> clause (see section <A HREF="jmlrefman_8.html#SEC74">8.4 Represents Clauses</A>).
(Thus the values of the model fields in an object determines its
"abstract value" <A HREF="jmlrefman_27.html#BIB40">[Hoare72a]</A>.) 
A model field also defines a data group <A HREF="jmlrefman_27.html#BIB73">[Leino98]</A>,
which collects model and concrete fields and is used to tell JML what
concrete fields may be assigned by various methods (see section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>).
</P><P>

<A NAME="IDX249"></A>
<A NAME="IDX250"></A>
Unlike model fields, model methods and model types are not
abstractions of non-model methods or types.  They are simply methods or
types that we imagine that the program has, to help in a specification.
</P><P>

<A NAME="IDX251"></A>
<A NAME="IDX252"></A>
A <CODE>ghost</CODE> field is similar to a model field, in that it is
also only present for purposes of specification and thus cannot be
used outside of annotations.
However, unlike a model field, a ghost field does not have a value
determined by a represents clause; instead its value is directly
determined by its initialization or by a <VAR>set-statement</VAR>
(see section <A HREF="jmlrefman_12.html#SEC163">12. Statements and Annotation Statements</A>).
</P><P>

<A NAME="IDX253"></A>
<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
<A NAME="IDX256"></A>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>
<A NAME="IDX259"></A>
Although these model and ghost names are used only for specifications,
JML uses the same namespace for such names as for normal Java names.
Thus, one cannot declare a field to be both a model (or ghost) field and
a normal Java field in the same class (or in a refinement, see section <A HREF="jmlrefman_16.html#SEC193">16. Refinement</A>).
Similarly, a method is either a model method or not.
In part, this is done because JML has no syntactic distinction between
Java and JML field access or method calls.
This decision makes it an error for someone to use the same name as a
model or ghost feature in an implementation.
In such a case if the Java code is considered to be the goal, one can
either change the name of the JML feature or have one declaration in which
the Java feature is modified with the JML modifier <CODE>spec_public</CODE>.
See section <A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A>, for more about <CODE>spec_public</CODE>.
</P><P>

<A NAME="Lightweight and Heavyweight Specifications"></A>
<HR SIZE="6">
<A NAME="SEC11"></A>
<H2> 2.3 Lightweight and Heavyweight Specifications </H2>
<!--docid::SEC11::-->
<P>

<A NAME="IDX260"></A>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
<A NAME="IDX263"></A>
In JML one is not required to specify behavior completely.  Indeed, JML
has a style of method specification case, called <EM>lightweight</EM>, in
which the user only says what interests them.  On the other hand, in a
<EM>heavyweight</EM> specification case, JML expects that the user is fully
aware of the defaults involved. In a heavyweight specification case,
JML expects that a user only omits parts of the specification case
when the user believes that the default is appropriate.
</P><P>

<A NAME="IDX264"></A>
<A NAME="IDX265"></A>
<A NAME="IDX266"></A>
Users distinguish these between such cases of method specifications by
using different syntaxes. See section <A HREF="jmlrefman_9.html#SEC82">9.2 Organization of Method Specifications</A>,
for details, but in essence in a method specification case that
uses one of the behavior keywords (such as <CODE>normal_behavior</CODE>,
<CODE>exceptional_behavior</CODE>, or <CODE>behavior</CODE>) is heavyweight,
while one that does not use such a keyword is lightweight.
</P><P>

<A NAME="Privacy Modifiers and Visibility"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<H2> 2.4 Privacy Modifiers and Visibility </H2>
<!--docid::SEC12::-->
<P>

<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
<A NAME="IDX275"></A>
Java code that is not within an annotation uses the usual access control
rules for
determining visibility (or accessibility) of Java <A HREF="jmlrefman_27.html#BIB2">[Arnold-Gosling-Holmes00]</A>
<A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>.
That is, a name declared in package <I>P</I> and type <I>P.T</I>
may be referenced from outside <I>P</I>
only if it is declared as <CODE>public</CODE>,
or if it is declared as <CODE>protected</CODE>
and the reference occurs within a subclass of <I>P.T</I>.
This name may be referenced from within <I>P</I>
but outside of <I>P.T</I>
only if it is declared as <CODE>public</CODE>, default access,
or <CODE>protected</CODE>.
Such a name may always be referenced from within <I>P.T</I>,
even if it is declared as <CODE>private</CODE>.
See the Java language specification <A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>
for details on visibility rules
applied to nested and inner classes.
</P><P>

<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>
<A NAME="IDX281"></A>
Within annotations, JML imposes some extra rules in addition
to the usual Java visibility rules <A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A>.
These rules depend not just on the declaration of the name but also on
the visibility level of the context that is referring to the name in
question. 
For purposes of this section, the <EM>annotation context</EM> of a
reference to a name is the smallest grammatical unit with an attached
(or implicit) visibility.  For example, this annotation context can be a method
specification case, an invariant, a history constraint, or a field declaration.
The visibility level of such an annotation context can be <CODE>public</CODE>, 
<CODE>protected</CODE>, <CODE>private</CODE>, or default (package) visibility. 
</P><P>

The JML rule, in essence, is that an annotation context cannot refer to names
that are more hidden than the context's own visibility.
That is, for a reference to a name <I>x</I> to be legal,
the visibility of the annotation context that contains the
reference to <I>x</I> must be at least as permissive as the declaration
of <I>x</I> itself.  The reason for this restriction is that
the people who are allowed to see the annotation should be able to
see each of the names used in that annotation <A HREF="jmlrefman_27.html#BIB80">[Meyer97]</A>,
otherwise they might not understand it.  For example, public clients
should be able to see all the declarations of names in publicly
visible annotations, hence public annotations should not contain
protected, default access, or private names.
</P><P>

In more detail, 
suppose <I>x</I> is a name declared in package <I>P</I> and type <I>P.T</I>.
<UL>
<LI>
An expression in a public annotation context
(e.g., in  a public method specification)
can refer to <I>x</I> only if <I>x</I> is declared as <CODE>public</CODE>.
<P>

<LI>
An expression in a protected annotation context
(e.g., in a protected method specification)
can refer to <I>x</I> only if <I>x</I> is declared as <CODE>public</CODE>
or <CODE>protected</CODE>, and <I>x</I> must also be visible according to
Java's rules (so if <I>x</I> is <CODE>protected</CODE>,
then the reference must either be from within <I>P</I>
or, if it is from outside <I>P</I>,
then the reference must occur in a subclass of <I>P.T</I>).
<P>

<LI>
An expression in a default (package) visibility annotation context
(e.g., in a default visibility method specification)
can refer to <I>x</I> only if <I>x</I> is declared as <CODE>public</CODE>,
<CODE>protected</CODE>, or with default visibility,
and <I>x</I> must also be visible according to
Java's rules (so if <I>x</I> has default visibility,
then the reference must be from within <I>P</I>).
<P>

<LI>
An expression in a <CODE>private</CODE> visibility annotation context
(e.g., in a private method specification)
can refer to <I>x</I> only if <I>x</I> is visible according to
Java's rules (so if <I>x</I> has private visibility,
then the reference must be from within <I>P.T</I>).
</UL>
<P>

In the following example, the comments on the right show which uses of
the various privacy level names are legal and illegal.  Similar
examples could be given for method specifications, history
constraints, and so on.
</P><P>

<A NAME="IDX282"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>public class PrivacyDemoLegalAndIllegal {
   public int pub;
   protected int prot;
   int def;
   private int priv;

   //@ public invariant pub &#62; 0;      // legal
   //@ public invariant prot &#62; 0;     // illegal!
   //@ public invariant def &#62; 0;      // illegal!
   //@ public invariant priv &#60; 0;     // illegal!

   //@ protected invariant pub &#62; 1;   // legal
   //@ protected invariant prot &#62; 1;  // legal
   //@ protected invariant def &#62; 1;   // illegal!
   //@ protected invariant priv &#60; 1;  // illegal!

   //@ invariant pub &#62; 1;              // legal
   //@ invariant prot &#62; 1;             // legal
   //@ invariant def &#62; 1;              // legal
   //@ invariant priv &#60; 1;             // illegal!

   //@ private invariant pub &#62; 1;      // legal
   //@ private invariant prot &#62; 1;     // legal
   //@ private invariant def &#62; 1;      // legal
   //@ private invariant priv &#60; 1;     // legal
}
</pre></td></tr></table></P><P>

<A NAME="IDX283"></A>
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
Note that in a lightweight method specification,
the privacy level is assumed to be the same privacy level as the
method itself.  That is, for example, a protected method with a
lightweight method specification is considered to be
a protected annotation context for purposes of checking proper visibility usage
<A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A> <A HREF="jmlrefman_27.html#BIB89">[Mueller02]</A>.
See section <A HREF="jmlrefman_2.html#SEC11">2.3 Lightweight and Heavyweight Specifications</A>, for more about the
differences between lightweight and heavyweight specification cases.
</P><P>

<A NAME="IDX290"></A>
<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>
<A NAME="IDX294"></A>
The ESC/Java2 system has the same visibility rules as described above.
(However, this was not true of the old version of ESC/Java
<A HREF="jmlrefman_27.html#BIB69">[Leino-Nelson-Saxe00]</A>.)
</P><P>

<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
The JML keywords <CODE>spec_public</CODE> and <CODE>spec_protected</CODE> provide
a way to make a declaration 
that has different visibilities for Java and JML.  For example, the
following declaration declares an integer field that Java regards as
private but JML regards as public.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    private /*@ spec_public @*/ int length;
</pre></td></tr></table></P><P>

Thus for example, <CODE>length</CODE> in the above declaration
could be used in a public method specification or invariant.
</P><P>

<A NAME="IDX297"></A>
<A NAME="IDX298"></A>
However, <CODE>spec_public</CODE> is more than just a way to change the
visibility of a name for specification purposes.  When applied to
fields it can be considered to be shorthand for the declaration of a
model field with the same name.  That is, the declaration of <CODE>length</CODE>
above can be thought of as equivalent to the following
declarations, together with a rewrite of the Java code that uses
<CODE>length</CODE> to use <CODE>_length</CODE> instead
(where we assume <CODE>_length</CODE> is fresh, i.e., not used elsewhere).
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  //@ public model int length;
  private int _length; //@ in length;
  //@ private represents length &#60;- _length;
</pre></td></tr></table></P><P>

The above desugaring allows one to change the underlying field without
affecting the readers of the specification.
</P><P>

<A NAME="IDX299"></A>
<A NAME="IDX300"></A>
The desugaring of <CODE>spec_protected</CODE> is the same as for
<CODE>spec_public</CODE>, except that one uses <CODE>protected</CODE>
instead of <CODE>public</CODE> in the desugared form.
</P><P>

<A NAME="Instance vs. Static"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<H2> 2.5 Instance vs. Static </H2>
<!--docid::SEC13::-->
<P>

<A NAME="IDX301"></A>
<A NAME="IDX302"></A>
In Java, a feature of a class or interface may declared to be
<CODE>static</CODE>.  This means that the feature is not part of instances
of that type, and it means that references to that feature (from
outside the type and its subtypes) must use a qualified name of the
form <I>T.f</I>, which refers to the static feature <I>f</I> in type <I>T</I>.
</P><P>

<A NAME="IDX303"></A>
A feature, such as a field or method, of a type that is not static is
an <EM>instance</EM> feature.  For example, in a Java interface, all the
methods declared are instance methods, although fields are static by
default.  In a Java class the default is that all features are
instance features, unless the modifier <CODE>static</CODE> is used.
</P><P>

<A NAME="IDX304"></A>
In JML declarations follow the normal Java rules for determining
whether they are instance or static features of a type.  However,
within annotations it is possible to explicitly label features as
<CODE>instance</CODE> (see section <A HREF="jmlrefman_6.html#SEC35">6. Type Definitions</A> for the syntax).
The use of the <CODE>instance</CODE> modifier is necessary to declare model
and ghost instance fields in interfaces, since otherwise the Java
default modifier for fields in interfaces (static) would apply.
</P><P>

It is also useful, in JML, to label invariants as either static or
instance invariants. See section <A HREF="jmlrefman_8.html#SEC66">8.2.1 Static vs. instance invariants</A>, for more
on this topic.
</P><P>

<A NAME="Locations and Aliasing"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<H2> 2.6 Locations and Aliasing </H2>
<!--docid::SEC14::-->
<P>

<A NAME="IDX305"></A>
A <EM>location</EM> is a field of an object or a local variable.  A
<EM>local variable</EM> is either a variable declared inside a method or
a formal parameter of a method.
</P><P>

<A NAME="IDX306"></A>
An <EM>access path</EM> is an expression either of the form <I>x</I>, where 
<I>x</I> is an identifier, or <I>p</I><CODE>.</CODE><I>x</I>, where <I>p</I> is an access
path and <I>x</I> is an identifier.<A NAME="DOCF5" HREF="jmlrefman_fot.html#FOOT5">(5)</A>
(In forming an access path, we ignore visibility.)
</P><P>

<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
In a given program state, <I>s</I>, a location <I>l</I> is <EM>aliased</EM> if there
are two or more access paths that, in <I>s</I>, both denote <I>l</I>.
The access paths in question are said to be <EM>aliases</EM> for <I>l</I>.
Similarly, we say that an object <I>o</I> is aliased in a state <I>s</I>
if there are two access paths that, in <I>s</I>, both have <I>o</I> as their value.
In Java, it is impossible to alias local variables, so the only
aliasing possible involves objects and their fields.
</P><P>

<A NAME="Expression Evaluation and Undefinedness"></A>
<HR SIZE="6">
<A NAME="SEC15"></A>
<H2> 2.7 Expression Evaluation and Undefinedness </H2>
<!--docid::SEC15::-->
<P>

<A NAME="IDX309"></A>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>
<A NAME="IDX312"></A>
<A NAME="IDX313"></A>
Within JML annotations, Java expressions have the values that
are defined in the Java Language Specification <A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>.
<A NAME="IDX314"></A>
<A NAME="IDX315"></A>
<A NAME="IDX316"></A>
<A NAME="IDX317"></A>
<A NAME="IDX318"></A>
This has consequences on the interpretation of assertion expressions
<A HREF="jmlrefman_27.html#BIB12">[Chalin07]</A> <A HREF="jmlrefman_27.html#BIB96">[Rioux-Chalin07]</A>:
an assertion is taken to be valid if and only if its interpretation
<UL>
<LI>
does not cause an exception to be raised, and
<LI>
yields the value true.
</UL>
<A NAME="IDX319"></A>
<A NAME="IDX320"></A>
<A NAME="IDX321"></A>
<A NAME="IDX322"></A>
<A NAME="IDX323"></A>
<A NAME="IDX324"></A>
<A NAME="IDX325"></A>
<A NAME="IDX326"></A>
<A NAME="IDX327"></A>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
<A NAME="IDX330"></A>
<A NAME="IDX331"></A>
<A NAME="IDX332"></A>
<A NAME="IDX333"></A>
<A NAME="IDX334"></A>
Note that this interpretation of assertions, said to be based on
"strong validity" <A HREF="jmlrefman_27.html#BIB12">[Chalin07]</A>, was made the default assertion
semantics for JML in 2007.  Prior to that, assertions were interpreted
using a classical defintion of validity <A HREF="jmlrefman_27.html#BIB57">[Leavens-etal05]</A>
<A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A> <A HREF="jmlrefman_27.html#BIB33">[Gries-Schneider95]</A> <A HREF="jmlrefman_27.html#BIB46">[Jones95e]</A>.
<P>

The strong validity semantics for assertion evaluation means that
exceptions may arise during evaluation of subexpressions within assertions.
These exceptions should be avoided by the specifier and tools are
encouraged to warn users when they detect that an exception may arise
during assertion evalution.
</P><P>

<A NAME="IDX335"></A>
<A NAME="IDX336"></A>
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>
<A NAME="IDX341"></A>
<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
<A NAME="IDX344"></A>
<A NAME="IDX345"></A>
To avoid exceptions during assertion evaluation, specifiers should
practice good Java coding habits, and write specifications that
prevent such exceptions. 
To do this, one can use left-to-right ordering of evaluation of
subexpressions and the short-curcuit nature of the Java 
operators <CODE>&#38;&#38;</CODE> and <CODE>||</CODE>.
JML also evaluates the its two implication operators,
<CODE>==&#62;</CODE> and <CODE>&#60;==</CODE> in short-curcuit fashion.
Within a specification case, the precondition can
protect the rest of the specification from exceptions
<A HREF="jmlrefman_27.html#BIB62">[Leavens-Wing98]</A>.
That is, one can assume that the precondition holds in the remainder
of the clauses in a specification case.
JML also evaluates multiple occurrences of clauses of the same kind
(such as <CODE>requires</CODE> or <CODE>ensures</CODE>) within a spec case in top
to bottom order, so earlier clauses can protect later ones, just as if they
were combined with <CODE>&#38;&#38;</CODE>.
</P><P>

<A NAME="Null is Not the Default"></A>
<HR SIZE="6">
<A NAME="SEC16"></A>
<H2> 2.8 Null is Not the Default </H2>
<!--docid::SEC16::-->
<P>

One common problem that occurs in Java and JML specifications
is the possibility of <CODE>null</CODE> dereferences.  For example,
if <CODE>x</CODE> is <CODE>null</CODE> then <CODE>x.f</CODE> and <CODE>x.m()</CODE> both
result in a <CODE>NullPointerException</CODE>.
Such null pointer exceptions cause undefinedness
in expression evaluation, as described above
(see section <A HREF="jmlrefman_2.html#SEC15">2.7 Expression Evaluation and Undefinedness</A>).
</P><P>

<A NAME="IDX346"></A>
<A NAME="IDX347"></A>
To avoid having to constantly specify that declarations (other than
local variables) are non-null, JML makes them implicitly <CODE>non_null</CODE> by default.
That is, unless a 
<UL>

<LI>member field (see section <A HREF="jmlrefman_7.html#SEC59">7.1.2 Field and Variable Declarations</A>),
<LI>formal parameter, (see section <A HREF="jmlrefman_7.html#SEC55">7.1.1.1 Formal Parameters</A>),
<LI>method return type (see section <A HREF="jmlrefman_7.html#SEC54">7.1.1 Method and Constructor Declarations</A>), or
<LI>bound variable (see section <A HREF="jmlrefman_11.html#SEC154">11.4.24.5 Modifiers for Bound Variables</A>)
</UL>
is explicitly annotated with the
modifier <CODE>nullable</CODE>, that declaration is assumed to be <CODE>non_null</CODE>.
<P>

For a field whose type is an array of reference types, such as a field
of type <CODE>Object[]</CODE>, both the field that refers to the array and
the elements of the array are <CODE>non_null</CODE> by default.
If a field whose type is an array of reference types is declared as
<CODE>nullable</CODE>, then both the reference to the array and all of its
elements may potentially be null.  To specify that the field is not
null but the elements may be null, use an invariant to state that the
field cannot contain null, as follows.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>private /*@ spec_public nullable @*/ Object[] a;
//@ public invariant a != null;
</pre></td></tr></table></P><P>

While these defaults differ from Java, research has
found that in most cases a declaration is expected to
be non-null <A HREF="jmlrefman_27.html#BIB13">[Chalin-Rioux05]</A>.
More importantly, since
one of the most common mistakes in JML specifications (and in Java
programs) is forgetting to specify that a declaration
is non-null, making the default be that they cannot hold null
helps eliminate a source of common errors in specifications.
</P><P>

See section <A HREF="jmlrefman_6.html#SEC51">6.2.12 Nullity Modifiers</A>, for more details on the nullity modifiers.
</P><P>

<A NAME="Language Levels"></A>
<HR SIZE="6">
<A NAME="SEC17"></A>
<H2> 2.9 Language Levels </H2>
<!--docid::SEC17::-->
<P>

<A NAME="IDX348"></A>
<A NAME="IDX349"></A>
One of JML's goals is to provide a single language that can be used
with a variety of different tools.  However, JML is also
an evolving language that is used as a research vehicle
by many groups.  The evolution of JML means that some features are not
completely documented or implemented.  Use of JML in research means
that some tools will have features that are not supported by other
tools.  All of this has the potential to threaten portability and to
make JML more difficult to learn and use.
</P><P>

The research groups working on JML are committed to making these
problems as invisible to non-researchers as possible, and for this
reason have defined several <EM>language levels</EM>.  The goal of defining these
language levels is to make it easier to learn and use JML and its
various tools.
</P><P>

We define the following language levels.<A NAME="DOCF6" HREF="jmlrefman_fot.html#FOOT6">(6)</A>
<UL>
<LI>
<A NAME="IDX350"></A>
Level 0 should be supported by all JML tools and constitutes the
heart of JML.  All users should be familiar with these level 0
features.
They are fundamental to all uses of JML, including its use as a design by
contract language, as documentation, and as formal specification for
formal verification efforts.  Thus the level 0 features
should be the ones that tutorial materials concentrate on.  Users
should be able to count on these features
being understood and checked by all tools.
<P>

<LI>
<A NAME="IDX351"></A>
Level 1 should be supported by most JML tools and should be a first
priority for developers after implementing the Level 0 features.
There are three categories of features that level 1 adds to level 0.
The first is the redundancy features of JML, which are useful in
documentation, but not absolutely vital.
The second is features that are sugars for features present in level 0.
The third is various features for which modular static verification
is still problematic, although a runtime assertion checking semantics
has been implemented.  This includes the use of methods and constructor
calls in assertions.
<P>

<LI>
<A NAME="IDX352"></A>
Level 2 contains features
that are more specialized to particular uses of JML, but are
still useful for several different tools.  It also contains some
features that are mainly needed to explain JML's semantics, and have
not been heavily used (so far).  
<P>

<LI>
<A NAME="IDX353"></A>
Level 3 features are even less commonly used and more exotic features.  The
semantics of some of these features are not yet well understood, and
the features are not implemented by many tools.
<P>

<LI>
<A NAME="IDX354"></A>
Level C contains features related to specification and verification of
concurrent Java programs.  Some of these are from ESC/Java
<A HREF="jmlrefman_27.html#BIB69">[Leino-Nelson-Saxe00]</A>, and others are from <A HREF="jmlrefman_27.html#BIB97">[Rodriguez-etal05]</A>.
<P>

<LI>
<A NAME="IDX355"></A>
Level X contains experimental features, which may eventually be moved
to other levels.  Many tools will have other experimental features not
documented here.
<P>

</UL>
<P>

<A NAME="IDX356"></A>
<A NAME="IDX357"></A>
When learning JML, one should focus on
levels 0 features first, as these form the heart of the language
which should be understood by all JML tools.
Features at level 1 are next in importance and should be supported by
most tools that are interested in having a large user base.  Features
at higher levels are less important and may not be present in all
tools.  Users should feel free to ignore them unless they meet some
specific need.
</P><P>

<A NAME="IDX358"></A>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
The language levels also provide guidance for tool designers.  JML
tools should parse all of the syntax in this reference manual that is
not marked as experimental.  This is the most important way to
guarantee portability for users, and the easiest way for tools to get
feedback.   In addition, tools should check at least level 0, and
preferably level 1 features.  Features at levels 2 and 3 are
candidates for the tool to just parse and ignore, if they are not
features of interest for that tool.  Experimental features may ignored
(or added) by any tool.
</P><P>

Many tool developers may want to start off supporting only a subset of
JML defined by level 0 and then move on to higher levels.
</P><P>

It is also suggested that tools give users optional feedback, perhaps
in a verbose mode, as to which features are fully and partially 
supported.  Clearly stating which JML levels are supported in a 
tool release is also very important.
</P><P>

More details are provided in the subsections below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC18">2.9.1 Level 0 Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC19">2.9.2 Level 1 Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC20">2.9.3 Level 2 Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC21">2.9.4 Level 3 Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC22">2.9.5 Level C Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_2.html#SEC23">2.9.6 Level X Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Level 0 Features"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<H3> 2.9.1 Level 0 Features </H3>
<!--docid::SEC18::-->
<P>

<A NAME="IDX362"></A>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>
The features in this level form the core of JML and should be
understood and checked by all JML tools.  Beginning users should pay
the most attention to these features.  These features include all of Java and
the syntax described in the rest of this section. 
</P><P>

Many, but not all, of the JML additions to Java's <VAR>modifier</VAR>s
(see section <A HREF="jmlrefman_6.html#SEC39">6.2 Modifiers</A>) are level 0 features. The following modifiers are
included in level 0.
</P><P>

<UL>
<LI>
The <VAR>modifier</VAR> <CODE>spec_public</CODE> (see section <A HREF="jmlrefman_6.html#SEC41">6.2.2 Spec Public</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>spec_protected</CODE> (see section <A HREF="jmlrefman_6.html#SEC42">6.2.3 Spec Protected</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>instance</CODE> (see section <A HREF="jmlrefman_6.html#SEC46">6.2.7 Instance</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>model</CODE> (see section <A HREF="jmlrefman_6.html#SEC44">6.2.5 Model</A>), as applied to field
declarations (see section <A HREF="jmlrefman_7.html#SEC60">7.1.2.1 JML Modifiers for Fields</A>).
Note that this modifier as applied to other
declarations is not a level 0 feature.
<P>

<LI>
The <VAR>modifier</VAR> <CODE>ghost</CODE> (see section <A HREF="jmlrefman_6.html#SEC45">6.2.6 Ghost</A>), as applied to both
field and variable declarations (see section <A HREF="jmlrefman_7.html#SEC59">7.1.2 Field and Variable Declarations</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>helper</CODE> (see section <A HREF="jmlrefman_6.html#SEC47">6.2.8 Helper</A>).
</UL>
<P>

Type specifications (see section <A HREF="jmlrefman_8.html#SEC63">8. Type Specifications</A>) are a level 0
feature, although not all clauses and features of type
specifications are level 0.  The following type-level clauses are
included in level 0.
</P><P>

<UL>
<LI>
Object invariants, that is an <VAR>invariant</VAR> (see section <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A>)
that is either written in an interface using the
<VAR>modifier</VAR> <CODE>instance</CODE> (see section <A HREF="jmlrefman_6.html#SEC46">6.2.7 Instance</A>) or one that is
written in a class and that does not use the <VAR>modifier</VAR> <CODE>static</CODE>
(see section <A HREF="jmlrefman_8.html#SEC66">8.2.1 Static vs. instance invariants</A>).
<P>

<LI>
The functional form of a <VAR>represents-clause</VAR> (see section <A HREF="jmlrefman_8.html#SEC74">8.4 Represents Clauses</A>).
That is, a represents
clause that uses <VAR>l-arrow-or-eq</VAR> and (not <CODE>\such_that</CODE>).
<P>

<LI>
The <VAR>initially-clause</VAR> (see section <A HREF="jmlrefman_8.html#SEC75">8.5 Initially Clauses</A>).
<P>

<LI>
The <VAR>type-spec</VAR> <CODE>\TYPE</CODE> (optionally, as a type of array
element).
See section <A HREF="jmlrefman_7.html#SEC61">7.1.2.2 Type-Specs</A>, for more details.
</UL>
<P>

Method specifications (see section <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>) are a level 0
feature.
This includes the ability to combine specification cases using
<CODE>also</CODE>
(see section <A HREF="jmlrefman_9.html#SEC96">9.6.5 Semantics of nested behavior specification cases</A>)
and specification inheritance <A HREF="jmlrefman_27.html#BIB22">[Dhara-Leavens96]</A> <A HREF="jmlrefman_27.html#BIB59">[Leavens-Naumann06]</A> <A HREF="jmlrefman_27.html#BIB67">[Leavens06b]</A>.
It also includes the use of <CODE>\not_specified</CODE> for all
specification clauses that are at level 0.
However, not all clauses and features of method
specifications are level 0. The following parts of method
specifications are included in level 0.
Redundancy features of method specifications are only present at
level 1, not at level 0.  The details are described below.
</P><P>

<UL>
<LI>
Lightweight specification cases (see section <A HREF="jmlrefman_9.html#SEC84">9.4 Lightweight Specification Cases</A>),
although not all clauses that are allowed in the syntax are
in level 0.
<P>

<LI>
Heavyweight specification cases (see section <A HREF="jmlrefman_9.html#SEC87">9.5 Heavyweight Specification Cases</A>) 
that do not use the keyword <CODE>code</CODE>.
This includes 
<VAR>behavior-spec-case</VAR> (see section <A HREF="jmlrefman_9.html#SEC88">9.6 Behavior Specification Cases</A>),
<VAR>normal-behavior-spec-case</VAR>
(see section <A HREF="jmlrefman_9.html#SEC97">9.7 Normal Behavior Specification Cases</A>),
and 
<VAR>exceptional-behavior-spec-case</VAR>
(see section <A HREF="jmlrefman_9.html#SEC98">9.8 Exceptional Behavior Specification Cases</A>).
However, note that not all clauses that are allowed in the syntax are
in level 0.
<P>

<LI>
The <VAR>requires-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A>).
The redundant form of this clause
(<CODE>requires_redundantly</CODE>, <CODE>pre_redundantly</CODE>) is a level 1 feature.
<P>

<LI>
The <VAR>ensures-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC105">9.9.3 Ensures Clauses</A>).
The redundant form of this clause
(<CODE>ensures_redundantly</CODE>, <CODE>post_redundantly</CODE>) is a level 1 feature.
<P>

<LI>
The <VAR>signals-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC106">9.9.4 Signals Clauses</A>).
The redundant form of this clause
(<CODE>signals_redundantly</CODE>, <CODE>exsures_redundantly</CODE>) is a level 1 feature.
<P>

<LI>
The <VAR>signals_only-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC107">9.9.5 Signals-Only Clauses</A>).
The redundant form of this clause
(<CODE>signals_only_redundantly</CODE>) is a level 1 feature.
<P>

<LI>
The <VAR>assignable-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC111">9.9.9 Assignable Clauses</A>).
The redundant form of this clause
(<CODE>assignable_redundantly</CODE>, <CODE>modifiable_redundantly</CODE>,
<CODE>modifies_redundantly</CODE>) is a level 1 feature. 
</UL>
<P>

Only static data groups (see section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>) are part of level 0.
</P><P>

<UL>
<LI>
The <VAR>in-group-clause</VAR> (see section <A HREF="jmlrefman_10.html#SEC119">10.1 Static Data Group Inclusions</A>)
kind of <VAR>jml-data-group-clause</VAR>
that attaches to field declarations 
(see section <A HREF="jmlrefman_7.html#SEC59">7.1.2 Field and Variable Declarations</A>).
</UL>
<P>

Some of JML's extensions to Java's <VAR>expression</VAR> syntax
(see section <A HREF="jmlrefman_11.html#SEC121">11. Predicates and Specification Expressions</A>), but not all of them,
can be used at level 0.  Note that
calls to pure methods and constructors in <VAR>spec-expression</VAR>s are
<EM>not</EM> part of level 0, but are only found at level 1.
We describe the level 0 specification
expressions below. 
</P><P>

<UL>
<LI>
The <VAR>result-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC126">11.4.1 <CODE>\result</CODE></A>).
<P>

<LI>
The <VAR>old-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC127">11.4.2 <CODE>\old</CODE> and <CODE>\pre</CODE></A>).
<P>

<LI>
The <VAR>fresh-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC134">11.4.9 <CODE>\fresh</CODE></A>).
<P>

<LI>
The <VAR>nonnullelements-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC139">11.4.14 <CODE>\nonnullelements</CODE></A>).
<P>

<LI>
The <VAR>informal-description</VAR> (see section <A HREF="jmlrefman_11.html#SEC140">11.4.15 Informal Predicates</A>).
<P>

<LI>
The <VAR>typeof-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC141">11.4.16 <CODE>\typeof</CODE></A>).
<P>

<LI>
The <VAR>elemtype-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC142">11.4.17 <CODE>\elemtype</CODE></A>).
<P>

<LI>
The <VAR>type-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC143">11.4.18 <CODE>\type</CODE></A>).
<P>

<LI>
The <VAR>spec-quantified-expr</VAR> (see section <A HREF="jmlrefman_11.html#SEC149">11.4.24 Quantified Expressions</A>) forms
that use the <VAR>quantifier</VAR> keywords
<CODE>\forall</CODE> and <CODE>\exists</CODE>
(see section <A HREF="jmlrefman_11.html#SEC150">11.4.24.1 Universal and Existential Quantifiers</A>). 
<P>

(The <VAR>quantifier</VAR> keywords
<CODE>\max</CODE>, <CODE>\min</CODE>, <CODE>\product</CODE>, and <CODE>\sum</CODE>
(see section <A HREF="jmlrefman_11.html#SEC151">11.4.24.2 Generalized Quantifiers</A>), as well as <CODE>\num_of</CODE>
(see section <A HREF="jmlrefman_11.html#SEC152">11.4.24.3 Numerical Quantifier</A>, are all level 1 features.)
</P><P>

<LI>
The <CODE>&#60;:</CODE> operator (see section <A HREF="jmlrefman_11.html#SEC158">11.6.1 Subtype operator</A>).
<P>

<LI>
The <CODE>&#60;==&#62;</CODE> and <CODE>&#60;=!=&#62;</CODE> operators
(see section <A HREF="jmlrefman_11.html#SEC159">11.6.2 Equivalence and Inequivalence Operators</A>).
<P>

<LI>
The <CODE>==&#62;</CODE> and <CODE>&#60;==</CODE> operators
(see section <A HREF="jmlrefman_11.html#SEC160">11.6.3 Forward and Reverse Implication Operators</A>).
<P>

<LI>
The syntax for <VAR>store-ref</VAR>s (see section <A HREF="jmlrefman_11.html#SEC162">11.7 Store Refs</A>).
</UL>
<P>

All of the Java statements and most of the JML extensions
for adding assertions to statements and annotation statements
(see section <A HREF="jmlrefman_12.html#SEC163">12. Statements and Annotation Statements</A>) are at level 0.  But redundancy
features of the JML extensions are only present at 
level 1, not at level 0. 
We describe the level 0 extension to statements below.
</P><P>

<UL>
<LI>
Using the <VAR>modifier</VAR> <CODE>ghost</CODE> in <VAR>local-declaration</VAR>s
(see section <A HREF="jmlrefman_12.html#SEC165">12.1.1 Modifiers for Local Declarations</A>).
<P>

<LI>
The <VAR>possibly-annotated-loop</VAR> statement (see section <A HREF="jmlrefman_12.html#SEC166">12.2 Loop Statements</A>),
with a <VAR>loop-invariant</VAR> (see section <A HREF="jmlrefman_12.html#SEC167">12.2.1 Loop Invariants</A>).
The redundant forms of <VAR>loop-invariant</VAR>s, namely those
that use the keywords <CODE>maintaining_redundantly</CODE> and
<CODE>loop_invariant_redundantly</CODE> are level 1 features.
Furthermore, the <VAR>variant-function</VAR> is a level 1 feature.
<P>

<LI>
The <VAR>assert-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A>).
Note that the <VAR>assert-redundantly-statement</VAR>,
which uses the keyword <CODE>assert_redundantly</CODE>, is in level 1.
<P>

<LI>
The non-redundant form of the <VAR>assume-statement</VAR>
(see section <A HREF="jmlrefman_12.html#SEC171">12.4.1 Assume Statements</A>).
Use of the keyword <CODE>assume_redundantly</CODE> is a level 1 feature.
<P>

<LI>
The <VAR>set-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC172">12.4.2 Set Statements</A>).
</UL>
<P>

The ability to
use a <CODE>.spec</CODE> file (see section <A HREF="jmlrefman_16.html#SEC194">16.1 File Name Suffixes</A>)
to give a separate specification for a
compilation unit that only appears in binary form (e.g., in a
<CODE>.class</CODE> file) is a level 0 feature.
Use of the <VAR>refine-prefix</VAR> (see section <A HREF="jmlrefman_16.html#SEC193">16. Refinement</A>) is a
level 1 feature.
</P><P>

Some syntax from the Universe type system
(see section <A HREF="jmlrefman_18.html#SEC203">18. Universe Type System</A>) is included in level 0.
However, <CODE>readonly</CODE> is considered to be in level X, as is the semantics
of the Universe type system.  The <CODE>rep</CODE> and <CODE>peer</CODE> modifiers
are included in level 0 because, in some form, they are important to
the semantics of several level 0 features
<A HREF="jmlrefman_27.html#BIB87">[Mueller-Poetzsch-Heffter-Leavens03]</A> <A HREF="jmlrefman_27.html#BIB88">[Mueller-Poetzsch-Heffter-Leavens06]</A>.
</P><P>

<UL>
<LI>
The <CODE>\rep</CODE> and <CODE>rep</CODE> <VAR>ownership-modifier</VAR>s
(see section <A HREF="jmlrefman_18.html#SEC205">18.2 Rep and Peer</A>).
<P>

<LI>
The <CODE>\peer</CODE> and <CODE>peer</CODE> <VAR>ownership-modifier</VAR>s
(see section <A HREF="jmlrefman_18.html#SEC205">18.2 Rep and Peer</A>).
</UL>
<P>

<A NAME="Level 1 Features"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<H3> 2.9.2 Level 1 Features </H3>
<!--docid::SEC19::-->
<P>

<A NAME="IDX365"></A>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
The features in this level will be 
understood and checked by many JML tools.  They are quite important in
practice, especially the use of methods and constructors in writing
the specifications of other methods and constructors. 
Also useful are all of JML's redundancy features
(see section <A HREF="jmlrefman_13.html#SEC177">13. Redundancy</A>), which are included here for level 0 features and
for other features at level 1.
</P><P>

The following additions to Java's <VAR>modifier</VAR>s
(see section <A HREF="jmlrefman_6.html#SEC39">6.2 Modifiers</A>) are level 1 features.
</P><P>

<UL>
<LI>
Method or constructor declarations that use the
<VAR>modifier</VAR> <CODE>model</CODE> (see section <A HREF="jmlrefman_7.html#SEC56">7.1.1.2 Model Methods and Constructors</A>).
However, note that using <CODE>model</CODE> on a field
declarations is a level 0 feature and that using <CODE>model</CODE> on a
type declaration is a level 2 feature.
<P>

<LI>
<VAR>import-definition</VAR>s that use the modifier <CODE>model</CODE>
(see section <A HREF="jmlrefman_5.html#SEC34">5.2 Import Definitions</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>pure</CODE> (see section <A HREF="jmlrefman_6.html#SEC43">6.2.4 Pure</A>).
<P>

<LI>
The <VAR>modifier</VAR> <CODE>uninitialized</CODE> (see section <A HREF="jmlrefman_6.html#SEC49">6.2.10 Uninitialized</A>).
</UL>
<P>

The following type-level clauses
(see section <A HREF="jmlrefman_8.html#SEC63">8. Type Specifications</A>) are included in level 1.
</P><P>

<UL>
<LI>
Attaching a <VAR>method-specification</VAR> to a
<VAR>class-initializer-decl</VAR> (see section <A HREF="jmlrefman_7.html#SEC62">7.2 Class Initializer Declarations</A>).
<P>

<LI>
Static invariants, that is an <VAR>invariant</VAR> (see section <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A>)
that is either written in an interface without using the
<VAR>modifier</VAR> <CODE>instance</CODE> (see section <A HREF="jmlrefman_6.html#SEC46">6.2.7 Instance</A>), or one that is
written in a class and that uses the <VAR>modifier</VAR> <CODE>static</CODE>
(see section <A HREF="jmlrefman_8.html#SEC66">8.2.1 Static vs. instance invariants</A>).
<P>

<LI>
Both object and static <VAR>history-constraint</VAR>s (see section <A HREF="jmlrefman_8.html#SEC70">8.3 Constraints</A>).
<P>

<LI>
The <VAR>axiom-clause</VAR> (see section <A HREF="jmlrefman_8.html#SEC76">8.6 Axioms</A>).
<P>

<LI>
The <VAR>maps-into-clause</VAR> (see section <A HREF="jmlrefman_10.html#SEC120">10.2 Dynamic Data Group Mappings</A>)
kind of <VAR>jml-data-group-clause</VAR>
that attaches to field declarations (see section <A HREF="jmlrefman_7.html#SEC59">7.1.2 Field and Variable Declarations</A>).
</UL>
<P>

The following features of method specifications
(see section <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>) are included in level 1.
</P><P>

<UL>
<LI>
The <VAR>spec-var-decls</VAR> that may occur in a specification case
(see section <A HREF="jmlrefman_9.html#SEC101">9.9.1 Specification Variable Declarations</A>).
<P>

<LI>
The <VAR>redundant-spec</VAR> parts of a method specification
(see section <A HREF="jmlrefman_13.html#SEC177">13. Redundancy</A>) are also included in level 1.
The following describes these parts.
<P>

<UL>
<LI>
The <VAR>implications</VAR> (<CODE>implies_that</CODE>) part of a <VAR>redundant-spec</VAR>
(see section <A HREF="jmlrefman_13.html#SEC178">13.1 Redundant Implications and Redundantly Clauses</A>).
<P>

<LI>
The <VAR>examples</VAR> (<CODE>for_example</CODE>) part of a <VAR>redundant-spec</VAR>.
</UL>
</UL>
<P>

The following extensions to Java's <VAR>expression</VAR> syntax
(see section <A HREF="jmlrefman_11.html#SEC121">11. Predicates and Specification Expressions</A>)
are included in level 1.
</P><P>

<UL>
<LI>
The <VAR>spec-quantified-expr</VAR> (see section <A HREF="jmlrefman_11.html#SEC149">11.4.24 Quantified Expressions</A>) forms
that use the <VAR>quantifier</VAR> keywords
<CODE>\max</CODE>, <CODE>\min</CODE>, <CODE>\product</CODE>, and <CODE>\sum</CODE>
(see section <A HREF="jmlrefman_11.html#SEC151">11.4.24.2 Generalized Quantifiers</A>), as well as <CODE>\num_of</CODE>
(see section <A HREF="jmlrefman_11.html#SEC152">11.4.24.3 Numerical Quantifier</A>).
<P>

(Note that the <CODE>\max</CODE> quantifier is distinct from the
<VAR>max-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC145">11.4.20 <CODE>\max</CODE></A>), which is a level C
feature.
Also, note that the <VAR>quantifier</VAR> keywords <CODE>\forall</CODE> and
<CODE>\exists</CODE> are level 0 features.)
</P><P>

<LI>
Calls to pure methods and constructors 
(see section <A HREF="jmlrefman_7.html#SEC57">7.1.1.3 Pure Methods and Constructors</A>)
in <VAR>spec-expression</VAR>s (see section <A HREF="jmlrefman_11.html#SEC121">11. Predicates and Specification Expressions</A>).
<P>

<LI>
The <VAR>set-comprehension</VAR> expression (see section <A HREF="jmlrefman_11.html#SEC156">11.5 Set Comprehensions</A>).
</UL>
<P>

The following additions to Java's statement syntax 
(see section <A HREF="jmlrefman_12.html#SEC163">12. Statements and Annotation Statements</A>)
are included in level 1.
</P><P>

<UL>
<LI>
The use of redundant forms of <VAR>loop-invariant</VAR>s (see section <A HREF="jmlrefman_12.html#SEC167">12.2.1 Loop Invariants</A>)
namely those that use the keywords <CODE>maintaining_redundantly</CODE> and
<CODE>loop_invariant_redundantly</CODE>.
Non-redundant <VAR>loop-invariant</VAR>s are in level 0.
<P>

<LI>
The <VAR>possibly-annotated-loop</VAR> statement (see section <A HREF="jmlrefman_12.html#SEC166">12.2 Loop Statements</A>),
with a <VAR>variant-function</VAR> (see section <A HREF="jmlrefman_12.html#SEC168">12.2.2 Loop Variant Functions</A>).
<P>

<LI>
The <VAR>assert-redundantly-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A>);
that is, assert statements that use the keyword <CODE>assert_redundantly</CODE>.
The non-redundant <VAR>assert-statement</VAR>s are a level 0 feature.
<P>

<LI>
The redundant form of the <VAR>assume-statement</VAR>
(see section <A HREF="jmlrefman_12.html#SEC171">12.4.1 Assume Statements</A>); that is, assume statements that use
the keyword <CODE>assume_redundantly</CODE>.
The non-redundant <VAR>assume-statement</VAR>s are a level 0 feature.
</UL>
<P>

The <VAR>refine-prefix</VAR> (see section <A HREF="jmlrefman_16.html#SEC193">16. Refinement</A>).  However, the ability to
use a <CODE>.spec</CODE> file to give a separate specification for a
compilation unit that only appears in binary form (e.g., in a
<CODE>.class</CODE> file) is a level 0 feature.
</P><P>

The <CODE>\bigint</CODE> type (see section <A HREF="jmlrefman_19.html#SEC214">19.1 \bigint</A>)
from the safe math extensions (see section <A HREF="jmlrefman_19.html#SEC213">19. Safe Math Extensions</A>) is a level 1
feature.
</P><P>

<A NAME="Level 2 Features"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<H3> 2.9.3 Level 2 Features </H3>
<!--docid::SEC20::-->
<P>

<A NAME="IDX368"></A>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>
Level 2 contains features that are more specialized to particular uses
of JML, but are still useful for several different tools.  It also
contains some features that are mainly needed to explain JML's
semantics, and have not been heavily used (so far).
</P><P>

The <VAR>nowarn-pragma</VAR> (see section <A HREF="jmlrefman_4.html#SEC27">4.2 Lexical Pragmas</A>).
</P><P>

The following type-level clauses
(see section <A HREF="jmlrefman_8.html#SEC63">8. Type Specifications</A>) are included in level 2.
</P><P>

<UL>
<LI>
The relational form of a <VAR>represents-clause</VAR> (see section <A HREF="jmlrefman_8.html#SEC74">8.4 Represents Clauses</A>).
That is, a represents
clause that uses <CODE>\such_that</CODE>.
Note that the functional form of such represents clauses is a level 0
feature.
<P>

<LI>
The <VAR>readable-if-clause</VAR> clause (see section <A HREF="jmlrefman_8.html#SEC77">8.7 Readable If Clauses</A>).
<P>

<LI>
The <VAR>writable-if-clause</VAR> clause (see section <A HREF="jmlrefman_8.html#SEC78">8.8 Writable If Clauses</A>).
</UL>
<P>

The following features of method specifications
(see section <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>) are included in level 2.
</P><P>

<UL>
<LI>
The <VAR>diverges-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC109">9.9.7 Diverges Clauses</A>).
<P>

<LI>
The <VAR>accessible-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC112">9.9.10 Accessible Clauses</A>).
<P>

<LI>
The <VAR>callable-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC113">9.9.11 Callable Clauses</A>).
<P>

<LI>
The <VAR>measured-by-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC114">9.9.12 Measured By Clauses</A>).
<P>

<LI>
The <VAR>captures-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC115">9.9.13 Captures Clauses</A>).
<P>

<LI>
The <VAR>working-space-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC116">9.9.14 Working Space Clauses</A>).
<P>

<LI>
The <VAR>duration-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC117">9.9.15 Duration Clauses</A>).
<P>

<LI>
The <VAR>model-program</VAR> style of method specification
(see section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>).
<P>

<LI>
The <VAR>refining-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC173">12.4.3 Refining Statements</A>).
<P>

<LI>
The <CODE>extract</CODE> modifier (see section <A HREF="jmlrefman_14.html#SEC182">14.2 Extracting Model Program Specifications</A>).
</UL>
<P>

The following extensions to Java's <VAR>expression</VAR> syntax
(see section <A HREF="jmlrefman_11.html#SEC121">11. Predicates and Specification Expressions</A>)
are included in level 2.
</P><P>

<UL>
<LI>
The <VAR>not-assigned-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC128">11.4.3 <CODE>\not_assigned</CODE></A>).
<P>

<LI>
The <VAR>not-modified-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC129">11.4.4 <CODE>\not_modified</CODE></A>).
<P>

<LI>
The <VAR>only-accessed-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC130">11.4.5 <CODE>\only_accessed</CODE></A>).
<P>

<LI>
The <VAR>only-assigned-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC131">11.4.6 <CODE>\only_assigned</CODE></A>).
<P>

<LI>
The <VAR>only-called-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC132">11.4.7 <CODE>\only_called</CODE></A>).
<P>

<LI>
The <VAR>only-captured-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC133">11.4.8 <CODE>\only_captured</CODE></A>).
<P>

<LI>
The <VAR>reach-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC135">11.4.10 <CODE>\reach</CODE></A>).
<P>

<LI>
The <VAR>is-initialized-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC146">11.4.21 <CODE>\is_initialized</CODE></A>).
<P>

<LI>
The <VAR>invariant-for-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC147">11.4.22 <CODE>\invariant_for</CODE></A>).
<P>

<LI>
The <VAR>lblneg-expression</VAR> and the <VAR>lblpos-expression</VAR>
(see section <A HREF="jmlrefman_11.html#SEC148">11.4.23 <CODE>\lblneg</CODE> and <CODE>\lblpos</CODE></A>).
</UL>
<P>

The following additions to Java's statement syntax 
(see section <A HREF="jmlrefman_12.html#SEC163">12. Statements and Annotation Statements</A>)
are included in level 2.
</P><P>

<UL>
<LI>
The <VAR>unreachable-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC174">12.4.4 Unreachable Statements</A>).
<P>

<LI>
The <VAR>debug-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC175">12.4.5 Debug Statements</A>)
<P>

<LI>
The <VAR>hence-by-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC176">12.4.6 Hence By Statements</A>).
</UL>
<P>

Note that all the <VAR>model-prog-statement</VAR>s (see section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>)
are at level 2, because the model program style of method specification
is at this level.
</P><P>

Aside from the <CODE>\bigint</CODE> type (see section <A HREF="jmlrefman_19.html#SEC214">19.1 \bigint</A>),
which is a level 1 feature, the rest of the safe math extensions
(see section <A HREF="jmlrefman_19.html#SEC213">19. Safe Math Extensions</A>) are level 2
features.  This includes the following particulars.
</P><P>

<UL>
<LI>
The <CODE>\real</CODE> type (see section <A HREF="jmlrefman_19.html#SEC215">19.2 \real</A>).
<P>

<LI>
The <VAR>modifier</VAR>s  <CODE>code_bigint_math</CODE>, <CODE>code_java_math</CODE>, 
<CODE>code_safe_math</CODE>, <CODE>spec_bigint_math</CODE>,
<CODE>spec_java_math</CODE>, and <CODE>spec_safe_math</CODE> (see section <A HREF="jmlrefman_6.html#SEC50">6.2.11 Math Modifiers</A>).
</UL>
<P>

<A NAME="Level 3 Features"></A>
<HR SIZE="6">
<A NAME="SEC21"></A>
<H3> 2.9.4 Level 3 Features </H3>
<!--docid::SEC21::-->
<P>

<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>
Level 3 features are more exotic and even less commonly used.  The
semantics of some of these features are not yet well understood, and
the features are not implemented by many tools.
</P><P>

<UL>
<LI>
<VAR>type-definition</VAR>s that use the modifier <CODE>model</CODE>
(see section <A HREF="jmlrefman_6.html#SEC38">6.1.2 Modifiers for Type Definitions</A>).
<P>

<LI>
The <VAR>duration-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC136">11.4.11 <CODE>\duration</CODE></A>).
<P>

<LI>
The <VAR>space-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC137">11.4.12 <CODE>\space</CODE></A>).
<P>

<LI>
The <VAR>working-space-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC138">11.4.13 <CODE>\working_space</CODE></A>).
</UL>
<P>

<A NAME="Level C Features"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<H3> 2.9.5 Level C Features </H3>
<!--docid::SEC22::-->
<P>

<A NAME="IDX374"></A>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>
The features in this level are related to the specification of concurrency.
This includes features inherited from ESC/Java having to do with
concurrency.  The features of this level are as follows.
</P><P>

<UL>
<LI>
The <VAR>monitors-for-clause</VAR> clause (see section <A HREF="jmlrefman_8.html#SEC79">8.9 Monitors For Clause</A>).
<P>

<LI>
The <VAR>when-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC110">9.9.8 When Clauses</A>).
<P>

<LI>
The <VAR>lockset-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC144">11.4.19 <CODE>\lockset</CODE></A>).
<P>

<LI>
The <VAR>max-expression</VAR> (see section <A HREF="jmlrefman_11.html#SEC145">11.4.20 <CODE>\max</CODE></A>).  Note that this is
<EM>not</EM> the quantifier <CODE>\max</CODE>
(see section <A HREF="jmlrefman_11.html#SEC151">11.4.24.2 Generalized Quantifiers</A>), which is a level 1 feature. 
<P>

<LI>
The <CODE>&#60;</CODE> and <CODE>&#60;=</CODE> operators applied to test ordering of locks
(see section <A HREF="jmlrefman_11.html#SEC161">11.6.4 Lockset Ordering</A>).
</UL>
<P>

<A NAME="Level X Features"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<H3> 2.9.6 Level X Features </H3>
<!--docid::SEC23::-->
<P>

<A NAME="IDX377"></A>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>
The features in this level are experimental.
They are as follows.
</P><P>

<UL>
<LI>
The MultiJava extensions to JML (see section <A HREF="jmlrefman_17.html#SEC200">17. MultiJava Extensions to JML</A>),
including the syntax for <VAR>multijava-top-level-declaration</VAR>
(see section <A HREF="jmlrefman_17.html#SEC201">17.1 Augmenting Method Declarations</A>)
and <VAR>multijava-param-declaration</VAR> (see section <A HREF="jmlrefman_17.html#SEC202">17.2 MultiMethods</A>).
<P>

<LI>
The <CODE>\readonly</CODE> and <CODE>readonly</CODE> <VAR>ownership-modifier</VAR>s
from the Universe type system (see section <A HREF="jmlrefman_18.html#SEC203">18. Universe Type System</A>).
Note that the <CODE>\peer</CODE> and <CODE>\rep</CODE> modifiers are level 0 features.
</UL>
<P>

<A NAME="Syntax Notation"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_2.html#SEC16"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_3.html#SEC24"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>May, 20  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
