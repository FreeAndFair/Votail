<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 20  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>JML Reference Manual: Statements and Annotation Statements</TITLE>

<META NAME="description" CONTENT="JML Reference Manual: Statements and Annotation Statements">
<META NAME="keywords" CONTENT="JML Reference Manual: Statements and Annotation Statements">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC163"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_11.html#SEC121"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_13.html#SEC177"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 12. Statements and Annotation Statements </H1>
<!--docid::SEC163::-->
<P>

JML also defines a number of annotation statements that may be interspersed
with Java statements in the body of a method, constructor, or initialization
block.
</P><P>

The following gives the syntax of statements.
These are the standard Java statements, with the addition of annotations,
the <VAR>hence-by-statement</VAR>, <VAR>assert-redundantly-statement</VAR>,
<VAR>assume-statement</VAR>, <VAR>set-statement</VAR>, <VAR>unreachable-statement</VAR>,
<VAR>debug-statement</VAR>,
and the various forms of <VAR>model-prog-statement</VAR>.
See section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>, for the syntax of <VAR>model-prog-statement</VAR>,
which is only allowed in model programs.
[[[ Does this include local class declarations?]]]
</P><P>

<A NAME="IDX2473"></A>
<A NAME="IDX2474"></A>
<A NAME="IDX2475"></A>
<A NAME="IDX2476"></A>
<A NAME="IDX2477"></A>
<A NAME="IDX2478"></A>
<A NAME="IDX2479"></A>
<A NAME="IDX2480"></A>
<A NAME="IDX2481"></A>
<A NAME="IDX2482"></A>
<A NAME="IDX2483"></A>
<A NAME="IDX2484"></A>
<A NAME="IDX2485"></A>
<A NAME="IDX2486"></A>
<A NAME="IDX2487"></A>
<A NAME="IDX2488"></A>
<A NAME="IDX2489"></A>
<A NAME="IDX2490"></A>
<A NAME="IDX2491"></A>
<A NAME="IDX2492"></A>
<A NAME="IDX2493"></A>
<A NAME="IDX2494"></A>
<A NAME="IDX2495"></A>
<A NAME="IDX2496"></A>
<A NAME="IDX2497"></A>
<A NAME="IDX2498"></A>
<A NAME="IDX2499"></A>
<A NAME="IDX2500"></A>
<A NAME="IDX2501"></A>
<A NAME="IDX2502"></A>
<A NAME="IDX2503"></A>
<A NAME="IDX2504"></A>
<A NAME="IDX2505"></A>
<A NAME="IDX2506"></A>
<A NAME="IDX2507"></A>
<A NAME="IDX2508"></A>
<A NAME="IDX2509"></A>
<A NAME="IDX2510"></A>
<A NAME="IDX2511"></A>
<A NAME="IDX2512"></A>
<A NAME="IDX2513"></A>
<A NAME="IDX2514"></A>
<A NAME="IDX2515"></A>
<A NAME="IDX2516"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>compound-statement</VAR> ::= <CODE>{</CODE> <VAR>statement</VAR> [ <VAR>statement</VAR> ] <small>...</small> <CODE>}</CODE>
<VAR>statement</VAR> ::= <VAR>compound-statement</VAR>
        | <VAR>local-declaration</VAR> <CODE>;</CODE>
        | <VAR>ident</VAR> <CODE>:</CODE> <VAR>statement</VAR>
        | <VAR>expression</VAR> <CODE>;</CODE>
        | <CODE>if</CODE> <CODE>(</CODE> <VAR>expression</VAR> <CODE>)</CODE>
          <VAR>statement</VAR> [ <CODE>else</CODE> <VAR>statement</VAR> ]
        | <VAR>possibly-annotated-loop</VAR>
        | <CODE>break</CODE> [ <VAR>ident</VAR> ] <CODE>;</CODE>
        | <CODE>continue</CODE> [ <VAR>ident</VAR> ] <CODE>;</CODE>
        | <CODE>return</CODE> [ <VAR>expression</VAR> ] <CODE>;</CODE>
        | <VAR>switch-statement</VAR>
        | <VAR>try-block</VAR> 
        | <CODE>throw</CODE> <VAR>expression</VAR> <CODE>;</CODE>
        | <CODE>synchronized</CODE> <CODE>(</CODE> <VAR>expression</VAR> <CODE>)</CODE> <VAR>statement</VAR>
        | <CODE>;</CODE>
        | <VAR>jml-annotation-statement</VAR>
        | <VAR>assert-statement</VAR>
        | <VAR>jml-annotation-statement</VAR>
        | <VAR>model-prog-statement</VAR> <I>// only allowed in model programs</I>
<VAR>switch-statement</VAR> ::= <CODE>switch</CODE> <CODE>(</CODE> <VAR>expression</VAR> <CODE>)</CODE> <CODE>{</CODE>
                     [ <VAR>switch-body</VAR> ] <small>...</small> <CODE>}</CODE>
<VAR>switch-body</VAR> ::= <VAR>switch-label-seq</VAR> [ <VAR>statement</VAR> ] <small>...</small>
<VAR>switch-label-seq</VAR> ::= <VAR>switch-label</VAR> [ <VAR>switch-label</VAR> ] <small>...</small>
<VAR>switch-label</VAR> ::= <CODE>case</CODE> <VAR>expression</VAR> <CODE>:</CODE> | <CODE>default</CODE> <CODE>:</CODE>
<VAR>try-block</VAR> ::= <CODE>try</CODE> <VAR>compound-statement</VAR>
              [ <VAR>handler</VAR> ] <small>...</small>
              [ <CODE>finally</CODE> <VAR>compound-statement</VAR> ]
<VAR>handler</VAR> ::= <CODE>catch</CODE> <CODE>(</CODE> <VAR>param-declaration</VAR> <CODE>)</CODE> <VAR>compound-statement</VAR>
</pre></td></tr></table></P><P>

The semantics of the Java statements are as in Java 
<A HREF="jmlrefman_27.html#BIB2">[Arnold-Gosling-Holmes00]</A> <A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>.
More details on the JML-specific features related to statements are
described below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC164">12.1 Local Declaration Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC166">12.2 Loop Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC170">12.4 JML Annotation Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Local Declaration Statements"></A>
<HR SIZE="6">
<A NAME="SEC164"></A>
<H2> 12.1 Local Declaration Statements </H2>
<!--docid::SEC164::-->
<P>

The following is the syntax of local declaration statements.
See section <A HREF="jmlrefman_7.html#SEC59">7.1.2 Field and Variable Declarations</A>, for the syntax of <VAR>variable-decls</VAR>.
</P><P>

<A NAME="IDX2517"></A>
<A NAME="IDX2518"></A>
<A NAME="IDX2519"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>local-declaration</VAR> ::= <VAR>local-modifiers</VAR> <VAR>variable-decls</VAR>
</pre></td></tr></table></P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC165">12.1.1 Modifiers for Local Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Modifiers for Local Declarations"></A>
<HR SIZE="6">
<A NAME="SEC165"></A>
<H3> 12.1.1 Modifiers for Local Declarations </H3>
<!--docid::SEC165::-->
<P>

JML allows the modifiers <CODE>ghost</CODE>, <CODE>uninitialized</CODE>, <CODE>non_null</CODE> and <CODE>nullable</CODE>
in addition 
to Java's <CODE>final</CODE> modifier on local variable declarations.
See section <A HREF="jmlrefman_18.html#SEC203">18. Universe Type System</A>, for the grammar of <VAR>ownership-modifier</VAR>.
</P><P>

<A NAME="IDX2520"></A>
<A NAME="IDX2521"></A>
<A NAME="IDX2522"></A>
<A NAME="IDX2523"></A>
<A NAME="IDX2524"></A>
<A NAME="IDX2525"></A>
<A NAME="IDX2526"></A>
<A NAME="IDX2527"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>local-modifiers</VAR> ::= [ <VAR>local-modifier</VAR> ] <small>...</small>
<VAR>local-modifier</VAR> ::= <CODE>ghost</CODE> | <CODE>final</CODE>  <CODE>uninitialized</CODE> | <CODE>non_null</CODE> | <CODE>nullable</CODE>
         | <VAR>ownership-modifier</VAR>  <I>// when the Universe type system is on</I>
</pre></td></tr></table></P><P>

The JML modifiers are discussed to some extent below.
See section <A HREF="jmlrefman_7.html#SEC60">7.1.2.1 JML Modifiers for Fields</A>, for more about these modifiers.
</P><P>

When used as a local variable modifier, <CODE>uninitialized</CODE> means that
the variable should be considered by the tools to be uninitialized, even
if it has an initialization.  This allows the tools to check for uses
before a "real" initialization.
</P><P>

A <EM>local ghost declaration</EM> is a variable declaration with a <CODE>ghost</CODE>
modifier, entirely contained in an annotation.  It introduces a new variable
that may be used in subsequent annotations within the remainder of the 
block in which the declaration appears.  A ghost variable is not used in
program execution as Java variables are, but is used by 
runtime assertion checkers or a static checker to
reason about the execution of the routine body in which the ghost variable
is used.
<UL>
<LI>
The variable name may not be already declared as a local variable or
local ghost variable or
as a formal parameter of the routine in which the declaration appears.
<LI>
Each variable declared may have an initializer; the initializer is in
the scope of the newly declared variable.
<LI>
The modifiers <CODE>final</CODE>, <CODE>uninitialized</CODE>, <CODE>non_null</CODE> and
<CODE>nullable</CODE> may be used on the ghost declaration.
</UL>
<P>

In the following, the body of the method <CODE>ghostLocalExample</CODE>
contains several examples of local ghost declarations.
<A NAME="IDX2528"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class GhostLocals {
    void ghostLocalExample() {
        //@ ghost int i = 0;
        //@ ghost int zero = 0, j, k = i+3;
        //@ ghost float[] a = {1, 2, 3};
        //@ ghost Object o;
        //@ final ghost non_null Object nno = new Object();
    }
}

</pre></td></tr></table></P><P>

<A NAME="Loop Statements"></A>
<HR SIZE="6">
<A NAME="SEC166"></A>
<H2> 12.2 Loop Statements </H2>
<!--docid::SEC166::-->
<P>

The following is the syntax of loop statements.
</P><P>

<A NAME="IDX2529"></A>
<A NAME="IDX2530"></A>
<A NAME="IDX2531"></A>
<A NAME="IDX2532"></A>
<A NAME="IDX2533"></A>
<A NAME="IDX2534"></A>
<A NAME="IDX2535"></A>
<A NAME="IDX2536"></A>
<A NAME="IDX2537"></A>
<A NAME="IDX2538"></A>
<A NAME="IDX2539"></A>
<A NAME="IDX2540"></A>
<A NAME="IDX2541"></A>
<A NAME="IDX2542"></A>
<A NAME="IDX2543"></A>
<A NAME="IDX2544"></A>
<A NAME="IDX2545"></A>
<A NAME="IDX2546"></A>
<A NAME="IDX2547"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>possibly-annotated-loop</VAR> ::=
          [ <VAR>loop-invariant</VAR> ] <small>...</small>
          [ <VAR>variant-function</VAR> ] <small>...</small>
          [ <VAR>ident</VAR> <CODE>:</CODE> ] <VAR>loop-stmt</VAR>
<VAR>loop-stmt</VAR> ::= <CODE>while</CODE> <CODE>(</CODE> <VAR>expression</VAR> <CODE>)</CODE> <VAR>statement</VAR>
        | <CODE>do</CODE> <VAR>statement</VAR> <CODE>while</CODE> <CODE>(</CODE> <VAR>expression</VAR> <CODE>)</CODE> <CODE>;</CODE>
        | <CODE>for</CODE> <CODE>(</CODE> [ <VAR>for-init</VAR> ] <CODE>;</CODE> [ <VAR>expression</VAR> ] <CODE>;</CODE> [ <VAR>expression-list</VAR> ] <CODE>)</CODE>
             <VAR>statement</VAR>
<VAR>for-init</VAR> ::= <VAR>local-declaration</VAR> | <VAR>expression-list</VAR>
</pre></td></tr></table></P><P>

In JML a loop statement can be annotated with one or more loop
invariants, and one or more variant functions.  The following class
contains an example in the middle of the method <CODE>sumArray</CODE>.
This example has a <CODE>while</CODE> loop with two loop invariants, which
follow the keyword <CODE>maintaining</CODE>, and a single variant function,
which follows the keyword <CODE>decreasing</CODE>.  The invariants and
variant function are written above the loop itself.
The first loop invariant describes the range that the variable
<CODE>i</CODE> can take, and the second relates <CODE>i</CODE> and the value in
<CODE>sum</CODE>. 
</P><P>

<A NAME="IDX2548"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

/** An example of some simple loops with loop invariants
 *  and variant functions specified.
 */
public abstract class SumArrayLoop {

    /** Return the sum of the argument array. */
    /*@   old \bigint sum = 
      @		(\sum int j; 0 &#60;= j &#38;&#38; j &#60; a.length; (\bigint)a[j]);
      @   requires Long.MIN_VALUE &#60;= sum &#38;&#38; sum &#60;= Long.MAX_VALUE;
      @   assignable \nothing;
      @   ensures \result == sum;
      @*/
    public static long sumArray(int [] a) {
        long sum = 0;
        int i = a.length;

        /*@ maintaining -1 &#60;= i &#38;&#38; i &#60;= a.length;
          @ maintaining sum
          @            == (\sum int j; 
          @                   i &#60;= j &#38;&#38; 0 &#60;= j &#38;&#38; j &#60; a.length; 
          @                   (\bigint)a[j]);
          @ decreasing i; @*/
        while (--i &#62;= 0) {
            sum += a[i];
        }

        //@ assert i &#60; 0 &#38;&#38; -1 &#60;= i &#38;&#38; i &#60;= a.length;
        //@ hence_by (i &#60; 0 &#38;&#38; -1 &#60;= i) ==&#62; i == -1;
        //@ assert i == -1 &#38;&#38; i &#60;= a.length;
        //@ assert sum == (\sum int j; 0 &#60;= j &#38;&#38; j &#60; a.length; (\bigint)a[j]);
        return sum;
    }

}
</pre></td></tr></table></P><P>

At the end of the loop, the negation of the loop's test expression and
the loop invariants hold.  This is shown by the assertions after the loop.
</P><P>

Loop invariants and variant functions are discussed in more detail below.
(Thanks to K. Rustan M. Leino, Claude Marche, and Steve M. Shaner
for discussions on this topic, including details of the semantics.)
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC167">12.2.1 Loop Invariants</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC168">12.2.2 Loop Variant Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Loop Invariants"></A>
<HR SIZE="6">
<A NAME="SEC167"></A>
<H3> 12.2.1 Loop Invariants </H3>
<!--docid::SEC167::-->
<P>

A loop can specify one or more loop invariants, using the following syntax.
</P><P>

<A NAME="IDX2549"></A>
<A NAME="IDX2550"></A>
<A NAME="IDX2551"></A>
<A NAME="IDX2552"></A>
<A NAME="IDX2553"></A>
<A NAME="IDX2554"></A>
<A NAME="IDX2555"></A>
<A NAME="IDX2556"></A>
<A NAME="IDX2557"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>loop-invariant</VAR> ::= <VAR>maintaining-keyword</VAR> <VAR>predicate</VAR> <CODE>;</CODE>
<VAR>maintaining-keyword</VAR> ::= <CODE>maintaining</CODE> | <CODE>maintaining_redundantly</CODE>
        | <CODE>loop_invariant</CODE> | <CODE>loop_invariant_redundantly</CODE>
</pre></td></tr></table></P><P>

A <VAR>loop-invariant</VAR> is used to help prove partial correctness of a
loop statement. 
</P><P>

The meaning of a loop, which does not contain a use of <CODE>break</CODE> that
exits the loop itself (as opposed to some inner loop), such as
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">  //@ maintaining <I>J</I>;
  while (<I>B</I>) { <I>S</I> }
</pre></td></tr></table>is as follows.
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">  while (true) {
    //@ assert <I>J</I>;
    if (!(<I>B</I>)) { break; }
    <I>S</I>
  }
</pre></td></tr></table>So that the loop invariant holds at the beginning of each iteration of
the loop.
</P><P>

The rule for deducing what is true after the loop can be stated simply
if the loop does not contain any <CODE>break</CODE> statements that exit the loop,
and if the loop test, <CODE><I>B</I></CODE>, is both a Java <VAR>expression</VAR> and a JML
<VAR>specification-expression</VAR>
(see section <A HREF="jmlrefman_11.html#SEC123">11.2 Specification Expressions</A>).  (This means that <CODE><I>B</I></CODE> is
side-effect free.)
For such loops, the rule is that, after a loop with condition
<CODE><I>B</I></CODE> and invariant <CODE><I>J</I></CODE> 
the negation of the condition, <CODE>(!<I>B</I>)</CODE>, conjoined with the invariant,
<CODE><I>J</I></CODE>, holds.
This is summarized in the following program schema.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">   //@ maintaining <I>J</I>;
   while (<I>B</I>) {  // <I>assuming B has no side effects</I>
     <I>S</I>
   }
   // assert !(<I>B</I>) &#38;&#38; <I>J</I>;
</pre></td></tr></table></P><P>

<A NAME="IDX2558"></A>
<A NAME="IDX2559"></A>
If the loop contains a <CODE>break</CODE> statement that exits the loop
itself, then more detailed reasoning is necessary to establish what
will be true after the loop.  The intended condition that should be
true after the loop when it is exited via a <CODE>break</CODE> statement can
be recorded in the code using an <CODE>assert</CODE> statement.
For example, if the loop has the form:
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"> //@ maintaining <I>J</I>;
 while (true) {
   <I>S1</I>
   if (<I>C</I>) {
      <I>S2</I>
      //@ assert <I>Q</I>;
      break;
   }
   <I>S3</I>
 }
</pre></td></tr></table>then after the loop the asserted condition, <CODE><I>Q</I></CODE>, should hold,
assuming there are no other <CODE>break</CODE> statements that exit the loop.
</P><P>

<A NAME="Loop Variant Functions"></A>
<HR SIZE="6">
<A NAME="SEC168"></A>
<H3> 12.2.2 Loop Variant Functions </H3>
<!--docid::SEC168::-->
<P>

A loop can also specify one or more variant functions, using the
following syntax.
</P><P>

<A NAME="IDX2560"></A>
<A NAME="IDX2561"></A>
<A NAME="IDX2562"></A>
<A NAME="IDX2563"></A>
<A NAME="IDX2564"></A>
<A NAME="IDX2565"></A>
<A NAME="IDX2566"></A>
<A NAME="IDX2567"></A>
<A NAME="IDX2568"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>variant-function</VAR> ::= <VAR>decreasing-keyword</VAR> <VAR>spec-expression</VAR> <CODE>;</CODE>
<VAR>decreasing-keyword</VAR> ::= <CODE>decreasing</CODE> | <CODE>decreasing_redundantly</CODE>
        | <CODE>decreases</CODE> | <CODE>decreases_redundantly</CODE>
</pre></td></tr></table></P><P>

A <VAR>variant-function</VAR> is used to help prove termination of a loop statement.
It specifies an expression of type <CODE>long</CODE> or <CODE>int</CODE> that must
be no less than 0 when the loop is executing, and must decrease by at
least one (1) each time around the loop.
</P><P>

The meaning of a loop such as
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"> //@ decreasing <I>E</I>;
 while (<I>B</I>) { <I>S</I> }
</pre></td></tr></table>in which <I>S</I> does not use <CODE>continue</CODE>, is as follows.
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">  while (true) {
    long vf = <I>E</I>;      // assuming vf is a fresh variable name
    if (!(<I>B</I>)) { break; }
    <I>S</I>
    //@ assert 0 &#60;= vf;
    //@ assert <I>E</I> &#60; vf;
  }
</pre></td></tr></table></P><P>

<A NAME="IDX2569"></A>
If the loop contains a <CODE>continue</CODE> statement,
then the loop variant is checked just before each use of
<CODE>continue</CODE>.
For example, if the loop has the form:
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"> //@ decreasing <I>E</I>;
 while (<I>B</I>) { <I>S1</I> if (<I>C</I>) { <I>S2</I> continue; } <I>S3</I> }
</pre></td></tr></table>then the meaning is as follows.
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">  while (true) {
    long vf = <I>E</I>;      // assuming vf is a fresh variable name
    if (!(<I>B</I>)) { break; }
    <I>S1</I>
    if (<I>C</I>) {
       <I>S2</I>
       //@ assert 0 &#60;= vf;
       //@ assert <I>E</I> &#60; vf;
       continue;
    }
    <I>S3</I>
    //@ assert 0 &#60;= vf;
    //@ assert <I>E</I> &#60; vf;
  }
</pre></td></tr></table></P><P>

<A NAME="Assert Statements"></A>
<HR SIZE="6">
<A NAME="SEC169"></A>
<H2> 12.3 Assert Statements </H2>
<!--docid::SEC169::-->
<P>

The syntax of assert and redundant assert statements is as follows.
</P><P>

<A NAME="IDX2570"></A>
<A NAME="IDX2571"></A>
<A NAME="IDX2572"></A>
<A NAME="IDX2573"></A>
<A NAME="IDX2574"></A>
<A NAME="IDX2575"></A>
<A NAME="IDX2576"></A>
<A NAME="IDX2577"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>assert-statement</VAR> ::= <CODE>assert</CODE> <VAR>expression</VAR> [ <CODE>:</CODE> <VAR>expression</VAR> ] <CODE>;</CODE>
        | <CODE>assert</CODE> <VAR>predicate</VAR> [ <CODE>:</CODE> <VAR>expression</VAR> ] <CODE>;</CODE>
<VAR>assert-redundantly-statement</VAR> ::= <CODE>assert_redundantly</CODE> <VAR>predicate</VAR>
                                 [ <CODE>:</CODE> <VAR>expression</VAR> ] <CODE>;</CODE>
</pre></td></tr></table></P><P>

<A NAME="IDX2578"></A>
<A NAME="IDX2579"></A>
Note that Java (as of J2SDK 1.4) also has its own <CODE>assert</CODE>
statement.  For this reason JML distinguishes between assert
statements that occur inside and outside annotations.
</P><P>

Outside an annotation, an assert statement is a Java
assert statement, whose syntax follows the first
<VAR>assert-statement</VAR> production above.
Thus in such an assert statement, the first <VAR>expression</VAR> can have side
effects (potentially, although it shouldn't).  The second expression
is supposed to have type <CODE>String</CODE>, and will be used in a message
should the assertion fail.
</P><P>

Inside an annotation, an assert statement is a JML assert statement,
and the second syntax is used for <VAR>assert-statement</VAR>.  Thus instead of an <VAR>expression</VAR>
before the optional colon, there is a JML <VAR>predicate</VAR>.
This predicate cannot have side effects, but can use the various JML
extensions to the Java expression syntax
(see section <A HREF="jmlrefman_11.html#SEC123">11.2 Specification Expressions</A>, for details.)
As in a Java assert statement, the optional expression that follows
the colon must be a <CODE>String</CODE>, which is printed if the assertion
fails.
</P><P>

An assert statements tells JML to check that the specified
<VAR>predicate</VAR> is true at the given point in the program.  The
runtime assertion checker checks such assertions during execution of
the program, when control reaches the assert statement.  Other tools,
such as verification tools, will try to prove that the assertion
always holds at that program point, for every possible execution.
</P><P>

The <VAR>assert-redundantly-statement</VAR> must appear in an annotation.
It has the same semantics as the JML form of an assert statement, but
is marked as redundant.  Thus it would be used to call attention to
some property, but need not be checked.
</P><P>

<A NAME="JML Annotation Statements"></A>
<HR SIZE="6">
<A NAME="SEC170"></A>
<H2> 12.4 JML Annotation Statements </H2>
<!--docid::SEC170::-->
<P>

The following gives the syntax of JML annotation statements.  These
can appear anywhere in normal Java code, but must be enclosed in
annotations.
See section <A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A>, for the syntax of the
<VAR>assert-redundantly-statement</VAR>.
See section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>, for the syntax of additional statements
that can only be used in model programs.
</P><P>

<A NAME="IDX2580"></A>
<A NAME="IDX2581"></A>
<A NAME="IDX2582"></A>
<A NAME="IDX2583"></A>
<A NAME="IDX2584"></A>
<A NAME="IDX2585"></A>
<A NAME="IDX2586"></A>
<A NAME="IDX2587"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>jml-annotation-statement</VAR> ::= <VAR>assert-redundantly-statement</VAR>
        | <VAR>assume-statement</VAR>
        | <VAR>hence-by-statement</VAR>
        | <VAR>set-statement</VAR>
        | <VAR>refining-statement</VAR>
        | <VAR>unreachable-statement</VAR>
        | <VAR>debug-statement</VAR>
</pre></td></tr></table></P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC171">12.4.1 Assume Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC172">12.4.2 Set Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC173">12.4.3 Refining Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC174">12.4.4 Unreachable Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC175">12.4.5 Debug Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_12.html#SEC176">12.4.6 Hence By Statements</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Assume Statements"></A>
<HR SIZE="6">
<A NAME="SEC171"></A>
<H3> 12.4.1 Assume Statements </H3>
<!--docid::SEC171::-->
<P>

The syntax of an assume statement is as follows.
As in a Java assert statement, the optional expression that follows
the colon must be a <CODE>String</CODE>, which is printed if the assumption fails.
</P><P>

<A NAME="IDX2588"></A>
<A NAME="IDX2589"></A>
<A NAME="IDX2590"></A>
<A NAME="IDX2591"></A>
<A NAME="IDX2592"></A>
<A NAME="IDX2593"></A>
<A NAME="IDX2594"></A>
<A NAME="IDX2595"></A>
<A NAME="IDX2596"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>assume-statement</VAR> ::= <VAR>assume-keyword</VAR> <VAR>predicate</VAR>
                     [ <CODE>:</CODE> <VAR>expression</VAR> ] <CODE>;</CODE>
<VAR>assume-keyword</VAR> ::= <CODE>assume</CODE> | <CODE>assume_redundantly</CODE>
</pre></td></tr></table></P><P>

In runtime assertion checking, assumptions are checked in the same way
that assert statements are checked (see section <A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A>).
</P><P>

However, in static analysis tools, the assume statement is used to
tell the tool that the given predicate is assumed to be true, and thus
need not be checked.  
</P><P>

<A NAME="Set Statements"></A>
<HR SIZE="6">
<A NAME="SEC172"></A>
<H3> 12.4.2 Set Statements </H3>
<!--docid::SEC172::-->
<P>

The syntax of a set statement is as follows.
See section <A HREF="jmlrefman_11.html#SEC124">11.3 Expressions</A>, for the syntax of <VAR>assignment-expr</VAR>.
</P><P>

<A NAME="IDX2597"></A>
<A NAME="IDX2598"></A>
<A NAME="IDX2599"></A>
<A NAME="IDX2600"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>set-statement</VAR> ::= <CODE>set</CODE> <VAR>assignment-expr</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

A set statement is the equivalent of an assignment statement but is within
an annotation.  It is used to assign a value to a ghost variable or to a
ghost field.  A set statement serves to assist the static checker in 
reasoning about the execution of the routine body in which it appears.
<UL>
<LI>the target of the set statement must be a ghost variable or a ghost field
<LI>the right-hand-side of the set statement must be pure (not have side effects)
</UL>
<BR><STRONG>Examples:</STRONG>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        //@ set i = 0;
        //@ set collection.elementType = \type(int);
</pre></td></tr></table><P>

[[[ Questions: must the rhs be pure?  Should we allow an arbitrary statement, not just an assignment? such as set ++i; or set i += 5; ]]]
</P><P>

<A NAME="Refining Statements"></A>
<HR SIZE="6">
<A NAME="SEC173"></A>
<H3> 12.4.3 Refining Statements </H3>
<!--docid::SEC173::-->
<P>

<A NAME="IDX2601"></A>
<A NAME="IDX2602"></A>
The syntax of a refining statement is as follows.
See section <A HREF="jmlrefman_14.html#SEC186">14.6 Specification Statements</A>,
for the syntax of <VAR>spec-statement</VAR> and <VAR>generic-spec-statement-case</VAR>.
See section <A HREF="jmlrefman_12.html#SEC163">12. Statements and Annotation Statements</A>, 
for the syntax of <VAR>statement</VAR>.
</P><P>

<A NAME="IDX2603"></A>
<A NAME="IDX2604"></A>
<A NAME="IDX2605"></A>
<A NAME="IDX2606"></A>
<A NAME="IDX2607"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>refining-statement</VAR> ::= <CODE>refining</CODE> <VAR>spec-statement</VAR> <VAR>statement</VAR>
        | <CODE>refining</CODE> <VAR>generic-spec-statement-case</VAR> <VAR>statement</VAR>
</pre></td></tr></table></P><P>

<A NAME="IDX2608"></A>
<A NAME="IDX2609"></A>
A refining statement allows one to annotate a specification with
a specification.  It has two parts, a <EM>specification</EM> and a <EM>body</EM>.
The specification part can be either a
<VAR>spec-statement</VAR> (see section <A HREF="jmlrefman_14.html#SEC186">14.6 Specification Statements</A>), 
which includes the grammar for a heavyweight specification case, 
or a <VAR>generic-spec-statement-case</VAR> (see section <A HREF="jmlrefman_14.html#SEC186">14.6 Specification Statements</A>),
which includes the grammar for a lightweight specification case.
The body is simply a statement.  In particular, the body can be a
<VAR>compound-statement</VAR> or a <VAR>jml-annotation-statement</VAR>,
including a nested <VAR>refining-statement</VAR>.
</P><P>

Annotating the body with a specification is a way of collecting all
the specification information about the statement in one place.
Giving such an annotation is especially useful for framing, 
e.g., writing <VAR>assignable-clause</VAR>s.
For example, by using a refining statement, one can
write an assignable clause for a loop statement 
or for the statement in the body of a loop.
</P><P>

Refining statements are also used in connection with model program
specification cases (see section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>).
Within the implementation of a method with such a model program
specification, a refining statement indicates exactly what
<VAR>spec-statement</VAR> is implemented by its body,
since its specification part would be exactly that <VAR>spec-statement</VAR>.
This is helpful for "matching" the implementation against the model
program specification <A HREF="jmlrefman_27.html#BIB102">[Shaner-Leavens-Naumann07]</A>.
</P><P>

Note that the scope of any declarations made 
in the specification part of a refining statement are limited to the
specification part, and do not extend into the body.
Thus a refining statement is type correct if each of its subparts is
type correct, using the surrounding context 
for separately type checking the specification and body.
</P><P>

The meaning of a refining statement of the form 
<CODE>refining</CODE> <I>S</I> <I>B</I>
is that the body <I>B</I> must refine the specification given in <I>S</I>.
This means that <I>B</I> has to obey all the specifications given in <I>S</I>.
For example, <I>B</I> may not assume a stronger precondition than that
given by <I>S</I>.
(Standard defaults are used for omitted clauses in the specification
part of a refining statement; thus, if there is no requires clause in
a <VAR>spec-statement</VAR>, then the precondition defaults to true.)
Similarly, <I>B</I> may not assign to locations that are not permitted to
be assigned to by <I>S</I>, and, assuming <I>S</I>'s precondition held, then
when <I>B</I> terminates normally it must establish <I>S</I>'s normal
postcondition.
See section <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>, for more about what it means to satisfy
such a specification.
</P><P>

When <CODE>\old()</CODE> or <CODE>\pre()</CODE> are used in the specification part
of a refining statement, they have the same meaning as in a
specification statement (see section <A HREF="jmlrefman_14.html#SEC186">14.6 Specification Statements</A>).
</P><P>

In execution, a refining statement of the form 
<CODE>refining</CODE> <I>S</I> <I>B</I> just executes its body <I>B</I>.
For this reason, typically the 
<CODE>refining</CODE> keyword and the specification <I>S</I>
would be in JML annotations, 
but the body <I>B</I> would be normal Java code (outside of any annotation).
</P><P>

See section <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>, for more examples.
</P><P>

<A NAME="Unreachable Statements"></A>
<HR SIZE="6">
<A NAME="SEC174"></A>
<H3> 12.4.4 Unreachable Statements </H3>
<!--docid::SEC174::-->
<P>

The syntax of the <CODE>unreachable</CODE> statement is as follows.
</P><P>

<A NAME="IDX2610"></A>
<A NAME="IDX2611"></A>
<A NAME="IDX2612"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>unreachable-statement</VAR> ::= <CODE>unreachable</CODE> <CODE>;</CODE>
</pre></td></tr></table></P><P>

The <CODE>unreachable</CODE> statement is an annotation that asserts that the
control flow of a routine will never reach that point in the program.  It is
equivalent to the annotation <CODE>assert false</CODE>.  If control flow does reach an
<CODE>unreachable</CODE> statement, a tool that checks (by reasoning or at runtime)
the behavior of the routine should issue an error of some kind.
The following is an example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        if (true) {
                ...
        } else {
                //@ unreachable;
        }
</pre></td></tr></table></P><P>

<A NAME="Debug Statements"></A>
<HR SIZE="6">
<A NAME="SEC175"></A>
<H3> 12.4.5 Debug Statements </H3>
<!--docid::SEC175::-->
<P>

The syntax of the <CODE>debug</CODE> statement is as follows.
See section <A HREF="jmlrefman_11.html#SEC124">11.3 Expressions</A>, for the syntax of <VAR>expression</VAR>.
</P><P>

<A NAME="IDX2613"></A>
<A NAME="IDX2614"></A>
<A NAME="IDX2615"></A>
<A NAME="IDX2616"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>debug-statement</VAR> ::= <CODE>debug</CODE> <VAR>expression</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

A <CODE>debug</CODE> statement is the equivalent of an expression statement
but is within an annotation. Thus, features visible only in the JML
scope can also appear in the <CODE>debug</CODE> statement. Examples of such
features include ghost variables, model methods, <CODE>spec_public</CODE>
fields, and JML-specific expression constructs, to name a few.
</P><P>

The main use of the <CODE>debug</CODE> statement is to help debugging
specifications, e.g., by printing the value of a JML expression, as
shown below.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        //@ debug System.err.println(x);
</pre></td></tr></table></P><P>

In the above example, the variable <CODE>x</CODE> may be a ghost variable.
Note that using <CODE>System.err</CODE> automatically flushes output, unlike
<CODE>System.out</CODE>.  This flushing of output is helpful for debugging.
</P><P>

As shown in the above example, expressions with side-effects are
allowed in the <CODE>debug</CODE> statement. These include not only methods
with side-effects but also increment (<CODE>++</CODE>) and decrement
(<CODE>--</CODE>) operators and various forms of assignment expressions
(e.g., <CODE>=</CODE>, <CODE>+=</CODE>, etc.). Thus, the <CODE>debug</CODE> statement
can also be used to assign a value to a variable, or mutate the state
of an object.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        //@ debug x = x + 1;
        //@ debug aList.add(y);
</pre></td></tr></table></P><P>

However, a model variable cannot be assigned to, nor can its state be
mutated by using the <CODE>debug</CODE> statement, as its value is given by
a <CODE>represents</CODE> clause (see section <A HREF="jmlrefman_8.html#SEC74">8.4 Represents Clauses</A>).
</P><P>

There is no restriction on the type of expression allowed in the
<CODE>debug</CODE> statement.
</P><P>

Tools should allow debug statements to be turned on or off easily.
Thus programmers should not count on debug statements being executed.
For example, if one needs to assign to a ghost variable, the proper way to
do it is to use a <VAR>set-statement</VAR> (see section <A HREF="jmlrefman_12.html#SEC172">12.4.2 Set Statements</A>),
which would execute even if debug statements are not being executed.
</P><P>

<A NAME="Hence By Statements"></A>
<HR SIZE="6">
<A NAME="SEC176"></A>
<H3> 12.4.6 Hence By Statements </H3>
<!--docid::SEC176::-->
<P>

The syntax of the <CODE>hence_by</CODE> statement is as follows.
</P><P>

<A NAME="IDX2617"></A>
<A NAME="IDX2618"></A>
<A NAME="IDX2619"></A>
<A NAME="IDX2620"></A>
<A NAME="IDX2621"></A>
<A NAME="IDX2622"></A>
<A NAME="IDX2623"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>hence-by-statement</VAR> ::= <VAR>hence-by-keyword</VAR> <VAR>predicate</VAR> <CODE>;</CODE>
<VAR>hence-by-keyword</VAR> ::= <CODE>hence_by</CODE> | <CODE>hence_by_redundantly</CODE>
</pre></td></tr></table></P><P>

The <CODE>hence_by</CODE> statement is used to record reasoning when writing
a proof by intermittent assertions.  It would normally be used between
two assert statements (see section <A HREF="jmlrefman_12.html#SEC169">12.3 Assert Statements</A>) or between two
assume statements (see section <A HREF="jmlrefman_12.html#SEC171">12.4.1 Assume Statements</A>).
</P><P>

[[[Needs example.]]]
</P><P>

<A NAME="Redundancy"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_12.html#SEC169"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_13.html#SEC177"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>May, 20  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
