<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 20  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>JML Reference Manual: Type Specifications</TITLE>

<META NAME="description" CONTENT="JML Reference Manual: Type Specifications">
<META NAME="keywords" CONTENT="JML Reference Manual: Type Specifications">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC63"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_7.html#SEC52"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_9.html#SEC80"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 8. Type Specifications </H1>
<!--docid::SEC63::-->
<P>

This chapter describes the way JML can be used to specify abstract
data types (ADTs).
</P><P>

Overall the mechanisms used in JML to specify ADTs can be described as
follows.  First, the interface of a type is described using the Java
syntax for such a type's declaration
(see section <A HREF="jmlrefman_7.html#SEC52">7. Class and Interface Member Declarations</A>); this includes any
required fields and methods, along with their types and visibilities,
etc.  Second, the behavior of a type is described by declaring model
and ghost fields to be the client (or subtype) visible abstractions of
the concrete state of the objects of that type, by writing method
specifications using those fields, and by writing various
<VAR>jml-declaration</VAR>s to further refine the logical model defined by
these fields.  These <VAR>jml-declaration</VAR>s can also be used to record
various design and implementation decisions.
</P><P>

The syntax of these <VAR>jml-declaration</VAR>s is as follows.
</P><P>

<A NAME="IDX1435"></A>
<A NAME="IDX1436"></A>
<A NAME="IDX1437"></A>
<A NAME="IDX1438"></A>
<A NAME="IDX1439"></A>
<A NAME="IDX1440"></A>
<A NAME="IDX1441"></A>
<A NAME="IDX1442"></A>
<A NAME="IDX1443"></A>
<A NAME="IDX1444"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>jml-declaration</VAR> ::= <VAR>modifiers</VAR> <VAR>invariant</VAR>
        | <VAR>modifiers</VAR> <VAR>history-constraint</VAR>
        | <VAR>modifiers</VAR> <VAR>represents-clause</VAR>
        | <VAR>modifiers</VAR> <VAR>initially-clause</VAR> 
        | <VAR>modifiers</VAR> <VAR>monitors-for-clause</VAR>
        | <VAR>modifiers</VAR> <VAR>readable-if-clause</VAR>
        | <VAR>modifiers</VAR> <VAR>writable-if-clause</VAR>
        | <VAR>axiom-clause</VAR>
</pre></td></tr></table></P><P>

The semantics of each of kind of <VAR>jml-declaration</VAR> is discussed in
the sections below. 
However, before getting to the details,
we start with some introductory examples.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC64">8.1 Introductory ADT Specification Examples</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC70">8.3 Constraints</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC74">8.4 Represents Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC75">8.5 Initially Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC76">8.6 Axioms</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC77">8.7 Readable If Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC78">8.8 Writable If Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC79">8.9 Monitors For Clause</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Introductory ADT Specification Examples"></A>
<HR SIZE="6">
<A NAME="SEC64"></A>
<H2> 8.1 Introductory ADT Specification Examples </H2>
<!--docid::SEC64::-->
<P>

[[[Need examples here, which should be first written into the
org.jmlspecs.samples.jmlrefman package and then included and discussed
here.]]]
</P><P>

<A NAME="Invariants"></A>
<HR SIZE="6">
<A NAME="SEC65"></A>
<H2> 8.2 Invariants </H2>
<!--docid::SEC65::-->
<P>

The syntax of an invariant declaration is as follows.
</P><P>

<A NAME="IDX1445"></A>
<A NAME="IDX1446"></A>
<A NAME="IDX1447"></A>
<A NAME="IDX1448"></A>
<A NAME="IDX1449"></A>
<A NAME="IDX1450"></A>
<A NAME="IDX1451"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>invariant</VAR> ::= <VAR>invariant-keyword</VAR> <VAR>predicate</VAR> <CODE>;</CODE>
<VAR>invariant-keyword</VAR> ::= <CODE>invariant</CODE> | <CODE>invariant_redundantly</CODE>
</pre></td></tr></table></P><P>

An example of an invariant is given below.
The invariant in the example has default (package) visibility,
and says that in every state that is a visible state for an object of
type <CODE>Invariant</CODE>, the object's field <CODE>b</CODE>
is not null and the array it refers to has exactly 6 elements.
In this example, no postcondition is necessary for the constructor
since the invariant is an implicit postcondition for it.
</P><P>

<A NAME="IDX1452"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;
 
public abstract class Invariant {

    boolean[] b; 

    //@ invariant b != null &#38;&#38; b.length == 6;

    //@ assignable b;
    Invariant() {
        b = new boolean[6];
    }
}
</pre></td></tr></table></P><P>

<A NAME="IDX1453"></A>
<A NAME="IDX1454"></A>
<A NAME="IDX1455"></A>
<A NAME="IDX1456"></A>
<A NAME="IDX1457"></A>
<A NAME="IDX1458"></A>
<A NAME="IDX1459"></A>
Invariants are properties that have to hold in all visible states.
The notion of visible state is of crucial importance in the explanation of
the semantics of both invariants and constraints.  A state is a
<EM>visible state</EM> for an object <I>o</I> if it is the state that occurs
at one of these moments in a program's execution:
</P><P>

<UL>
<LI>
at end of a non-helper constructor invocation that is initializing
<I>o</I>,
<P>

<LI>
at the beginning of a non-helper finalizer invocation that is
finalizing <I>o</I>,
<P>

<LI>
at the beginning or end of a non-helper non-static non-finalizer
method invocation with <I>o</I> as the receiver,
<P>

<LI>
at the beginning or end of a non-helper static method invocation for a
method in <I>o</I>'s class or some superclass of <I>o</I>'s class, or
<P>

<LI>
when no constructor, destructor, non-static method invocation with
<I>o</I> as receiver, or static method invocation for a method in <I>o</I>'s
class or some superclass of <I>o</I>'s class is in progress.
</UL>
<P>

<A NAME="IDX1460"></A>
<A NAME="IDX1461"></A>
<A NAME="IDX1462"></A>
Note that visible states for an object <I>o</I> do not include states at
the beginning and end of invocations of <EM>helpers</EM>: constructors or
methods declared with the <CODE>helper</CODE> modifier
(see section <A HREF="jmlrefman_9.html#SEC95">9.6.4 Helper methods and constructors</A>).
Thus the post-state of a helper constructor and the pre- and
post-states of helper methods are not visible states.
</P><P>

<A NAME="IDX1463"></A>
A state is a <EM>visible state</EM> for a type <I>T</I> if it occurs after
static initialization for <I>T</I> is complete and it is a visible state
for some object that has type <I>T</I>.
</P><P>

<A NAME="IDX1464"></A>
<A NAME="IDX1465"></A>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
JML distinguishes <EM>static</EM> and <EM>instance</EM> invariants.  These are
mutually exclusive and any invariant is either a static or instance
invariant.  An invariant may be explicitly declared to be static or
instance by using one of the modifiers <CODE>static</CODE> or <CODE>instance</CODE>
in the declaration of the invariant.  An invariant declared in a class
declaration is, by default, an instance invariant.  An invariant
declared in an interface declaration is, by default, a static invariant.
</P><P>

For example, the invariant declared in the class <CODE>Invariant</CODE> above
is an instance invariant, because it occurs inside a class declaration.
If <CODE>Invariant</CODE> had been an interface instead of a class, then this
invariant would have been a static invariant.
</P><P>

A static invariant may only refer to static fields of an object.  An
instance invariant, on the other hand, may refer to both static and
non-static fields.
</P><P>

The distinction between static and instance invariants also affects
when the invariants are supposed to hold.  A static invariant declared
in a type <I>T</I> must hold in every state that is a visible state for
type <I>T</I>.  An instance invariant declared in a type <I>T</I> must
hold for every object <I>o</I> of type <I>T</I>, for every state that is a
visible state for <I>o</I>.
</P><P>

<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
<A NAME="IDX1470"></A>
<A NAME="IDX1471"></A>
<A NAME="IDX1472"></A>
<A NAME="IDX1473"></A>
For reasoning about invariants we make a distinction between assuming,
establishing, and preserving an invariant.  A method or constructor
<EM>assumes</EM> an invariant if the invariant must hold in its
pre-state.  A method or constructor <EM>establishes</EM> an invariant if
the invariant must hold in its post-state.  A method or constructor
<EM>preserves</EM> an invariant if the invariant is both assumed and
established.
</P><P>

<A NAME="IDX1474"></A>
<A NAME="IDX1475"></A>
JML's verification logic enforces invariants by making sure that
each non-helper method, constructor, or finalizer:
<UL>
<LI>
assumes the static invariants of all types, <I>T</I>, for which
its pre-state is a visible state for <I>T</I>,
<P>

<LI>
establishes the static invariants of all types, <I>T</I>, for which
its post-state is a visible state for <I>T</I>,
<P>

<LI>
assumes the instance invariants of all objects, <I>o</I>,
for which its pre-state is a visible state for <I>o</I>, and
<P>

<LI>
establishes the instance invariants of all objects, <I>o</I>,
for which its post-state is a visible state for <I>o</I>.
</UL>
<P>

This means that each non-helper constructor found in a class <I>C</I>
preserves the static invariants of all types, including <I>C</I>, that
have finished their static initialization, establishes the instance
invariant of the object under construction, and, modulo creation and
deletion of objects, preserves the instance invariants of all other
objects.  (Objects that are created by a constructor must have their
instance invariant established; and objects that are deleted by the
action of the constructor can be assumed to satisfy their instance
invariant in the constructor's pre-state.)  Note in particular that,
at the beginning of a constructor invocation, the instance invariant
of the object being initialized does not have to hold yet.
</P><P>

Furthermore, each non-helper non-static method found in a type <I>T</I>
preserves the static invariants of all types that have finished their
static initialization, including <I>T</I>, and, modulo creation and
deletion of objects, preserves the instance invariants of all objects,
in particular the receiver object.
However, finalizers do only assume the instance invariant of the
receiver object, and do not have to establish it on exit.
</P><P>

<A NAME="IDX1476"></A>
<A NAME="IDX1477"></A>
The semantics given above is highly non-modular, but is in general
necessary for the enforcement of invariance when no mechanisms are
available to prevent aliasing problems, or when constructs like
(concrete) public fields are used <A HREF="jmlrefman_27.html#BIB93">[Poetzsch-Heffter97]</A>.  Of course, one
would like to enforce invariants in a more modular way.  By a modular
enforcement of invariants, we mean that one could verify each type
independently of the types that it does not use, and that a well-formed
program put together from such verified types would still satisfy the
semantics for invariants given above.  That is, each type would be
responsible for the enforcement of the invariants it declares and would
be able to assume, without checking, the invariants of other types it
uses.
</P><P>

<A NAME="IDX1478"></A>
<A NAME="IDX1479"></A>
<A NAME="IDX1480"></A>
<A NAME="IDX1481"></A>
<A NAME="IDX1482"></A>
<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>
<A NAME="IDX1485"></A>
To accomplish this ideal, it seems that some mechanism for object
ownership and alias control <A HREF="jmlrefman_27.html#BIB91">[Noble-Vitek-Potter98]</A>
<A HREF="jmlrefman_27.html#BIB84">[Mueller-Poetzsch-Heffter00]</A> <A HREF="jmlrefman_27.html#BIB85">[Mueller-Poetzsch-Heffter00a]</A>
<A HREF="jmlrefman_27.html#BIB86">[Mueller-Poetzsch-Heffter01a]</A> <A HREF="jmlrefman_27.html#BIB89">[Mueller02]</A>
<A HREF="jmlrefman_27.html#BIB87">[Mueller-Poetzsch-Heffter-Leavens03]</A> is necessary.  However,
this mechanism is still not a part of JML, although some design work
in this direction has taken place
<A HREF="jmlrefman_27.html#BIB88">[Mueller-Poetzsch-Heffter-Leavens06]</A>.
</P><P>

On the other hand, people generally assume that there are no object
ownership alias problems; this is perhaps a reasonable strategy for some
tools, like run-time assertion checkers, to take.  The alternative,
tracking which types and objects are in visible states, and checking
every applicable invariant for every type and object in a visible state,
is obviously impractical.
</P><P>

Therefore, assuming or ignoring the problems with object ownership and
alias control, one obtains a simple and more modular way to check
invariants.  This is as follows.
<UL>
<LI>
Each non-helper constructor declared in a class <I>C</I>, must preserve
the static invariant of <I>C</I>, if <I>C</I> is finished with its static
initialization, and must establish the instance invariant of the
object being constructed.
<P>

<LI>
Each non-helper non-static non-finalizer method declared in a type <I>T</I>, must
preserve the static invariant of <I>T</I>, if <I>T</I> is finished with its
static initialization, and must preserve the instance invariant of the
receiver object.
<P>

<LI>
Each non-helper static method declared in a type <I>T</I>, must preserve
the static invariant of <I>T</I>, if <I>T</I> is finished with its static
initialization.
</UL>
When doing such proofs, one may assume the static invariant of any
type (that is finished with its static initialization), and one may
also assume the instance invariant of any other object.
<P>

In this, more modular, style of checking invariants, one can think of
all the static invariants in a class as being implicitly conjoined to
the pre- and postconditions of all non-helper constructors and
methods, and the instance invariants in a class as being implicitly
conjoined to the postcondition of all non-helper constructors, and to
the pre- and postconditions of all non-helper methods.
</P><P>

<A NAME="IDX1486"></A>
As noted above, <CODE>helper</CODE> methods and constructors are exempt from
the normal rules for checking invariants.  That is because the
beginning and end of invocations of these <CODE>helper</CODE> methods and
constructors are not visible states, and therefore they do not have to
preserve or establish invariants.  Note that only <CODE>private</CODE>
methods and constructors can be declared as <CODE>helper</CODE>.
See section <A HREF="jmlrefman_7.html#SEC58">7.1.1.4 Helper Methods and Constructors</A>.
</P><P>

The following subsections discuss other points about the semantics of
invariants:
<UL>
<LI>
Invariants can be declared <CODE>static</CODE>; 
see <A HREF="jmlrefman_8.html#SEC66">8.2.1 Static vs. instance invariants</A>.
<P>

<LI>
Invariants can be declared with the access modifiers <CODE>public</CODE>,
<CODE>protected</CODE>, and <CODE>private</CODE>, or be left with default access;
see <A HREF="jmlrefman_8.html#SEC68">8.2.3 Access Modifiers for Invariants</A>.
<P>

<LI>
Invariants should also hold in case a constructor or method terminates
abruptly, by throwing an exception; 
see <A HREF="jmlrefman_8.html#SEC67">8.2.2 Invariants and Exceptions</A>.
<P>

<LI>
A class inherits all visible invariants specified in its superclasses
and superinterfaces; see <A HREF="jmlrefman_8.html#SEC69">8.2.4 Invariants and Inheritance</A>.
<P>

<LI>
Although some aspects of invariants are discussed in isolation here,
the full explanation of their semantics can only be given considered
together with that of method specifications.  After all, a method only
has to preserve invariants when one of the preconditions (i.e.,
<CODE>requires</CODE> clauses) specified for that method holds.  So
invariants are an integral part of the explanation of method
specifications in <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>.
<P>

<LI>
When considering an individual method body, remember that invariants
should not just hold in the beginning and the end of it, but also at
any program point halfway where another (non-<CODE>helper</CODE>) method or
constructor is invoked.  After all, these program points are also
visible states, and, as stated above, invariants should hold at all
visible states.
<P>

<LI>
<A NAME="IDX1487"></A>
A method invocation on an object should not just preserve the instance
invariants of that object and the static invariants of the class, but
it should preserve the invariants of all other (reachable) objects as
well <A HREF="jmlrefman_27.html#BIB93">[Poetzsch-Heffter97]</A>.
</UL>
<P>

It should be noted that the last two points above are not specific to
Java or JML, but these are tricky issues that have to be considered
for any notion of invariant in an object-oriented languages. Indeed,
these two issues make the familiar notion of invariant a lot more
complicated than one might guess at first sight!
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC66">8.2.1 Static vs. instance invariants</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC67">8.2.2 Invariants and Exceptions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC68">8.2.3 Access Modifiers for Invariants</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC69">8.2.4 Invariants and Inheritance</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Static vs. instance invariants"></A>
<HR SIZE="6">
<A NAME="SEC66"></A>
<H3> 8.2.1 Static vs. instance invariants </H3>
<!--docid::SEC66::-->
<P>

<A NAME="IDX1488"></A>
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
As discussed above (see section <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A>),
invariants can be declared <CODE>static</CODE> or <CODE>instance</CODE>.
Just like a static method, a static invariant cannot refer to the 
current object <CODE>this</CODE> and thus cannot refer to instance fields of
<CODE>this</CODE> or non-static methods of the type.
</P><P>

Instance invariants must be established by the constructors of an object,
and must be preserved by all non-helper instance methods.
If an object has fields that can be changed without calling methods
(usually a bad idea), then any such changes must also preserve the
invariants.  For example, if an object has a public field, each
assignment to that field must establish all invariants that
might be affected.
</P><P>

Static methods do not have a receiver object for which they need to
assume or establish an instance invariant, since they have no receiver
object.  However, a static method may assume instance invariants of
other objects, such as argument objects passed to the
method.<A NAME="DOCF7" HREF="jmlrefman_fot.html#FOOT7">(7)</A>
</P><P>

Static invariants must be established by the static initialization
of a class, and must be preserved by all non-helper constructors and methods, 
i.e., by both static and instance methods.
</P><P>

The table below summarizes this:
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><TT>          | static          non-helper     non-helper    non-helper</TT>
<TT>          | initialization  static method  constructor   instance method</TT>
<TT>--------------------------------------------------------------------</TT>
<TT>static    | establish       preserve       preserve      preserve   </TT>
<TT>invariant |                                                         </TT>
<TT>          |                                                         </TT>
<TT>instance  | (irrelevant)    (irrelevant)   establish     preserve,   </TT>
<TT>invariant |                                              if not a   </TT>
<TT>                                                         finalizer</TT>
</pre></td></tr></table></P><P>

<A NAME="IDX1495"></A>
<A NAME="IDX1496"></A>
<A NAME="IDX1497"></A>
<A NAME="IDX1498"></A>
<A NAME="IDX1499"></A>
A word of warning about terminology.  As stated above, we call an
invariant about static properties "static invariants" and we call an
invariant about the dynamic properties of objects an "instance
invariant" or, equivalently, an "object invariant."  This terminology
is contrary to the literature but it is more accurate with respect to
the nomenclature of Java.
</P><P>

<A NAME="Invariants and Exceptions"></A>
<HR SIZE="6">
<A NAME="SEC67"></A>
<H3> 8.2.2 Invariants and Exceptions </H3>
<!--docid::SEC67::-->
<P>

Methods and constructors should preserve and establish invariants both
in the case of normal termination and in the case of abrupt
termination (i.e., when an exception is thrown).  In other words,
invariants are implicitly included in both normal postconditions,
i.e., <CODE>ensures</CODE> clauses, and in exceptional postconditions, i.e.,
<CODE>signals</CODE> clauses, of methods and constructors.
</P><P>

The requirement that invariants hold after abrupt termination of a
method or constructor may seen excessively strong.  However, it is the
only sound option in the long run.  After all, once an object's
invariant is broken, no guarantees whatsoever can be made about
subsequent method invocations on that object.  When faced with a method
or constructor that may violate an invariant in case it throws an
exception, one will typically try to strengthen the precondition of the
method to rule out this exceptional behavior or try to weaken the
invariant.  Note that a method that does not have any side effects when
it throws an exception automatically preserves all invariants.
</P><P>

<A NAME="Access Modifiers for Invariants"></A>
<HR SIZE="6">
<A NAME="SEC68"></A>
<H3> 8.2.3 Access Modifiers for Invariants </H3>
<!--docid::SEC68::-->
<P>

Invariants can be declared with any one of the Java access modifiers
 <CODE>private</CODE>, <CODE>protected</CODE>, and <CODE>public</CODE>.  Like class
members, invariants declared in a class have <CODE>package</CODE> visibility
if they do not have one of these keywords as modifier.  Similarly,
invariants declared in an interface implicitly have <CODE>public</CODE>
visibility if they do not have one of these keywords as modifier.
</P><P>

The access modifier of an invariant affects which members, i.e. which
fields and which (pure) methods, may be used in it, according to JML's
usual visibility rules.  See section <A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A>, for
the details and an example using invariants.
</P><P>

The access modifiers of invariants do <EM>not</EM> affect the obligations
of methods and constructors to maintain and establish them.  That is,
<EM>all</EM> non-<CODE>helper</CODE> methods are expected to preserve
invariants irrespective of the access modifiers of the invariants and
the methods.  For example, a public method must preserve private
invariants as well as public ones.
</P><P>

[[[
JML's visibility restrictions still allow some highly dubious
invariants.  E.g., a private invariant can refer to a public field,
which, if this public field is not final, means the invariant is not
really enforceable.  Tools should warn about (or forbid??)  invariants
which refer to non-final non-model fields that have a looser access
control than the invariant itself has.
]]]
</P><P>

<A NAME="Invariants and Inheritance"></A>
<HR SIZE="6">
<A NAME="SEC69"></A>
<H3> 8.2.4 Invariants and Inheritance </H3>
<!--docid::SEC69::-->
<P>

Each type inherits all the instance invariants specified
in its superclasses and superinterfaces.
[[[Erik wrote: "Static invariants are not inherited", but there seems to
be some kind of static field inheritance in Java...]]]
[[[ DRCok- but all the static invariants of a superclass have to be 
maintained by the subclass methods - isn't this equivalent to inheritance?]]]
</P><P>

The fact that (instance) invariants are inherited is one of the
reasons why the use of the keyword <CODE>super</CODE> is not allowed
in invariants.  [[[ Is this true? - I don't understand this. DRCok ]]]
</P><P>

<A NAME="Constraints"></A>
<HR SIZE="6">
<A NAME="SEC70"></A>
<H2> 8.3 Constraints </H2>
<!--docid::SEC70::-->
<P>

<A NAME="IDX1500"></A>
History constraints <A HREF="jmlrefman_27.html#BIB76">[Liskov-Wing93b]</A> <A HREF="jmlrefman_27.html#BIB77">[Liskov-Wing94]</A>, which we call
<EM>constraints</EM> for short, are related to invariants.  But whereas
invariants are predicates that should hold in all visible states,
history constraints are relationships that should hold for the combination of
each visible state
and any visible state that occurs later in the program's execution.
Constraints can therefore be used to constrain the way that values
change over time.
</P><P>

The syntax of history constraints in JML is as follows.
</P><P>

<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>
<A NAME="IDX1503"></A>
<A NAME="IDX1504"></A>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>
<A NAME="IDX1507"></A>
<A NAME="IDX1508"></A>
<A NAME="IDX1509"></A>
<A NAME="IDX1510"></A>
<A NAME="IDX1511"></A>
<A NAME="IDX1512"></A>
<A NAME="IDX1513"></A>
<A NAME="IDX1514"></A>
<A NAME="IDX1515"></A>
<A NAME="IDX1516"></A>
<A NAME="IDX1517"></A>
<A NAME="IDX1518"></A>
<A NAME="IDX1519"></A>
<A NAME="IDX1520"></A>
<A NAME="IDX1521"></A>
<A NAME="IDX1522"></A>
<A NAME="IDX1523"></A>
<A NAME="IDX1524"></A>
<A NAME="IDX1525"></A>
<A NAME="IDX1526"></A>
<A NAME="IDX1527"></A>
<A NAME="IDX1528"></A>
<A NAME="IDX1529"></A>
<A NAME="IDX1530"></A>
<A NAME="IDX1531"></A>
<A NAME="IDX1532"></A>
<A NAME="IDX1533"></A>
<A NAME="IDX1534"></A>
<A NAME="IDX1535"></A>
<A NAME="IDX1536"></A>
<A NAME="IDX1537"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>history-constraint</VAR> ::= <VAR>constraint-keyword</VAR> <VAR>predicate</VAR>
              [ <CODE>for</CODE> <VAR>constrained-list</VAR> ] <CODE>;</CODE>
<VAR>constraint-keyword</VAR> ::= <CODE>constraint</CODE> | <CODE>constraint_redundantly</CODE>
<VAR>constrained-list</VAR> ::= <VAR>method-name-list</VAR> | <CODE>\everything</CODE>
<VAR>method-name-list</VAR> ::= <VAR>method-name</VAR> [ <CODE>,</CODE> <VAR>method-name</VAR> ] <small>...</small>
<VAR>method-name</VAR> ::= <VAR>method-ref</VAR> [ <CODE>(</CODE> [ <VAR>param-disambig-list</VAR> ] <CODE>)</CODE> ] | <VAR>method-ref-start</VAR> <CODE>.</CODE> <CODE>*</CODE> 
<VAR>method-ref</VAR> ::= <VAR>method-ref-start</VAR> [ <CODE>.</CODE> <VAR>method-ref-rest</VAR> ] <small>...</small>
        | <CODE>new</CODE> <VAR>reference-type</VAR>
<VAR>method-ref-start</VAR> ::=  <CODE>super</CODE> | <CODE>this</CODE> | <VAR>ident</VAR>
<VAR>method-ref-rest</VAR> ::=  <CODE>this</CODE> | <VAR>ident</VAR>
<VAR>param-disambig-list</VAR> ::= <VAR>param-disambig</VAR> [ <CODE>,</CODE> <VAR>param-disambig</VAR> ] <small>...</small>
<VAR>param-disambig</VAR> ::= <VAR>type-spec</VAR> [ <VAR>ident</VAR> [ <VAR>dims</VAR> ] ]
</pre></td></tr></table></P><P>

Because methods will not necessarily change the values referred to in
a constraint, a constraint will generally describe reflexive and transitive
relations.
</P><P>

For example, the constraints in the example below say that the
value of field <CODE>a</CODE> and the length of the array <CODE>b</CODE> will 
never change, and that the length of the array <CODE>c</CODE> will only ever 
increase.
<A NAME="IDX1538"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class Constraint {

    int a;
    //@ constraint a == \old(a);
 
    boolean[] b; 

    //@ invariant b != null;
    //@ constraint b.length == \old(b.length) ;

    boolean[] c;

    //@ invariant c != null;
    //@ constraint c.length &#62;= \old(c.length) ;

    //@ requires bLength &#62;= 0 &#38;&#38; cLength &#62;= 0;
    Constraint(int bLength, int cLength) {
      b = new boolean[bLength];
      c = new boolean[cLength];
    }
}

</pre></td></tr></table>Note that, unlike invariants, constraints can -- and typically do -- 
use the JML keyword <CODE>\old</CODE>.
</P><P>

A constraint declaration may optionally explicitly list one or more methods.  It is
the listed methods that must <EM>respect</EM> the constraint.  If no methods are listed, then 
all non-helper methods of the class (and any subclasses) must respect the constraint.
A method respects a history constraint iff the
pre-state and the post-state of a non-static method invocation are in
the relation specified by the history constraint.
So one can think of history constraints as being
implicitly included in the postcondition of relevant methods.  However,
history constraints do not apply to constructors and destructors,
since constructors do not have a pre-state and destructors do not have
a post-state.
</P><P>

Private methods declared as <CODE>helper</CODE> methods do not have to 
respect history constraints, just like these do not have to preserve 
invariants.
</P><P>

A few points to note about history constraints:
<UL>
<LI>
Constraints can be declared <CODE>static</CODE>;
see <A HREF="jmlrefman_8.html#SEC71">8.3.1 Static vs. instance constraints</A>.
<P>

<LI>
Constraints can be declared with the access modifiers <CODE>public</CODE>, 
<CODE>protected</CODE>, and <CODE>private</CODE>;
see <A HREF="jmlrefman_8.html#SEC72">8.3.2 Access Modifiers for Constraints</A>.
<P>

<LI>
Constraints should also hold if a method terminates abruptly by
throwing an exception.
<P>

<LI>
A class inherits all constraints specified in its superclasses 
and superinterfaces;
see <A HREF="jmlrefman_8.html#SEC73">8.3.3 Constraints and Inheritance</A>. 
<P>

<LI>
Although some aspects of constraints are discussed in isolation here,
the full explanation of their semantics can only be given considered
together with that of method specifications.  After all, a method only
has to respect constraints when one of the preconditions
(ie. <CODE>requires</CODE> clauses) specified for that method holds.  So
constraints are an integral part of the explanation of method
specifications in <A HREF="jmlrefman_9.html#SEC80">9. Method Specifications</A>.
<P>

<LI>
When considering an individual method body, remember that constraints
not only have to hold between the pre-state and the post-state, but
between all visible state that arise during execution of the method.
So, given that any program points in the method where
(non-<CODE>helper</CODE>) methods or constructors are invoked are also
visible states, constraints should also hold between the pre-state and
any such program points, between these program points themselves, and
between any such program points and the post-state.
<P>

<LI>
A method invocation on an object <CODE>o</CODE> should not just respect the
constraints of <CODE>o</CODE>, but should respect the constraints of all
other (reachable) objects as well.
</UL>
<P>

These aspects of constraints are discussed in more detail below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC71">8.3.1 Static vs. instance constraints</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC72">8.3.2 Access Modifiers for Constraints</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_8.html#SEC73">8.3.3 Constraints and Inheritance</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Static vs. instance constraints"></A>
<HR SIZE="6">
<A NAME="SEC71"></A>
<H3> 8.3.1 Static vs. instance constraints </H3>
<!--docid::SEC71::-->
<P>

<A NAME="IDX1539"></A>
<A NAME="IDX1540"></A>
<A NAME="IDX1541"></A>
<A NAME="IDX1542"></A>
<A NAME="IDX1543"></A>
<A NAME="IDX1544"></A>
<A NAME="IDX1545"></A>
History constraints can be declared <CODE>static</CODE>.
Non-<CODE>static</CODE> constraints are also called <EM>instance</EM> constraints.
Like a static invariant, a static history constraint cannot refer to the 
current object <CODE>this</CODE> or to its fields.
</P><P>

Static constraints should be respected by all constructors and all methods, 
i.e., both static and instance methods.
</P><P>

Instance constraints must be respected by all instance methods.
</P><P>

The table below summarizes this:
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><TT>          | static          non-helper     non-helper    non-helper</TT>
<TT>          | initialization  static method  constructor   instance method</TT>
<TT>--------------------------------------------------------------------</TT>
<TT>static    | (irrelevant)    respect        respect       respect   </TT>
<TT>constraint|                                                         </TT>
<TT>          |                                                         </TT>
<TT>instance  | (irrelevant)    (irrelevant)   (irrelevant)  respect    </TT>
<TT>constraint|                                                         </TT>
</pre></td></tr></table></P><P>

Instance constraints are irrelevant for constructors,
in that here there is no pre-state for a constructor that can be related 
(or not) to the post-state.
However, if a visible state arises during the execution of a constructor,
then any instance constraints have to be respected.
</P><P>

In the same way, and for the same reason, static constraints are irrelevant 
for static initialization.
</P><P>

<A NAME="Access Modifiers for Constraints"></A>
<HR SIZE="6">
<A NAME="SEC72"></A>
<H3> 8.3.2 Access Modifiers for Constraints </H3>
<!--docid::SEC72::-->
<P>

The access modifiers <CODE>public</CODE>, <CODE>private</CODE>, and <CODE>protected</CODE>
pose exactly the same restrictions on constraints as they do on invariants,
see <A HREF="jmlrefman_8.html#SEC68">8.2.3 Access Modifiers for Invariants</A>.
</P><P>

<A NAME="Constraints and Inheritance"></A>
<HR SIZE="6">
<A NAME="SEC73"></A>
<H3> 8.3.3 Constraints and Inheritance </H3>
<!--docid::SEC73::-->
<P>

Any class inherits all the instance constraints specified
in its superclasses and superinterfaces.
[[[Static constraints are not inherited.]]] [[[ But they still apply to subclasses, no ? and it says they are above - David]]]
</P><P>

The fact that (instance) constraints are inherited is one of the
reasons why the use of the keyword <CODE>super</CODE> is not allowed
in constraints.  [[[ Needs explanation - David ]]]
</P><P>

<A NAME="Represents Clauses"></A>
<HR SIZE="6">
<A NAME="SEC74"></A>
<H2> 8.4 Represents Clauses </H2>
<!--docid::SEC74::-->
<P>

<A NAME="IDX1546"></A>
The following is the syntax for <CODE>represents</CODE> clauses.
</P><P>

<A NAME="IDX1547"></A>
<A NAME="IDX1548"></A>
<A NAME="IDX1549"></A>
<A NAME="IDX1550"></A>
<A NAME="IDX1551"></A>
<A NAME="IDX1552"></A>
<A NAME="IDX1553"></A>
<A NAME="IDX1554"></A>
<A NAME="IDX1555"></A>
<A NAME="IDX1556"></A>
<A NAME="IDX1557"></A>
<A NAME="IDX1558"></A>
<A NAME="IDX1559"></A>
<A NAME="IDX1560"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>represents-clause</VAR> ::= <VAR>represents-keyword</VAR> <VAR>store-ref-expression</VAR>
                    <VAR>l-arrow-or-eq</VAR> <VAR>spec-expression</VAR> <CODE>;</CODE>
        | <VAR>represents-keyword</VAR> <VAR>store-ref-expression</VAR> <CODE>\such_that</CODE>
          <VAR>predicate</VAR> <CODE>;</CODE>
<VAR>represents-keyword</VAR> ::= <CODE>represents</CODE> | <CODE>represents_redundantly</CODE>
<VAR>l-arrow-or-eq</VAR> ::= <CODE>&#60;-</CODE> | <CODE>=</CODE>
</pre></td></tr></table></P><P>

<A NAME="IDX1561"></A>
<A NAME="IDX1562"></A>
<A NAME="IDX1563"></A>
The first form of <CODE>represents</CODE> clauses (with <CODE>&#60;-</CODE> or
<CODE>=</CODE>) is called a <EM>functional abstraction</EM>.  This form
defines the value of the <VAR>store-ref-expression</VAR> in a visible state
as the value of the <VAR>spec-expression</VAR> that follows the 
<VAR>l-arrow-or-eq</VAR>.
</P><P>

<A NAME="IDX1564"></A>
<A NAME="IDX1565"></A>
The second form (with <CODE>\such_that</CODE>) is called a
<EM>relational abstraction</EM>.
This form constrains the value of the <VAR>store-ref-expression</VAR> in a
visible state to satisfy the given <VAR>predicate</VAR>.
</P><P>

<UL>
<LI>
The left-hand side of a <CODE>represents</CODE> clause must be a reference
to a model field (See section <A HREF="jmlrefman_7.html#SEC52">7. Class and Interface Member Declarations</A>, for details of model fields).  Although it is a <VAR>store-ref-expression</VAR>,
wild cards and array ranges are not permitted.
<P>

<LI>
In the functional abstraction form, the type of right-hand side of a
<CODE>represents clause</CODE> must be assignment-compatible to the type of
left-hand side.
<P>

<LI>
In the relational abstraction form, the type of right-hand side of a
<CODE>represents clause</CODE> must be <CODE>boolean</CODE>.
</UL>
<P>

A <CODE>represents</CODE> clause can be declared as <CODE>static</CODE>
(See section <A HREF="jmlrefman_6.html#SEC35">6. Type Definitions</A>, for <CODE>static</CODE> declarations).  In a
<CODE>static represents</CODE> clause, only static elements can be
referenced both in the left-hand side and the right-hand side.  In
addition, the following restriction is enforced:
</P><P>

<UL>
<LI>
A <CODE>static</CODE> <CODE>represents</CODE> clause must be declared in the type
where the model field on the left-hand side is declared.
</UL>
<P>

Unless explicitly declared as <CODE>static</CODE>, a <CODE>represents</CODE>
clause is non-<CODE>static</CODE>
(for exceptions see see section <A HREF="jmlrefman_6.html#SEC35">6. Type Definitions</A>).  
A non-<CODE>static represents</CODE> clause can refer to
both <CODE>static</CODE> and non-<CODE>static</CODE> elements on the right-hand
side.
</P><P>

<UL>
<LI>
A non-<CODE>static represents</CODE> clause must not have a static model
field in its left-hand side.
<P>

<LI>
A non-<CODE>static represents</CODE> clause must be declared in a type
descended from (or nested within) the type where the model field on
the left-hand side is declared.
</UL>
<P>

Note that represents clauses can be recursive.  That is, a represents
clause may name a field on its right hand side that is the same as the
field being represented (named on the left hand side).  It is the
specifier's responsibility to make sure such definitions are
well-defined.  But such recursive represents clauses can be useful when
dealing with recursive datatypes <A HREF="jmlrefman_27.html#BIB87">[Mueller-Poetzsch-Heffter-Leavens03]</A>.
</P><P>

<A NAME="Initially Clauses"></A>
<HR SIZE="6">
<A NAME="SEC75"></A>
<H2> 8.5 Initially Clauses </H2>
<!--docid::SEC75::-->
<P>

The <VAR>initially-clause</VAR> has the following syntax.
</P><P>

<A NAME="IDX1566"></A>
<A NAME="IDX1567"></A>
<A NAME="IDX1568"></A>
<A NAME="IDX1569"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>initially-clause</VAR> ::= <CODE>initially</CODE> <VAR>predicate</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

The meaning is that each non-helper (see section <A HREF="jmlrefman_6.html#SEC47">6.2.8 Helper</A>) constructor for
each concrete subtype of the 
enclosing type (including that type itself, if it is concrete) must
establish the <VAR>predicate</VAR>.  Thus, the predicate can be thought of
as implicitly conjoined to the postconditions of all non-helper constructors.
</P><P>

<A NAME="Axioms"></A>
<HR SIZE="6">
<A NAME="SEC76"></A>
<H2> 8.6 Axioms </H2>
<!--docid::SEC76::-->
<P>

An <VAR>axiom-clause</VAR> has the following syntax.
</P><P>

<A NAME="IDX1570"></A>
<A NAME="IDX1571"></A>
<A NAME="IDX1572"></A>
<A NAME="IDX1573"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>axiom-clause</VAR> ::= <CODE>axiom</CODE> <VAR>predicate</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

Such a clause specifies that a theorem prover should assume that the given
predicate is true (whenever such an assumption is needed).
</P><P>

[[[ example needed ]]]
</P><P>

<A NAME="Readable If Clauses"></A>
<HR SIZE="6">
<A NAME="SEC77"></A>
<H2> 8.7 Readable If Clauses </H2>
<!--docid::SEC77::-->
<P>

The syntax of the <VAR>readable-if-clause</VAR> is as follows.
</P><P>

<A NAME="IDX1574"></A>
<A NAME="IDX1575"></A>
<A NAME="IDX1576"></A>
<A NAME="IDX1577"></A>
<A NAME="IDX1578"></A>
<A NAME="IDX1579"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>readable-if-clause</VAR> ::= <CODE>readable</CODE> <VAR>ident</VAR> <CODE>if</CODE> <VAR>predicate</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

Such a clause gives a condition that must be true before the field
named by <VAR>ident</VAR> can be read.  This field must be one
declared in the type in which the declaration appears,
or in a supertype of the class.
</P><P>

<A NAME="Writable If Clauses"></A>
<HR SIZE="6">
<A NAME="SEC78"></A>
<H2> 8.8 Writable If Clauses </H2>
<!--docid::SEC78::-->
<P>

The syntax of the <VAR>writeable-if-clause</VAR> is as follows.
</P><P>

<A NAME="IDX1580"></A>
<A NAME="IDX1581"></A>
<A NAME="IDX1582"></A>
<A NAME="IDX1583"></A>
<A NAME="IDX1584"></A>
<A NAME="IDX1585"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>writable-if-clause</VAR> ::= <CODE>writable</CODE> <VAR>ident</VAR> <CODE>if</CODE> <VAR>predicate</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

Such a clause gives a condition that must be true before the field
named by <VAR>ident</VAR> can be written.  This field must be one
declared in the type in which the declaration appears,
or in a supertype of the class.
</P><P>

<A NAME="Monitors For Clause"></A>
<HR SIZE="6">
<A NAME="SEC79"></A>
<H2> 8.9 Monitors For Clause </H2>
<!--docid::SEC79::-->
<P>

The <VAR>monitors-for-clause</VAR> is adapted from ESC/Java
<A HREF="jmlrefman_27.html#BIB69">[Leino-Nelson-Saxe00]</A> <A HREF="jmlrefman_27.html#BIB97">[Rodriguez-etal05]</A>.  It has the
following syntax.
</P><P>

<A NAME="IDX1586"></A>
<A NAME="IDX1587"></A>
<A NAME="IDX1588"></A>
<A NAME="IDX1589"></A>
<A NAME="IDX1590"></A>
<A NAME="IDX1591"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>monitors-for-clause</VAR> ::= <CODE>monitors_for</CODE> <VAR>ident</VAR>
                        <VAR>l-arrow-or-eq</VAR> <VAR>spec-expression-list</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

A <VAR>monitors-for-clause</VAR> such as <CODE>monitors_for f &#60;- e1, e2;</CODE>
specifies a relationship between the field, <CODE>f</CODE>
and a set of objects, denoted by a specification expression list
<CODE>e1, e2</CODE>.  The meaning of this declaration is
that all of the (non-null) objects in the list, in this
example, the objects denoted by <CODE>e1</CODE> and <CODE>e2</CODE>, must be
locked to read the field (<CODE>f</CODE> in the example) in this object.
</P><P>

Note that the righthand-side of the <VAR>monitors-for-clause</VAR> is not just a
<VAR>store-ref-list</VAR>, but is in fact a <VAR>spec-expression-list</VAR>,
where each <VAR>spec-expression</VAR> evaluates to a reference to an
object.
</P><P>

<A NAME="Method Specifications"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_8.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_9.html#SEC80"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>May, 20  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
