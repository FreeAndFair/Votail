<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 20  2008 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>JML Reference Manual: Method Specifications</TITLE>

<META NAME="description" CONTENT="JML Reference Manual: Method Specifications">
<META NAME="keywords" CONTENT="JML Reference Manual: Method Specifications">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC80"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_8.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_10.html#SEC118"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 9. Method Specifications </H1>
<!--docid::SEC80::-->
<P>

<A NAME="IDX1592"></A>
<A NAME="IDX1593"></A>
Although the use of pre- and postconditions for specification of the
behavior of methods is standard, JML offers some features that are
not so standard.  A good example of such a feature is the distinction
between normal and exceptional postconditions (in <CODE>ensures</CODE> and
<CODE>signals</CODE> clauses, respectively), and the specification of frame
conditions using <CODE>assignable</CODE> clauses.  Another example of such a
feature is that JML uses privacy modifiers to allow one to write
different specification that are intended for different readers; for
example, one can write a public specification for clients, a protected
specification for subclasses, and a private specification to record
implementation design decisions.
Yet another such feature is the use of redundancy to allow one to
point out important consequences of a specification for readers
<A HREF="jmlrefman_27.html#BIB105">[Tan95]</A> <A HREF="jmlrefman_27.html#BIB52">[Leavens-Baker99]</A>.
</P><P>

JML provides two constructs for specifying methods and constructors:
<UL>
<LI>
pre- and postconditions, and
<P>

<LI>
model programs.
<P>

</UL>
<P>

This chapter only discusses the first of these,
which is by far the most common.
Model programs are discussed in <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC81">9.1 Basic Concepts in Method Specification</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC82">9.2 Organization of Method Specifications</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC83">9.3 Access Control in Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC84">9.4 Lightweight Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC87">9.5 Heavyweight Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC88">9.6 Behavior Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC97">9.7 Normal Behavior Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC98">9.8 Exceptional Behavior Specification Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC100">9.9 Method Specification Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Basic Concepts in Method Specification"></A>
<HR SIZE="6">
<A NAME="SEC81"></A>
<H2> 9.1 Basic Concepts in Method Specification </H2>
<!--docid::SEC81::-->
<P>

[[[Discuss the "client viewpoint" here and give some basic examples here.]]]
</P><P>

[[[Perhaps discuss other common things to avoid repeating ourselves below...]]]
</P><P>

<A NAME="Organization of Method Specifications"></A>
<HR SIZE="6">
<A NAME="SEC82"></A>
<H2> 9.2 Organization of Method Specifications </H2>
<!--docid::SEC82::-->
<P>

The following gives the syntax of behavioral specifications for methods.
We start with the top-level syntax that organizes these specifications.
</P><P>

<A NAME="IDX1594"></A>
<A NAME="IDX1595"></A>
<A NAME="IDX1596"></A>
<A NAME="IDX1597"></A>
<A NAME="IDX1598"></A>
<A NAME="IDX1599"></A>
<A NAME="IDX1600"></A>
<A NAME="IDX1601"></A>
<A NAME="IDX1602"></A>
<A NAME="IDX1603"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>method-specification</VAR> ::= <VAR>specification</VAR> | <VAR>extending-specification</VAR>
<VAR>extending-specification</VAR> ::= <CODE>also</CODE> <VAR>specification</VAR>
<VAR>specification</VAR> ::= <VAR>spec-case-seq</VAR> [ <VAR>redundant-spec</VAR> ]
              | <VAR>redundant-spec</VAR>
<VAR>spec-case-seq</VAR> ::= <VAR>spec-case</VAR> [ <CODE>also</CODE> <VAR>spec-case</VAR> ] <small>...</small>
</pre></td></tr></table></P><P>

Redundant specifications (<VAR>redundant-spec</VAR>) are discussed
in <A HREF="jmlrefman_13.html#SEC177">13. Redundancy</A>.
</P><P>

A
<VAR>method-specification</VAR> of a method in a class or interface <EM>must</EM> start with
the keyword <CODE>also</CODE> if (and only if) 
this method is already declared in the parent
type that the current type extends, in one of the interfaces the class
implements, or in a previous file of the refinement sequence for this type.
Starting a <VAR>method-specification</VAR> with the keyword <CODE>also</CODE> is
intended to tell the reader that this specification is in addition to
some specifications of the method that are given in the superclass of
the class, one of the interfaces it implements, or in another file in the
refinement sequence.  
</P><P>

A <VAR>method-specification</VAR> can include any number of
<VAR>spec-case</VAR>s, joined by the keyword <CODE>also</CODE>, 
as well as a <VAR>redundant-spec</VAR>.  
Aside from the <VAR>redundant-spec</VAR>, each of the <VAR>spec-case</VAR>s
specifies a behavior that must be satisfied by 
a correct implementation of the method or constructor.
That is, whenever a call to the specified method or constructor satisfies
the precondition of one of its <VAR>spec-case</VAR>s,
the rest of the clauses in that <VAR>spec-case</VAR> 
must also be satisfied by the implementation
<A HREF="jmlrefman_27.html#BIB22">[Dhara-Leavens96]</A> <A HREF="jmlrefman_27.html#BIB59">[Leavens-Naumann06]</A> <A HREF="jmlrefman_27.html#BIB67">[Leavens06b]</A>
<A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A> <A HREF="jmlrefman_27.html#BIB107">[Wills92b]</A> <A HREF="jmlrefman_27.html#BIB108">[Wing83]</A>.
Model program specification cases, which have no explicit
preconditions, must be satisified by all implementations.
</P><P>

The <VAR>spec-case</VAR>s in a <VAR>method-specification</VAR> can have 
several forms:
</P><P>

<A NAME="IDX1604"></A>
<A NAME="IDX1605"></A>
<A NAME="IDX1606"></A>
<A NAME="IDX1607"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>spec-case</VAR> ::= <VAR>lightweight-spec-case</VAR> | <VAR>heavyweight-spec-case</VAR>
        | <VAR>model-program</VAR>
</pre></td></tr></table></P><P>

Model programs are discussed in <A HREF="jmlrefman_14.html#SEC180">14. Model Programs</A>. 
The remainder of
this chapter concentrates on lightweight and heavyweight 
behavior specification cases.
JML distinguishes between
<UL>
<LI>
<EM>heavyweight specification cases</EM>, which start with one of the
keywords <CODE>behavior</CODE>, <CODE>normal_behavior</CODE> or
<CODE>exceptional_behavior</CODE>, or one of their British variant spellings
keywords <CODE>behaviour</CODE>, <CODE>normal_behaviour</CODE> or
<CODE>exceptional_behaviour</CODE>
(these are also called behavior, normal
behavior, and exceptional behavior specification cases, respectively),
and
<P>

<LI>
<EM>lightweight specification cases</EM>, which do not contain one of
these behavior keywords.
</UL>
<P>

A lightweight specification case is similar to a behavior specification
case, but with different defaults <A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A>.  It also is
possible to desugar all such specification cases into behavior
specification cases <A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A>.
</P><P>

<A NAME="Access Control in Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC83"></A>
<H2> 9.3 Access Control in Specification Cases </H2>
<!--docid::SEC83::-->
<P>

<A NAME="IDX1608"></A>
Heavyweight specification cases may be declared with an explicit
access modifier, according to the following syntax.
</P><P>

<A NAME="IDX1609"></A>
<A NAME="IDX1610"></A>
<A NAME="IDX1611"></A>
<A NAME="IDX1612"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>privacy</VAR> ::= <CODE>public</CODE> | <CODE>protected</CODE> | <CODE>private</CODE>
</pre></td></tr></table></P><P>

The access modifier of a heavyweight specification case 
cannot allow more access than the method being specified.
So a <CODE>public</CODE> method may have a <CODE>private</CODE> behavior specification,
but a <CODE>private</CODE> method may not have a <CODE>public</CODE> public specification.
A heavyweight specification case without an explicit access modifier
is considered to have default (package) access.
</P><P>

Lightweight specification cases have no way to explicitly specify an
access modifier, so their access modifier is implicitly the same
as the method being specified.  For example, a lightweight specification
of a <CODE>public</CODE> method has <CODE>public</CODE> access, implicitly,
but a lightweight specification
of a <CODE>private</CODE> method has <CODE>private</CODE> access, implicitly.
Note that this is a different default than that for heavyweight
specifications, where an omitted access modifier always means package access.
</P><P>

The access modifier of a specification case affects only which annotations
are visible in the specification and does <EM>not</EM> affect
the semantics of a specification case in any other way.
</P><P>

<A NAME="IDX1613"></A>
JML's usual visibility rules apply to specification cases.
So, for example, a public specification case
may only refer to public members,
a protected specification case may refer to both public and protected members,
as long as the protected members are otherwise accessible according to
Java's rules, etc.
See section <A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A>, for more details and examples.
</P><P>

<A NAME="Lightweight Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC84"></A>
<H2> 9.4 Lightweight Specification Cases </H2>
<!--docid::SEC84::-->
<P>

<A NAME="IDX1614"></A>
</P><P>

<A NAME="SEC85"></A>
<H3> Syntax </H3>
<!--docid::SEC85::-->
<P>

The following is the syntax of lightweight specification cases.
These are the most concise specification cases.
</P><P>

<A NAME="IDX1615"></A>
<A NAME="IDX1616"></A>
<A NAME="IDX1617"></A>
<A NAME="IDX1618"></A>
<A NAME="IDX1619"></A>
<A NAME="IDX1620"></A>
<A NAME="IDX1621"></A>
<A NAME="IDX1622"></A>
<A NAME="IDX1623"></A>
<A NAME="IDX1624"></A>
<A NAME="IDX1625"></A>
<A NAME="IDX1626"></A>
<A NAME="IDX1627"></A>
<A NAME="IDX1628"></A>
<A NAME="IDX1629"></A>
<A NAME="IDX1630"></A>
<A NAME="IDX1631"></A>
<A NAME="IDX1632"></A>
<A NAME="IDX1633"></A>
<A NAME="IDX1634"></A>
<A NAME="IDX1635"></A>
<A NAME="IDX1636"></A>
<A NAME="IDX1637"></A>
<A NAME="IDX1638"></A>
<A NAME="IDX1639"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>lightweight-spec-case</VAR> ::= <VAR>generic-spec-case</VAR>
<VAR>generic-spec-case</VAR> ::= [ <VAR>spec-var-decls</VAR> ]
                      <VAR>spec-header</VAR>
                      [ <VAR>generic-spec-body</VAR> ]
        | [ <VAR>spec-var-decls</VAR> ]
          <VAR>generic-spec-body</VAR>
<VAR>generic-spec-body</VAR> ::= <VAR>simple-spec-body</VAR>
        | <CODE>{|</CODE> <VAR>generic-spec-case-seq</VAR> <CODE>|}</CODE>
<VAR>generic-spec-case-seq</VAR> ::= <VAR>generic-spec-case</VAR>
                          [ <CODE>also</CODE> <VAR>generic-spec-case</VAR> ] <small>...</small>
<VAR>spec-header</VAR> ::= <VAR>requires-clause</VAR> [ <VAR>requires-clause</VAR> ] <small>...</small>
<VAR>simple-spec-body</VAR> ::= <VAR>simple-spec-body-clause</VAR>
                     [ <VAR>simple-spec-body-clause</VAR> ] <small>...</small> 
<VAR>simple-spec-body-clause</VAR> ::= <VAR>diverges-clause</VAR>
        | <VAR>assignable-clause</VAR> | <VAR>captures-clause</VAR> 
        | <VAR>when-clause</VAR> | <VAR>working-space-clause</VAR>
        | <VAR>duration-clause</VAR> | <VAR>ensures-clause</VAR>
        | <VAR>signals-only-clause</VAR> | <VAR>signals-clause</VAR>
</pre></td></tr></table>[[[ Is this list missing measured_by, accessible, callable? -- DRC ]]]
</P><P>

As far as the syntax is concerned, the only difference between a
lightweight specification case and a <VAR>behavior-specification-case</VAR>
(see section <A HREF="jmlrefman_9.html#SEC88">9.6 Behavior Specification Cases</A>) is that the latter has the
keyword <CODE>behavior</CODE> and possibly an access control modifier.
</P><P>

A lightweight specification case always has the same access modifier as
the method being specified, 
see <A HREF="jmlrefman_9.html#SEC83">9.3 Access Control in Specification Cases</A>.  
To specify a different access control modifier, one must use a
heavyweight specification.
</P><P>

<A NAME="SEC86"></A>
<H3> Semantics </H3>
<!--docid::SEC86::-->
<P>

A lightweight specification case can be understood as syntactic sugar for
a behavior specification case,
except that the defaults for omitted
specification clauses are different for lightweight specification cases
than for behavior specification cases.
So, for example, apart from the class names,
method <CODE>m</CODE> in class <CODE>Lightweight</CODE> below
<A NAME="IDX1640"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class Lightweight {

    protected boolean P, Q, R;
    protected int X;

    /*@ requires P;
      @  assignable X;
      @  ensures Q;
      @  signals (Exception) R;
      @*/
    protected abstract int m() throws Exception;
}
</pre></td></tr></table>has a specification that is equivalent to that
of method <CODE>m</CODE> in class <CODE>Heavyweight</CODE> below.
<A NAME="IDX1641"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class Heavyweight {

    protected boolean P, Q, R;
    protected int X;

    /*@ protected behavior
      @   requires P;
      @   diverges false;
      @   assignable X;
      @   when \not_specified;
      @   working_space \not_specified;
      @   duration \not_specified;
      @   ensures Q;
      @   signals_only Exception;
      @   signals (Exception) R;
      @*/
    protected abstract int m() throws Exception;
}
</pre></td></tr></table></P><P>

<A NAME="IDX1642"></A>
<A NAME="IDX1643"></A>
As this example illustrates, the default for an omitted clause in a
lightweight specification is <CODE>\not_specified</CODE> for all clauses,
except <CODE>diverges</CODE>, which has a default of <CODE>false</CODE>, and
<CODE>signals</CODE> <A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A>.  The default for an omitted
<CODE>signals</CODE> clause is to only permit the exceptions declared in the
method's header to be thrown.  Thus, if the method declares that
exceptions <CODE>DE1</CODE> and <CODE>DE2</CODE> may be thrown, then the default
for an omitted <CODE>signals</CODE> clause is
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">  signals (Exception e) e instanceof DE1 || e instanceof DE2;
</pre></td></tr></table><A NAME="IDX1644"></A>
It is intended that the meaning of
<CODE>\not_specified</CODE> may vary between different uses of a JML
specification.  For example, a static checker might treat a
<CODE>requires</CODE> clause that is <CODE>\not_specified</CODE> as if it were
<CODE>true</CODE>, while a verification logic may decide to treat it as if it
were <CODE>false</CODE>.
</P><P>

<A NAME="IDX1645"></A>
<A NAME="IDX1646"></A>
<A NAME="IDX1647"></A>
<A NAME="IDX1648"></A>
<A NAME="IDX1649"></A>
A completely omitted specification is taken to be a lightweight
specification.
If the default (zero-argument) constructor of a class is omitted
because its code is omitted,  then its specification defaults to
an assignable clause that allows all the locations that the
default (zero-argument) constructor of its superclass assigns -- in
essence a copy of the superclass's default constructor's assignable clause.
If some other frame is desired, then one has to write the specification,
or at least the code, explicitly.
</P><P>

<A NAME="IDX1650"></A>
<A NAME="IDX1651"></A>
<A NAME="IDX1652"></A>
<A NAME="IDX1653"></A>
A method or constructor with code present has a
<EM>completely omitted</EM> specification if it has no
<VAR>specification-case</VAR>s and does not use 
annotations like <CODE>non_null</CODE> or <CODE>pure</CODE> that add implicit
specifications.
</P><P>

If a method or constructor has code, has a completely omitted
specification, and does not override another method, then 
its meaning is taken as the lightweight specification
<CODE>diverges \not_specified;</CODE>. 
Thus, its meaning can be read
from the lightweight column of table above, except that the diverges
clause is not given its usual default.
This is done so that the default
specification when no specification is given truly says nothing about
the method's behavior.
However, if a method with code and a completely omitted
specification overrides some other method, then its meaning is taken
to be the lightweight specification <CODE>also requires false;</CODE>.  This somewhat
counter-intuitive specification is the unit under specification
conjunction with <CODE>also</CODE>; it is used so as not to
change the meaning of the inherited specification.
</P><P>

If the code is annotated with keywords like <CODE>non_null</CODE> or
<CODE>pure</CODE> that add implicit specifications, then these implicit
specifications are used instead of the default.  Code with such
annotations is considered to have an implicit specification.
</P><P>

<A NAME="Heavyweight Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC87"></A>
<H2> 9.5 Heavyweight Specification Cases </H2>
<!--docid::SEC87::-->
<P>

<A NAME="IDX1654"></A>
</P><P>

There are three kinds of heavyweight specification cases, called
behavior, normal behavior, and exceptional behavior specification
cases, beginning (after an optional privacy modifier) with the one of
the keywords <CODE>behavior</CODE>, <CODE>normal_behavior</CODE>, or
<CODE>exceptional_behavior</CODE>, respectively.
</P><P>

<A NAME="IDX1655"></A>
<A NAME="IDX1656"></A>
<A NAME="IDX1657"></A>
<A NAME="IDX1658"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>heavyweight-spec-case</VAR> ::= <VAR>behavior-spec-case</VAR>
        | <VAR>exceptional-behavior-spec-case</VAR>
        | <VAR>normal-behavior-spec-case</VAR>
</pre></td></tr></table></P><P>

Like lightweight specification cases, normal behavior and exceptional
behavior specification cases can be understood as syntactic sugar for
special kinds of <CODE>behavior</CODE> specification cases
<A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A>.
</P><P>

<A NAME="Behavior Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC88"></A>
<H2> 9.6 Behavior Specification Cases </H2>
<!--docid::SEC88::-->
<P>

<A NAME="IDX1659"></A>
<A NAME="IDX1660"></A>
The behavior specification case is the most general form of
specification case.  All other forms of specification cases simply
provide some syntactic sugar for special kinds of <CODE>behavior</CODE>
specification cases.
</P><P>

<A NAME="SEC89"></A>
<H3> Syntax  </H3>
<!--docid::SEC89::-->
<P>

<A NAME="IDX1661"></A>
<A NAME="IDX1662"></A>
As far as the syntax is concerned, the only difference between a
<CODE>behavior</CODE> specification case and a lightweight one is 
the optional access control modifier, <VAR>privacy</VAR>,
and the keyword <CODE>behavior</CODE> (or the British variant, <CODE>behaviour</CODE>).
One can use either the British or the American spelling of this
keyword, although for historical reasons most examples will use the
American spelling.
</P><P>

<A NAME="IDX1663"></A>
<A NAME="IDX1664"></A>
<A NAME="IDX1665"></A>
<A NAME="IDX1666"></A>
<A NAME="IDX1667"></A>
<A NAME="IDX1668"></A>
<A NAME="IDX1669"></A>
<A NAME="IDX1670"></A>
<A NAME="IDX1671"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>behavior-spec-case</VAR> ::= [ <VAR>privacy</VAR> ] [ <CODE>code</CODE> ] <VAR>behavior-keyword</VAR>
                       <VAR>generic-spec-case</VAR>
<VAR>behavior-keyword</VAR> ::= <CODE>behavior</CODE> | <CODE>behaviour</CODE>
</pre></td></tr></table></P><P>

See section <A HREF="jmlrefman_15.html#SEC192">15.2 Code Contracts</A>, for details of the semantics of
<VAR>behavior-spec-case</VAR>s that use the <CODE>code</CODE> keyword.
</P><P>

<A NAME="SEC90"></A>
<H3> Semantics  </H3>
<!--docid::SEC90::-->
<P>

To explain the semantics of a behavior specification case we make a
distinction between flat and nested specification cases:
<UL>
<LI>
<EM>Flat</EM> specification cases are of the form
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"> <CODE>behavior</CODE> [ <VAR>spec-var-decls</VAR> ] [ <VAR>spec-header</VAR> ] <VAR>simple-spec-body</VAR> 
</pre></td></tr></table>A flat specification case is just made up of a sequence of method
specification clauses, ie. <CODE>require</CODE>, <CODE>ensures</CODE>, etc. clauses,
and its semantics is explained directly in 
<A HREF="jmlrefman_9.html#SEC92">9.6.1 Semantics of flat behavior specification cases</A>.
<P>

<LI>
<EM>Nested</EM> specification cases are all other specification cases.
They use the special brackets <CODE>{|</CODE> and <CODE>|}</CODE> to nest
specification clauses and possibly also <CODE>also</CODE> inside these
brackets to join several specification cases.
<P>

A nested specification case can be syntactically desugared into a list
of one or more simple specification cases, joined by the <CODE>also</CODE>
keyword <A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A>.  
This is explained in <A HREF="jmlrefman_9.html#SEC96">9.6.5 Semantics of nested behavior specification cases</A>.
</UL>
<P>

<A NAME="SEC91"></A>
<H3> Invariants and constraints </H3>
<!--docid::SEC91::-->
<P>

The semantics of a behavior specification case for a method or
constructor in a class depends on the invariants and constraints that
have been specified.  This is discussed in <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A> and
<A HREF="jmlrefman_8.html#SEC70">8.3 Constraints</A>.  In a nutshell, methods must preserve invariants
and respect constraints, and constructors must establish invariants.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC92">9.6.1 Semantics of flat behavior specification cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC93">9.6.2 Non-helper methods</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC94">9.6.3 Non-helper constructors</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC95">9.6.4 Helper methods and constructors</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC96">9.6.5 Semantics of nested behavior specification cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Semantics of flat behavior specification cases"></A>
<HR SIZE="6">
<A NAME="SEC92"></A>
<H3> 9.6.1 Semantics of flat behavior specification cases </H3>
<!--docid::SEC92::-->
<P>

Below we explain the semantics of a simple <VAR>behavior-spec-case</VAR>
case with precisely 
one <CODE>requires</CODE> clause,
one <CODE>diverges</CODE> clause,
one <CODE>measured_by</CODE> clause,
one <CODE>assignable</CODE> clause,
one <CODE>accessible</CODE> clause,
one <CODE>callable</CODE> clause,
one <CODE>when</CODE> clause,
one <CODE>ensures</CODE> clause,
one <CODE>duration</CODE> clause,
one <CODE>working_space</CODE> clause,
one <CODE>signals_only</CODE> clause,
and
one <CODE>signals</CODE> clause.
</P><P>

A <CODE>behavior</CODE> specification case can contain any number of these
clauses, and there are defaults that allow any of them to be omitted.
However, as explained in <A HREF="jmlrefman_9.html#SEC100">9.9 Method Specification Clauses</A>, any
<CODE>behavior</CODE> specification case is equivalent with a <CODE>behavior</CODE>
specification case of this form.
</P><P>

<A NAME="Non-helper methods"></A>
<HR SIZE="6">
<A NAME="SEC93"></A>
<H3> 9.6.2 Non-helper methods </H3>
<!--docid::SEC93::-->
<P>

<A NAME="IDX1672"></A>
<A NAME="IDX1673"></A>
<A NAME="IDX1674"></A>
<A NAME="IDX1675"></A>
<A NAME="IDX1676"></A>
<A NAME="IDX1677"></A>
<A NAME="IDX1678"></A>
<A NAME="IDX1679"></A>
<A NAME="IDX1680"></A>
<A NAME="IDX1681"></A>
<A NAME="IDX1682"></A>
<A NAME="IDX1683"></A>
<A NAME="IDX1684"></A>
<A NAME="IDX1685"></A>
<A NAME="IDX1686"></A>
<A NAME="IDX1687"></A>
<A NAME="IDX1688"></A>
<A NAME="IDX1689"></A>
<A NAME="IDX1690"></A>
Consider a non-<CODE>helper</CODE> instance method <CODE>m</CODE>, and a
specification case of the following form.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  behavior
    forall <I>T1</I> <I>x1</I>; <small>...</small> forall <I>Tn</I> <I>xn</I>;
    old <I>U1</I> <I>y1</I> = <I>F1</I>; <small>...</small> old <I>Uk</I> <I>yk</I> = <I>Fk</I>;
    requires <I>P</I>;
    measured_by <I>Mbe</I> <CODE>if</CODE> <I>Mbp</I>;
    diverges <I>D</I>;
    when <I>W</I>;
    accessible <I>R</I>;
    assignable <I>A</I>;
    callable <I>p1</I>(<small>...</small>), <small>...</small>, <I>pl</I>(<small>...</small>);
    captures <I>Z</I>;
    ensures <I>Q</I>;
    signals_only <I>E1</I>, <small>...</small>, <I>Eo</I>;
    signals (<I>E</I> <I>e</I>) <I>S</I>;
    working_space <I>Wse</I> <CODE>if</CODE> <I>Wsp</I>;
    duration <I>De</I> <CODE>if</CODE> <I>Dp</I>;
</pre></td></tr></table></P><P>

The meaning of this specification case is as follows.
</P><P>

Consider a particular call of the method <I>m</I>.
</P><P>

<A NAME="IDX1691"></A>
<A NAME="IDX1692"></A>
<A NAME="IDX1693"></A>
The state of the program after passing parameters to <I>m</I>, but before
running any of the code of <I>m</I> is called the <EM>pre-state</EM> of the
method call.
</P><P>

Suppose all applicable invariants hold in the pre-state of this call.
</P><P>

<A NAME="IDX1694"></A>
For every possible value of the variables declared in the
<CODE>forall</CODE> clauses, <I>x1</I>, <small>...</small>, <I>xn</I>, the following must be
true.  (If there are no <CODE>forall</CODE> clauses, then the following just
has to hold all by itself.)
</P><P>

<A NAME="IDX1695"></A>
Suppose that the variable <I>y1</I> is bound to the pre-state value of
<I>F1</I> in the pre-state (i.e., the beginning of the method, after
parameter passing), and in turn each of the <CODE>old</CODE> variable
declarations are bound to the values of the corresponding expressions,
also evaluated in the pre-state, and finally <I>yk</I> is bound to the value
of <I>Fk</I> in the pre-state.  These bindings can depend on previously
defined <CODE>old</CODE> variable declarations in the specification case.
(If there are no <CODE>old</CODE> clauses, then no such variables are
bound.)
<A NAME="IDX1696"></A>
We call the state with such bindings in place the <EM>augmented pre-state</EM>.
</P><P>

<A NAME="IDX1697"></A>
Suppose also that with these binding
(i.e., in the augmented pre-state), that the precondition, <I>P</I>, from
the <CODE>requires</CODE> clause, holds.
</P><P>

If the method has a <CODE>measured_by</CODE> clause,
and if the predicate in the <CODE>measured_by</CODE> clause,
<I>Mbp</I>, is true in the augmented pre-state, 
and if this call is in the control flow of another instance of this
method, <I>Caller</I>,
then the value of the expression <I>Mbe</I> in this call's augmented pre-state
must be non-negative and strictly less than the value of
<I>Mbe</I> in the pre-state of <I>Caller</I>.
(If the <CODE>measured_by</CODE> clause is omitted, there is no such requirement.)
For example, consider a method <CODE>fib</CODE> that calls itself directly
and has an integer parameter <CODE>n</CODE> and for which the
<CODE>measured_by</CODE> clause has <CODE>n</CODE> as its expression (<I>Mbe</I>),
and the default predicate (<I>Mbp</I>) is true;
then recursive calls of <CODE>fib</CODE> that appear in the body of
<CODE>fib</CODE> must have actual argument exprssions whose value is
(non-negative and)
strictly less than <CODE>n</CODE>, such as <CODE>n-1</CODE> and <CODE>n-2</CODE>.<A NAME="DOCF8" HREF="jmlrefman_fot.html#FOOT8">(8)</A>
</P><P>

Then one of the following must also hold:
<UL>
<LI>
<A NAME="IDX1698"></A>
the <CODE>diverges</CODE> predicate, <I>D</I>, holds in the augmented pre-state
and the execution of the method does not terminate (i.e., it loops
forever or the Java virtual machine exits in such a way that the method call
does not return or throw an exception).  (If the <CODE>diverges</CODE> clause
is omitted, then the default for <I>D</I> is <CODE>false</CODE>, and hence
these outcomes are effectively prohibited.)
or
<P>

<LI>
<A NAME="IDX1699"></A>
<A NAME="IDX1700"></A>
the Java virtual machine throws an error (i.e., an instance of
<CODE>java.lang.Throwable</CODE> whose type does not inherit from
<CODE>java.lang.Exception</CODE>, usually an instance of <CODE>java.lang.Error</CODE>), or
<P>

<LI>
<A NAME="IDX1701"></A>
<A NAME="IDX1702"></A>
<A NAME="IDX1703"></A>
the method terminates by returning or throwing an exception,
reaching a state called its <EM>post-state</EM>,
in which all of the following hold.
<UL>
<LI>
<A NAME="IDX1704"></A>
<A NAME="IDX1705"></A>
<A NAME="IDX1706"></A>
<A NAME="IDX1707"></A>
The method's execution only reaches its commit point (a label in the
method body with the name "<CODE>commit</CODE>" [Rogriguez-etal05]) in a state such
that the <CODE>when</CODE> clause's condition, <I>W</I>, holds.
(If the condition does not hold,
then the method's execution waits for a concurrent thread to make it
true, and then proceeds.  There is no guarantee that the method will
proceed the first time this condition holds, so the condition may have
to hold many times before the thread may proceed to its commit point.)
(If the <CODE>when</CODE> clause is omitted, there is no need to have a
commit point in the method, and the method need not wait for the
execution of concurrent threads.)
<P>

<LI>
<A NAME="IDX1708"></A>
During execution of the method (which includes all directly and
indirectly called methods and constructors),
only locations that either did not exist in the pre-state,
that are local to the method (including the method's formal parameters),
or that are either named in the lists <I>R</I> and <I>A</I> found in the 
<CODE>accessible</CODE> and <CODE>assignable</CODE> clauses
or that are dependees (see section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>) of such locations,
are read from.
The set of locations named by the accessible and assignable clauses
(and hence the elements of their data groups) are computed in the pre-state.
(If the <CODE>accessible</CODE> clause is omitted, it defaults to
<CODE>accessible \everything;</CODE>, which allows all locations to be accessed.)
<P>

<LI>
<A NAME="IDX1709"></A>
During execution of the method,
only locations that either did not exist in the pre-state,
that are local to the method,
or that are either named by the <CODE>assignable</CODE> clause's list, <I>A</I>,
or are dependees (see section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>) of such locations,
are assigned to.
The set of locations named by the assignable clause (and hence the
elements of their data groups) are computed in the pre-state.
(If the <CODE>assignable</CODE> clause is omitted, it defaults to
<CODE>assignable \everything;</CODE>, which allows all locations to be assigned.)
<P>

<LI>
<A NAME="IDX1710"></A>
During execution of the method,
the only methods and constructors called are those listed in the
<CODE>callable</CODE> clause's list <I>p1</I>, <small>...</small>, <I>pl</I>.
(If the <CODE>callable</CODE> clause is omitted, it defaults to
<CODE>callable \everything;</CODE>, which allows all methods and
constructors to be called.)
<P>

The form <I>p</I><CODE>.*</CODE> refers to all methods of the object denoted by <I>p</I>.
</P><P>

<LI>
<A NAME="IDX1711"></A>
<A NAME="IDX1712"></A>
During execution of the method, of the formal parameters whose type is
a reference type, only those listed in the
<CODE>captures</CODE> clause's list, <I>Z</I>, may be assigned to fields of
some object or to array elements.
(References in formals may freely be assigned to local variables,
however, as these are "borrowed" but not captured <A HREF="jmlrefman_27.html#BIB8">[Boyland00]</A>.
If the <CODE>captures</CODE> clause is omitted, then all such formals may
be assigned freely.)
<P>

<LI>
<A NAME="IDX1713"></A>
If the execution of the method terminates by returning normally,
then the normal postcondition, <I>Q</I>, given in the <CODE>ensures</CODE>
clause, holds in the post-state.
<P>

<LI>
<A NAME="IDX1714"></A>
<A NAME="IDX1715"></A>
If the execution of the method terminates by throwing an exception of
some type <I>Ea</I> that is a subtype of <CODE>java.lang.Exception</CODE>, then:
<UL>
<LI>
<A NAME="IDX1716"></A>
the type <I>Ea</I> must be a subtype of some type in the list <I>E1</I>,
<small>...</small>, <I>Eo</I>, listed in the <CODE>signals_only</CODE> clause (this list
of types has as its default the list in the method's <CODE>throws</CODE>
clause), and 
<P>

<LI>
<A NAME="IDX1717"></A>
if <I>Ea</I> is a subtype of the type <I>E</I> given in the <CODE>signals</CODE>
clause, then the exceptional postcondition <I>R</I> must hold in the
post-state, augmented by a binding from the variable <I>e</I> to 
the exception object thrown.
</UL>
<P>

<LI>
All applicable invariants and history constraints hold in the
post-state.
<P>

<LI>
<A NAME="IDX1718"></A>
If the predicate in the <CODE>working_space</CODE> clause,
<I>Wsp</I>, was true in the augmented pre-state, then
the method execution had available to it the amount of heap space, in bytes,
<I>Wse</I> <A HREF="jmlrefman_27.html#BIB49">[Krone-Ogden-Sitaraman03]</A>.
(Note that the expression <I>Wse</I> may depend on post-state values
so this expression is conceptually evaluated in the post-state,
although it may use <CODE>\old()</CODE> to refer to pre-state values.
If the <CODE>working_space</CODE> clause is omitted, there is no restriction
placed on the maximum space that the method call may during its execution.)
<P>

<LI>
<A NAME="IDX1719"></A>
If the predicate in the <CODE>duration</CODE> clause,
<I>Dp</I>, was true in the augmented pre-state, then
the method execution used no more than the number of virtual machine
cycles given by the expression <I>De</I> <A HREF="jmlrefman_27.html#BIB49">[Krone-Ogden-Sitaraman03]</A>.
(Note that the expression <I>De</I> may depend on post-state values
so this expression is conceptually evaluated in the post-state,
although it may use <CODE>\old()</CODE> to refer to pre-state values.
If the <CODE>duration</CODE> clause is omitted, there is no restriction
placed on the maximum number of virtual machine cycles that the call
may use during its execution.)
</UL>
</UL>
<P>

In all of these clauses, the value of a formal parameter is always
considered to be the value they had in the pre-state.
That is the actual post-state value they take in an execution is not
considered, as explained in See section <A HREF="jmlrefman_9.html#SEC108">9.9.6 Parameters in Postconditions</A>.
</P><P>

<A NAME="Non-helper constructors"></A>
<HR SIZE="6">
<A NAME="SEC94"></A>
<H3> 9.6.3 Non-helper constructors </H3>
<!--docid::SEC94::-->
<P>

The semantics of a flat specification case for a (non-<CODE>helper</CODE>) 
constructor is the same as that for a (non-<CODE>helper</CODE>) method given 
above, except that:
<UL>
<LI>
any instance invariants of the object being initialized by the
constructor are not assumed to hold in the precondition,
<P>

<LI>
any instance constraints do not have to be established as implicit
part of the postcondition of the constructor.
</UL>
These two differences are also discussed in <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A> 
and <A HREF="jmlrefman_8.html#SEC70">8.3 Constraints</A>.
<P>

<A NAME="Helper methods and constructors"></A>
<HR SIZE="6">
<A NAME="SEC95"></A>
<H3> 9.6.4 Helper methods and constructors </H3>
<!--docid::SEC95::-->
<P>

The semantics of a flat specification case for a helper method 
(or constructor) is the same as that for a non-helper method 
(or constructor) given above,
except that:
<UL>
<LI>
the instance invariants for the current object
and the static invariants for the current class
are not assumed to hold in the pre-state, 
and do not have to be established in the post-state.
<P>

<LI>
the instance constraints for current object
and the static constraints for the current class
do not have to be established in the post-state
</UL>
These differences are also discussed in <A HREF="jmlrefman_8.html#SEC65">8.2 Invariants</A> 
and <A HREF="jmlrefman_8.html#SEC70">8.3 Constraints</A>.
<P>

<A NAME="Semantics of nested behavior specification cases"></A>
<HR SIZE="6">
<A NAME="SEC96"></A>
<H3> 9.6.5 Semantics of nested behavior specification cases </H3>
<!--docid::SEC96::-->
<P>

We now explain how all behavior specification cases can be desugared
into a list of one or more flat specification cases joined by the
<CODE>also</CODE> keyword <A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A>.  The semantics of a behavior
specification case is then simply the semantics of this desugared
version. 
</P><P>

The desugaring is as follows.  Consider a specification of the form.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><VAR>spec-var-decls</VAR>
<VAR>spec-header</VAR>
{|
    <VAR>GenSpecCase1</VAR> 
  also 
    <small>...</small> 
  also 
    <VAR>GenSpecCasen</VAR> 
|}
</pre></td></tr></table></P><P>

The above desugars to the following.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    <VAR>spec-var-decls</VAR>
    <VAR>spec-header</VAR>
    <VAR>GenSpecCase1</VAR>
  also 
    <small>...</small> 
  also 
    <VAR>spec-var-decls</VAR>
    <VAR>spec-header</VAR>
    <VAR>GenSpecCasen</VAR>
</pre></td></tr></table></P><P>

In the above desugaring either the <VAR>spec-var-decls</VAR> or the
<VAR>spec-header</VAR> (or both) may be omitted.
</P><P>

The meaning of the desugared list of specification cases is
explained in <A HREF="jmlrefman_9.html#SEC82">9.2 Organization of Method Specifications</A>.
The meaning of a single simple specification case is explained in
<A HREF="jmlrefman_9.html#SEC92">9.6.1 Semantics of flat behavior specification cases</A>.
</P><P>

<A NAME="Normal Behavior Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC97"></A>
<H2> 9.7 Normal Behavior Specification Cases </H2>
<!--docid::SEC97::-->
<P>

<A NAME="IDX1720"></A>
A <CODE>normal_behavior</CODE> specification case is just syntactic sugar for
a <CODE>behavior</CODE> specification case with an implicit <CODE>signals</CODE>
clause
<TABLE><tr><td>&nbsp;</td><td class=example><pre>    signals (java.lang.Exception) false;
</pre></td></tr></table>ruling out abrupt termination, i.e., the throwing of any exception.
Note that this includes unchecked exceptions, since in Java,
<CODE>RuntimeException</CODE> is a subclass of <CODE>Exception</CODE>.
</P><P>

The following gives the syntax of the body of a normal behavior
specification case.
</P><P>

<A NAME="IDX1721"></A>
<A NAME="IDX1722"></A>
<A NAME="IDX1723"></A>
<A NAME="IDX1724"></A>
<A NAME="IDX1725"></A>
<A NAME="IDX1726"></A>
<A NAME="IDX1727"></A>
<A NAME="IDX1728"></A>
<A NAME="IDX1729"></A>
<A NAME="IDX1730"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>normal-behavior-spec-case</VAR> ::= [ <VAR>privacy</VAR> ] [ <CODE>code</CODE> ] <VAR>normal-behavior-keyword</VAR>
                              <VAR>normal-spec-case</VAR>
<VAR>normal-behavior-keyword</VAR> ::= <CODE>normal_behavior</CODE> | <CODE>normal_behaviour</CODE>
<VAR>normal-spec-case</VAR> ::= <VAR>generic-spec-case</VAR>
</pre></td></tr></table></P><P>

As far as syntax is concerned, the only difference 
between a <VAR>normal-spec-case</VAR> and a <VAR>generic-spec-case</VAR>
is that normal behavior specification cases
cannot include <VAR>signals-clause</VAR>s or <VAR>signals-only-clause</VAR>s.
</P><P>

The semantics of a normal behavior specification case is the same as the
corresponding
<CODE>behavior</CODE> specification case
(see section <A HREF="jmlrefman_9.html#SEC88">9.6 Behavior Specification Cases</A>)
with the addition of the following
<VAR>signals-clause</VAR>
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    signals (java.lang.Exception) false;
</pre></td></tr></table></P><P>

So a normal behavior specification case specifies a precondition which
guarantees normal termination; i.e., it prohibits the method from
throwing an exception.
</P><P>

<A NAME="Exceptional Behavior Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC98"></A>
<H2> 9.8 Exceptional Behavior Specification Cases </H2>
<!--docid::SEC98::-->
<P>

<A NAME="IDX1731"></A>
The following gives the syntax of the body of an exceptional behavior
specification case.
</P><P>

<A NAME="IDX1732"></A>
<A NAME="IDX1733"></A>
<A NAME="IDX1734"></A>
<A NAME="IDX1735"></A>
<A NAME="IDX1736"></A>
<A NAME="IDX1737"></A>
<A NAME="IDX1738"></A>
<A NAME="IDX1739"></A>
<A NAME="IDX1740"></A>
<A NAME="IDX1741"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>exceptional-behavior-spec-case</VAR> ::= [ <VAR>privacy</VAR> ] [ <CODE>code</CODE> ] <CODE>exceptional-behavior-keyword</CODE>
                                   <VAR>exceptional-spec-case</VAR>
<VAR>exceptional-behavior-keyword</VAR> ::= <CODE>exceptional_behavior</CODE> | <CODE>exceptional_behaviour</CODE>
<VAR>exceptional-spec-case</VAR> ::= <VAR>generic-spec-case</VAR>
</pre></td></tr></table></P><P>

As far as syntax is concerned, the only difference 
between an <VAR>exceptional-spec-case</VAR> and a <VAR>generic-spec-case</VAR>
is that exceptional behavior specification cases
cannot include <VAR>ensures-clause</VAR>s.
</P><P>

The semantics of an exceptional behavior specification case is the same
as the corresponding behavior specification case
(see section <A HREF="jmlrefman_9.html#SEC88">9.6 Behavior Specification Cases</A>)
with the addition of the following
<CODE>ensures</CODE> clause.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    ensures false;
</pre></td></tr></table></P><P>

So an exceptional behavior specification case specifies a precondition
which guarantees that the method throws an exception, if it terminates, i.e., a
precondition which prohibits the method from terminating normally.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC99">9.8.1 Pragmatics of Exceptional Behavior Specifications Cases</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Pragmatics of Exceptional Behavior Specification Cases"></A>
<HR SIZE="6">
<A NAME="SEC99"></A>
<H3> 9.8.1 Pragmatics of Exceptional Behavior Specifications Cases </H3>
<!--docid::SEC99::-->
<P>

Note that an exceptional behavior specification case says that some
exception <EM>must</EM> be thrown if its precondition is met (assuming
the diverges clause predicate is <CODE>false</CODE>, as is the default.)
Beware of the difference between specifying that an exception
<EM>must</EM> be thrown and specifying that an exception <EM>may</EM> be
thrown. To specify that an exception <EM>may</EM> be thrown you should
<EM>not</EM> use an exceptional behavior, but should instead use a
behavior specification case <A HREF="jmlrefman_27.html#BIB54">[Leavens-Baker-Ruby06]</A>.
</P><P>

For example, the following method specification
<A NAME="IDX1742"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class InconsistentMethodSpec {

    /** A specification that can't be satisfied. */
    /*@  public normal_behavior
     @    requires z &#60;= 99;
     @    assignable \nothing;
     @    ensures \result &#62; z;
     @ also
     @  public exceptional_behavior
     @    requires z &#60; 0;
     @    assignable \nothing;
     @    signals (IllegalArgumentException) true;
     @*/
    public abstract int cantBeSatisfied(int z)
        throws IllegalArgumentException;
}
</pre></td></tr></table>is <EM>inconsistent</EM> because the preconditions <CODE>z &#60;= 99</CODE> and
<CODE>z &#60; 0</CODE> overlap, for example when <CODE>z</CODE> is <CODE>-1</CODE>.  When
both preconditions hold then the exceptional behavior case specifies
that an exception <EM>must</EM> be thrown and the normal behavior case
specifies that an exception <EM>must not</EM> be thrown, but the
implementation cannot both throw and not throw an exception.
</P><P>

<A NAME="IDX1743"></A>
Similarly, multiple exceptional specification cases with overlapping 
preconditions may give rise to an inconsistent specification.
For example, the following method specification
<A NAME="IDX1744"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class InconsistentMethodSpec2 {

    /** A specification that can't be satisfied. */
    /*@  public exceptional_behavior
     @     requires z &#60; 99;
     @     assignable \nothing;
     @     signals_only IllegalArgumentException;
     @ also
     @   public exceptional_behavior
     @     requires z &#62; 0;
     @     assignable \nothing;
     @     signals_only NullPointerException;
     @*/
    public abstract int cantBeSatisfied(int z)
        throws IllegalArgumentException, NullPointerException;
}
</pre></td></tr></table>is inconsistent because, again, the two preconditions overlap, and the
<CODE>signals_only</CODE> clauses do not permit the same exception to be
thrown in both cases.
</P><P>

<A NAME="IDX1745"></A>
There is an important distinction to be made between the
<CODE>signals</CODE> and the <CODE>signals_only</CODE> clauses in JML.
The <CODE>signals_only</CODE> clause says what exceptions may be thrown
(when the specification case's precondition is met); this clause does
not say anything about the state of the exception object or other
locations in the system.  On the other hand, the <CODE>signals</CODE> clause
only describes what must be true of the system state when an exception
is thrown, and does not say anything about what exceptions may be thrown.
For example, consider the following specification.
<A NAME="IDX1746"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class SignalsClause {

    /*@ signals (IllegalArgumentException) x &#60; 0;
      @ signals (NullPointerException) x &#60; 0;
      @*/
    public abstract int notPrecise(int x) throws RuntimeException;
}
</pre></td></tr></table>The above allows a method to throw either an <CODE>IllegalArgumentException</CODE> or
a <CODE>NullPointerException</CODE> when <CODE>x</CODE> is less than 0, but in
that condition the method might also throw a different exception
altogether, as long as that exception was permitted by the method's
declaration header.  The only thing ruled out by this specification is
throwing either a <CODE>IllegalArgumentException</CODE> or
a <CODE>NullPointerException</CODE> when <CODE>x</CODE> is not less than 0.
Thus from such a specification one may draw the conclusion that
<CODE>x &#60; 0</CODE> only when one of these two exceptions is thrown.
</P><P>

Therefore, if one just wants to specify the exceptions that are permitted
to be thrown in a specific situation, 
one should use the <CODE>signals_only</CODE> clause.
</P><P>

<A NAME="Method Specification Clauses"></A>
<HR SIZE="6">
<A NAME="SEC100"></A>
<H2> 9.9 Method Specification Clauses </H2>
<!--docid::SEC100::-->
<P>

The different kinds of clauses that can be used in method
specifications are discussed in this section.  
See section <A HREF="jmlrefman_9.html#SEC84">9.4 Lightweight Specification Cases</A>, 
for the overall syntax that ties these clauses together.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC101">9.9.1 Specification Variable Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC105">9.9.3 Ensures Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC106">9.9.4 Signals Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC107">9.9.5 Signals-Only Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC108">9.9.6 Parameters in Postconditions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC109">9.9.7 Diverges Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC110">9.9.8 When Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC111">9.9.9 Assignable Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC112">9.9.10 Accessible Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC113">9.9.11 Callable Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC114">9.9.12 Measured By Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC115">9.9.13 Captures Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC116">9.9.14 Working Space Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC117">9.9.15 Duration Clauses</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Specification Variable Declarations"></A>
<HR SIZE="6">
<A NAME="SEC101"></A>
<H3> 9.9.1 Specification Variable Declarations </H3>
<!--docid::SEC101::-->
<P>

The syntax of <VAR>spec-var-decls</VAR> is as follows.
</P><P>

<A NAME="IDX1747"></A>
<A NAME="IDX1748"></A>
<A NAME="IDX1749"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>spec-var-decls</VAR> ::= <VAR>forall-var-decls</VAR> [ <VAR>old-var-decls</VAR> ]
        | <VAR>old-var-decls</VAR>
</pre></td></tr></table>The scope of the variables declared in the <VAR>spec-var-decls</VAR> is the
entire specification case in which they appear.  The two types of such
declarations are described below.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC102">9.9.1.1 Forall Variable Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="jmlrefman_9.html#SEC103">9.9.1.2 Old Variable Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Forall Variable Declarations"></A>
<HR SIZE="6">
<A NAME="SEC102"></A>
<H4> 9.9.1.1 Forall Variable Declarations </H4>
<!--docid::SEC102::-->
<P>

The syntax of the <VAR>forall-var-decls</VAR> is as follows.
</P><P>

<A NAME="IDX1750"></A>
<A NAME="IDX1751"></A>
<A NAME="IDX1752"></A>
<A NAME="IDX1753"></A>
<A NAME="IDX1754"></A>
<A NAME="IDX1755"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>forall-var-decls</VAR> ::= <VAR>forall-var-declarator</VAR> [ <VAR>forall-var-declarator</VAR> ] <small>...</small> 
<VAR>forall-var-declarator</VAR> ::= <CODE>forall</CODE> [ <VAR>bound-var-modifiers</VAR> ] <VAR>quantified-var-declarator</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

When a <VAR>forall-var-declarator</VAR> is used, it specifies that the
specification case that follows must hold for every possible value of
the declared variables.  In other words, it is a universal
quantification over the specification case.
</P><P>

Note that if such variables are used in preconditions, then
they can be thought to range over all values that satisfy the preconditions.  The bound variable may not rename earlier bound 
variables in the specification, nor the formal parameters of the
method declaration.
</P><P>

<A NAME="Old Variable Declarations"></A>
<HR SIZE="6">
<A NAME="SEC103"></A>
<H4> 9.9.1.2 Old Variable Declarations </H4>
<!--docid::SEC103::-->
<P>

The syntax of the <VAR>old-var-decls</VAR> is as follows.
See section <A HREF="jmlrefman_7.html#SEC61">7.1.2.2 Type-Specs</A>, for the syntax of <VAR>type-spec</VAR>.
[[[Give cross ref for <VAR>spec-variable-declarators</VAR> when ready.]]]
</P><P>

<A NAME="IDX1756"></A>
<A NAME="IDX1757"></A>
<A NAME="IDX1758"></A>
<A NAME="IDX1759"></A>
<A NAME="IDX1760"></A>
<A NAME="IDX1761"></A>
<A NAME="IDX1762"></A>
<A NAME="IDX1763"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>old-var-decls</VAR> ::= <VAR>old-var-declarator</VAR> [ <VAR>old-var-declarator</VAR> ] <small>...</small>
<VAR>old-var-declarator</VAR> ::= <CODE>old</CODE> [ <VAR>bound-var-modifiers</VAR> ] <VAR>type-spec</VAR> <VAR>spec-variable-declarators</VAR> <CODE>;</CODE>
</pre></td></tr></table></P><P>

An <VAR>old-var-declarator</VAR> allows abbreviation within a specification
case.  The names defined in the <VAR>spec-variable-declarators</VAR> can be
used throughout the specification case for the values of their
initializers.  As the name suggests, the expressions are evaluated in
the method's pre-state.  The bound variable may not rename earlier bound 
variables in the specification, nor the formal parameters of the
method declaration.
</P><P>

[[[Example]]]
</P><P>

<A NAME="Requires Clauses"></A>
<HR SIZE="6">
<A NAME="SEC104"></A>
<H3> 9.9.2 Requires Clauses </H3>
<!--docid::SEC104::-->
<P>

<A NAME="IDX1764"></A>
<A NAME="IDX1765"></A>
A requires clause specifies a precondition of
method or constructor.  Its syntax is as follows.
</P><P>

<A NAME="IDX1766"></A>
<A NAME="IDX1767"></A>
<A NAME="IDX1768"></A>
<A NAME="IDX1769"></A>
<A NAME="IDX1770"></A>
<A NAME="IDX1771"></A>
<A NAME="IDX1772"></A>
<A NAME="IDX1773"></A>
<A NAME="IDX1774"></A>
<A NAME="IDX1775"></A>
<A NAME="IDX1776"></A>
<A NAME="IDX1777"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>requires-clause</VAR> ::= <VAR>requires-keyword</VAR> <VAR>pred-or-not</VAR> <CODE>;</CODE>
        | <VAR>requires-keyword</VAR> <CODE>\same</CODE> <CODE>;</CODE>
<VAR>requires-keyword</VAR> ::= <CODE>requires</CODE> | <CODE>pre</CODE> 
        | <CODE>requires_redundantly</CODE> | <CODE>pre_redundantly</CODE>
<VAR>pred-or-not</VAR> ::= <VAR>predicate</VAR> | <CODE>\not_specified</CODE>
</pre></td></tr></table></P><P>

The <VAR>predicate</VAR> in a <CODE>requires</CODE> clause can
refer to any visible fields and to the parameters of the method.
See section <A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A>, for more details on visibility
in JML.
</P><P>

Any number of requires clauses can be included a single 
specification case.
Multiple requires clauses in a specification case
mean the same as a single requires clause whose precondition predicate
is the <EM>conjunction</EM> of these precondition predicates in
the given requires clauses.
For example,
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  requires <I>P</I>;
  requires <I>Q</I>;
</pre></td></tr></table>means the same thing as:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  requires <I>P</I> &#38;&#38; <I>Q</I>;
</pre></td></tr></table></P><P>

<A NAME="IDX1778"></A>
<A NAME="IDX1779"></A>
When a requires clause is omitted in a specification case,
a default requires clause is used.
For a lightweight specification case, the default precondition is
<CODE>\not_specified</CODE>.
The default precondition for a heavyweight specification case is
<CODE>true</CODE>.
</P><P>

<A NAME="IDX1780"></A>
At most one precondition in a specification case can use <CODE>\same</CODE>,
and <CODE>\same</CODE> cannot be used in the only specification case for a
method unless the method is an override.
Similarly, <CODE>\same</CODE> cannot be used in the only specification case for a
constructor or a static method.
Another restriction is that <CODE>\same</CODE> cannot be used in a requires
clause of a nested specification case
(see section <A HREF="jmlrefman_9.html#SEC96">9.6.5 Semantics of nested behavior specification cases</A>). 
</P><P>

When the precondition is <CODE>\same</CODE> in a specification case,
it means that the specification
case being written has, effectively, the same precondition as that
specified in the other (non-<CODE>\same</CODE>) specification cases.
That is, <CODE>\same</CODE> stands for
the disjunction of the preconditions in all non-<CODE>\same</CODE>
specification cases of the method's specification from the current class
together with the inherited specification cases defined in its supertypes 
(i.e., in its superclasses and implemented interfaces). 
</P><P>

<A NAME="Ensures Clauses"></A>
<HR SIZE="6">
<A NAME="SEC105"></A>
<H3> 9.9.3 Ensures Clauses </H3>
<!--docid::SEC105::-->
<P>

<A NAME="IDX1781"></A>
<A NAME="IDX1782"></A>
<A NAME="IDX1783"></A>
An ensures clause specifies a normal postcondition, i.e., a property
that is guaranteed to hold at the end of the method (or constructor)
invocation in the case that this method (or constructor) invocation
returns without throwing an exception.  The syntax is as follows
See section <A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A>, for the syntax of <VAR>pred-or-not</VAR>.
</P><P>

<A NAME="IDX1784"></A>
<A NAME="IDX1785"></A>
<A NAME="IDX1786"></A>
<A NAME="IDX1787"></A>
<A NAME="IDX1788"></A>
<A NAME="IDX1789"></A>
<A NAME="IDX1790"></A>
<A NAME="IDX1791"></A>
<A NAME="IDX1792"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>ensures-clause</VAR> ::= <VAR>ensures-keyword</VAR> <VAR>pred-or-not</VAR> <CODE>;</CODE>
<VAR>ensures-keyword</VAR> ::= <CODE>ensures</CODE> | <CODE>post</CODE>
        | <CODE>ensures_redundantly</CODE> | <CODE>post_redundantly</CODE>
</pre></td></tr></table></P><P>

A <VAR>predicate</VAR> in an <CODE>ensures</CODE> clause can
refer to any visible fields, the parameters of the method,
<CODE>\result</CODE> if the method is non-void,
and may contain expressions of the form <CODE>\old(<VAR>E</VAR>)</CODE>.
See section <A HREF="jmlrefman_2.html#SEC12">2.4 Privacy Modifiers and Visibility</A>, for more details on visibility
in JML.
</P><P>

Informally,
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ensures <I>Q</I>;
</pre></td></tr></table>means 
<BLOCKQUOTE>
if the method invocation terminates normally (ie. without
throwing an exception), then predicate <I>Q</I> holds in the post-state.
</BLOCKQUOTE>
<P>

In an ensures clause,
<CODE>\result</CODE> stands for the result that is returned by the method.
The postcondition <I>Q</I> may contain expressions of 
the form <CODE>\old(e)</CODE>.
Such expressions are evaluated in the pre-state, and not in the post-state,
and allow <I>Q</I> to express a relation between the pre- and the post-state.
If parameters of the method occur in the postcondition <I>Q</I>,
these are always evaluated in the pre-state, not the post-state.
In other words, if a method parameter <I>x</I> occurs in  <I>Q</I>,
it is treated as <CODE>\old(</CODE><I>x</I><CODE>)</CODE>.
For a detailed explanation of this see <A HREF="jmlrefman_9.html#SEC108">9.9.6 Parameters in Postconditions</A>.
</P><P>

Any number of ensures clauses can be given in a single specification
case.
Multiple ensures clauses in a specification case
mean the same as a single ensures clause whose postcondition predicate
is the <EM>conjunction</EM> of the postcondition predicates in the given
ensures clauses.
So 
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ensures <I>P</I>;
  ensures <I>Q</I>;
</pre></td></tr></table>means the same as
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ensures <I>P</I> &#38;&#38; <I>Q</I>;
</pre></td></tr></table>Note that, in JML's semantics for expressions within assertions, the
order of evaluation of <I>P</I> and <I>Q</I> does not matter.
See section <A HREF="jmlrefman_2.html#SEC15">2.7 Expression Evaluation and Undefinedness</A>, for more details on
this topic.
</P><P>

<A NAME="IDX1793"></A>
When an ensures clause is omitted in a specification case, a default
ensures clause is used.  For a lightweight specification case, the
default precondition is <CODE>\not_specified</CODE>.  The default
precondition for a heavyweight specification case is <CODE>true</CODE>.
</P><P>

<A NAME="Signals Clauses"></A>
<HR SIZE="6">
<A NAME="SEC106"></A>
<H3> 9.9.4 Signals Clauses </H3>
<!--docid::SEC106::-->
<P>

<A NAME="IDX1794"></A>
<A NAME="IDX1795"></A>
<A NAME="IDX1796"></A>
In a specification case a <CODE>signals</CODE> clause specifies the
exceptional or abnormal postcondition, i.e., the property that is
guaranteed to hold at the end of a method (or constructor) invocation
when this method (or constructor) invocation terminates abruptly by
throwing a given exception.
</P><P>

The syntax is as follows.
See section <A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A>, for the syntax of <VAR>pred-or-not</VAR>.
</P><P>

<A NAME="IDX1797"></A>
<A NAME="IDX1798"></A>
<A NAME="IDX1799"></A>
<A NAME="IDX1800"></A>
<A NAME="IDX1801"></A>
<A NAME="IDX1802"></A>
<A NAME="IDX1803"></A>
<A NAME="IDX1804"></A>
<A NAME="IDX1805"></A>
<A NAME="IDX1806"></A>
<A NAME="IDX1807"></A>
<A NAME="IDX1808"></A>
<A NAME="IDX1809"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>signals-clause</VAR> ::= <VAR>signals-keyword</VAR> <CODE>(</CODE> <VAR>reference-type</VAR> [ <VAR>ident</VAR> ] <CODE>)</CODE>
                   [ <VAR>pred-or-not</VAR> ] <CODE>;</CODE>
<VAR>signals-keyword</VAR> ::= <CODE>signals</CODE> | <CODE>signals_redundantly</CODE>
        | <CODE>exsures</CODE> | <CODE>exsures_redundantly</CODE>
</pre></td></tr></table></P><P>

In a <VAR>signals-clause</VAR> of the form
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (<I>E</I> <I>e</I>) <I>P</I>;
</pre></td></tr></table><I>E</I> has to be a subclass of <CODE>java.lang.Exception</CODE>, and the
variable <I>e</I> is bound in <I>P</I>.  If <I>E</I> is a checked exception
(i.e., if it does not inherit from <CODE>java.lang.RuntimeException</CODE>
<A HREF="jmlrefman_27.html#BIB2">[Arnold-Gosling-Holmes00]</A> <A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>), it must either be one of
the exceptions listed in the method or constructor's <CODE>throws</CODE>
clause, or a subclass or a superclass of such a declared exception.
</P><P>

Informally,
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (<I>E</I> <I>e</I>) <I>P</I>;
</pre></td></tr></table>means 
<BLOCKQUOTE>
If the method (or constructor) invocation terminates abruptly by
throwing an exception of type <I>E</I>, then predicate <I>P</I> holds in the
final state for this exception object <I>E</I>.
</BLOCKQUOTE>
<P>

A signals clause of the form
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (<I>E</I> <I>e</I>) <I>R</I>;
</pre></td></tr></table>is equivalent to the signals clause 
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (java.lang.Exception <I>e</I>) (<I>e</I> instanceof <I>E</I>) ==&#62; <I>R</I>;
</pre></td></tr></table></P><P>

Several signals clauses can be given in a single lightweight, behavior
or exceptional behavior specification case.  Multiple signals clauses
in a specification case mean the same as a single signals clause whose
exceptional postcondition predicate is the <EM>conjunction</EM> of the
exceptional postcondition predicates in the given signals clauses.
This should be understood to take place after the desugaring given
above, which makes all the signals clauses refer to exceptions of type
<CODE>java.lang.Exception</CODE>.  Also, the names in the given signals
clauses have to be standardized <A HREF="jmlrefman_27.html#BIB95">[Raghavan-Leavens05]</A>.  So for example,
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (<I>E1</I> e) <I>R1</I>;
  signals (<I>E2</I> e) <I>R2</I>;
</pre></td></tr></table>means the same as
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (Exception e)   ((e instanceof <I>E1</I>) ==&#62; <I>R1</I>)
                       &#38;&#38; ((e instanceof <I>E2</I>) ==&#62; <I>R2</I>);
</pre></td></tr></table>Note that this means that if an exception is thrown that is both of
type <I>E1</I> and of type <I>E2</I>, then both <I>R1</I> and <I>R2</I> must hold.
</P><P>

[[[EXAMPLE]]]
</P><P>

Beware that a <CODE>signals</CODE> clause specifies when a certain exception
<EM>may</EM> be thrown, not when a certain exception <EM>must</EM> be
thrown.  To say that an exception must be thrown in some situation,
one has to exclude that situation from other signals clauses and from
ensures clause (and any diverges clauses). It may also be useful to
use the <CODE>signals_only</CODE> clause in such specifications
(see section <A HREF="jmlrefman_9.html#SEC107">9.9.5 Signals-Only Clauses</A>).
</P><P>

[[[EXAMPLE?]]]
</P><P>

<A NAME="IDX1810"></A>
<A NAME="IDX1811"></A>
<A NAME="IDX1812"></A>
<A NAME="IDX1813"></A>
When a behavior or exceptional specification case has no
<VAR>signals-clause</VAR>, a default signals clause is used.  For a
heavyweight specification case, 
the default signals clause is <CODE>signals (Exception) true;</CODE>.
Since normal behavior specification cases do not have signals clauses,
no default applies for such specification cases.
For a lightweight specification case, the default is
<CODE>signals \not_specified;</CODE>.
</P><P>

<A NAME="Signals-Only Clauses"></A>
<HR SIZE="6">
<A NAME="SEC107"></A>
<H3> 9.9.5 Signals-Only Clauses </H3>
<!--docid::SEC107::-->
<P>

<A NAME="IDX1814"></A>
<A NAME="IDX1815"></A>
<A NAME="IDX1816"></A>
A <CODE>signals_only</CODE> clause is an abbreviation for a
<VAR>signals-clause</VAR> (see section <A HREF="jmlrefman_9.html#SEC106">9.9.4 Signals Clauses</A>) that
specifies what exceptions may be thrown by a method, and thus, implicitly, what
exceptions may <EM>not</EM> be thrown.
</P><P>

The syntax is as follows.
</P><P>

<A NAME="IDX1817"></A>
<A NAME="IDX1818"></A>
<A NAME="IDX1819"></A>
<A NAME="IDX1820"></A>
<A NAME="IDX1821"></A>
<A NAME="IDX1822"></A>
<A NAME="IDX1823"></A>
<A NAME="IDX1824"></A>
<A NAME="IDX1825"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>signals-only-clause</VAR> ::= <VAR>signals-only-keyword</VAR> <VAR>reference-type</VAR> [ <CODE>,</CODE> <VAR>reference-type</VAR> ] <small>...</small> <CODE>;</CODE>
        | <VAR>signals-only-keyword</VAR> <CODE>\nothing</CODE> <CODE>;</CODE>
<VAR>signals-only-keyword</VAR> ::= <CODE>signals_only</CODE> | <CODE>signals_only_redundantly</CODE>

</pre></td></tr></table></P><P>

All of the <VAR>reference-type</VAR>s named in a <VAR>signals-only-clause</VAR>
must be subtypes of <CODE>java.lang.Exception</CODE>.  Each
<VAR>reference-type</VAR> that is a checked exception type
(i.e., that does not inherit from <CODE>java.lang.RuntimeException</CODE>
<A HREF="jmlrefman_27.html#BIB2">[Arnold-Gosling-Holmes00]</A> <A HREF="jmlrefman_27.html#BIB32">[Gosling-etal00]</A>), must either be one of
the exceptions listed in the method or constructor's <CODE>throws</CODE>
clause, or a subclass or a superclass of such a declared exception.
</P><P>

A <VAR>signals-only-clause</VAR> of the form
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals_only <I>E1</I>, <I>E2</I>, <small>...</small>, <I>En</I>;
</pre></td></tr></table>is considered to be an abbreviation (syntactic sugar) for
the following <VAR>signals</VAR> clause (see section <A HREF="jmlrefman_9.html#SEC106">9.9.4 Signals Clauses</A>).
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  signals (java.lang.Exception e)
           e instanceof <I>E1</I>
        || e instanceof <I>E2</I>
        || <small>...</small>
        || e instanceof <I>En</I>;
</pre></td></tr></table>That is, such a clause specifies that if the method or constructor
throws an exception, it must be an instance of one of the types named.
</P><P>

<A NAME="IDX1826"></A>
Several <VAR>signals-only-clause</VAR>s can be given in a single
lightweight, behavior or exceptional behavior specification case.
Multiple such clauses 
in a specification case mean the same as a single clause whose
list contains only the names <I>Ej</I> that are subtypes of some type
named in all of the given <VAR>signals-only-clause</VAR>s.
Thus, the meaning is a kind of intersection of the <CODE>signals_only</CODE>
clauses.  Since this may be confusing, only one
<CODE>signals_only</CODE> clause should ever be used in a given specification case.
</P><P>

<A NAME="IDX1827"></A>
The <CODE>signals_only</CODE> clause is useful for specifying
when a certain exception, or one of a small set of exceptions, <EM>must</EM> be
thrown.  To say that an exception must be thrown in some situation,
one has to exclude the method from returning normally in that
situation (using an ensures clause or the precondition of some other
specification case) and from not terminating (by using the diverges clause).
</P><P>

[[[Example]]]
</P><P>

<A NAME="IDX1828"></A>
If the <CODE>signals_only</CODE> is omitted from a specification case,
a default <CODE>signals_only</CODE> clause is provided.
The same default is used for both lightweight and heavyweight
behavior and exceptional behavior specification cases.
(Since normal behavior specification cases cannot throw exceptions at all,
there is no default <CODE>signals_only</CODE> clause for such specification cases.)
This default prohibits any exception not declared by the method in
the method's header from being thrown.  Thus the exact default depends on the
method header. If the method header does not list any exceptions that
can be thrown, then the default is <CODE>signals_only \nothing;</CODE>
(which means that the method cannot throw any exceptions).
However, if the method header declares that the method may throw
exceptions <I>DE_1</I>, <small>...</small>, <I>DE_n</I>, <I>Err_1</I>, <small>...</small>, <I>Err_m</I>,
where each <I>DE_i</I> is a subtype of <CODE>java.lang.Exception</CODE>, and
each <I>Err_j</I> is not a subtype of <CODE>java.lang.Exception</CODE>,
then the default 
<CODE>signals_only</CODE> clause is as follows.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   signals_only <I>DE_1</I>, <small>...</small>, <I>DE_n</I>
</pre></td></tr></table>For example, if the method has the header
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">   public void foo() throws E1, E2
</pre></td></tr></table>then the default <CODE>signals_only</CODE> clause
would be 
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif">   signals_only E1, E2;
</pre></td></tr></table></P><P>

<A NAME="IDX1829"></A>
<A NAME="IDX1830"></A>
<A NAME="IDX1831"></A>
<A NAME="IDX1832"></A>
It is important to note that the set of exceptions included in the default
<CODE>signals</CODE> clause described above never includes
<CODE>java.lang.Throwable</CODE>, and does not include
<CODE>java.lang.Error</CODE> or any of its subtypes.  Furthermore, this
default would not normally include
<CODE>java.lang.RuntimeException</CODE> or any of its subtypes, because Java
explicitly allows RuntimeExceptions to be thrown even if they are not
declared in the method header's <CODE>throws</CODE> clause.
Since such unchecked, runtime exceptions are not usually listed in the
method header, they would not find their way into the default
<CODE>signals_only</CODE> clause.
In JML, however, if you wish to allow such runtime exceptions, you
can either explicitly list them in the method header or, more
usually, you would list them in an explicit <CODE>signals_only</CODE> clause.
</P><P>

<A NAME="Parameters in Postconditions"></A>
<HR SIZE="6">
<A NAME="SEC108"></A>
<H3> 9.9.6 Parameters in Postconditions </H3>
<!--docid::SEC108::-->
<P>

Parameters of methods are passed by value in Java,
meaning that parameters are local variables 
in a method body, which are initialized when the method
is called with the values of the parameters for the invocation.
</P><P>

This leads us to the following two rules:
</P><P>

<UL>
<LI>
The parameters of a method or constructor can never be listed in
its assignable clause.
<P>

<LI>
If parameters of a method (or constructor) are used in
a normal or exceptional postcondition for that method (or constructor),
i.e., in an ensures or signals clause,
then these always have their value in the pre-state of the method 
(or constructor),
not the post-state.
In other words, there is an implicit <CODE>\old()</CODE> placed around
any occurrence of a formal parameter in a postcondition.
</UL>
<P>

The justification for the first convention is that clients cannot observe
assignments to the parameters anyway, as these are
local variables that can only be used by the implementation
of the method.
Given that clients can never observe these assignments,
there is no point in making them 
part of the contract between a class and its clients.
</P><P>

The justification for the second convention is that clients only know 
the initial values of the parameter that they supply, 
and do not have any knowledge of the final values
that these variables may have in the post-state.
</P><P>

The reason for this is best illustrated by an example.
Consider the following class and its method specifications.
Without the convention described above 
the implementations given for methods
<CODE>notCorrect1</CODE> and <CODE>notCorrect2</CODE> would satisfy their specifications.
However, clearly neither of these satisfies the specification
when read from the caller's point of view.
</P><P>

<A NAME="IDX1833"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;

public abstract class ImplicitOld {

    /*@ ensures 0 &#60;= \result &#38;&#38; \result &#60;= x;
      @ signals (Exception) x &#60; 0;
      @*/
    public static int notCorrect1(int x) throws Exception {
        x = 5;
        return 4;
    }

    /*@ ensures 0 &#60;= \result &#38;&#38; \result &#60;= x;
      @ signals (Exception) x &#60; 0;
      @*/
    public static int notCorrect2(int x) throws Exception {
        x = -1;
        throw new Exception();
    }

    /*@ ensures 0 &#60;= \result &#38;&#38; \result &#60;= x;
      @ signals (Exception) x &#60; 0;
      @*/
    public static int correct(int x) throws Exception {
        if (x &#60; 0) {
            throw new Exception();
        } else {
            return 0;
        }
    }
}
</pre></td></tr></table></P><P>

The convention above rules out such
pathological implementations as <CODE>notCorrect1</CODE> 
above; because mention of a formal parameter name, such as <CODE>x</CODE> above,
in postconditions always means the pre-state value of that name,
e.g., <CODE>\old(x)</CODE> in the example above.
</P><P>

<A NAME="Diverges Clauses"></A>
<HR SIZE="6">
<A NAME="SEC109"></A>
<H3> 9.9.7 Diverges Clauses </H3>
<!--docid::SEC109::-->
<P>

<A NAME="IDX1834"></A>
The diverges clause is a seldom-used feature of JML.  It says when a
method may loop forever or otherwise not return to its caller, by
either throwing an exception or returning normally.  The syntax is as
follows See section <A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A>, for the syntax of <VAR>pred-or-not</VAR>.
</P><P>

<A NAME="IDX1835"></A>
<A NAME="IDX1836"></A>
<A NAME="IDX1837"></A>
<A NAME="IDX1838"></A>
<A NAME="IDX1839"></A>
<A NAME="IDX1840"></A>
<A NAME="IDX1841"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>diverges-clause</VAR> ::= <VAR>diverges-keyword</VAR> <VAR>pred-or-not</VAR> <CODE>;</CODE>
<VAR>diverges-keyword</VAR> ::= <CODE>diverges</CODE> | <CODE>diverges_redundantly</CODE>
</pre></td></tr></table></P><P>

<A NAME="IDX1842"></A>
<A NAME="IDX1843"></A>
<A NAME="IDX1844"></A>
When a diverges clause is omitted in a specification case, a default
diverges clause is used.  For both lightweight and heavyweight
specification cases, the 
default diverges condition is <CODE>false</CODE>.
Thus by default, specification cases
give total correctness specifications <A HREF="jmlrefman_27.html#BIB28">[Dijkstra76]</A>.  Explicitly writing
a diverges clause allows one to obtain a partial correctness
specification <A HREF="jmlrefman_27.html#BIB39">[Hoare69]</A>.  Being able to specify both total and partial
correctness specification cases for a method leads to additional power
<A HREF="jmlrefman_27.html#BIB38">[Hesselink92]</A> <A HREF="jmlrefman_27.html#BIB90">[Nelson89]</A>.
</P><P>

As an example of the use of <CODE>diverges</CODE>, consider the <CODE>exit</CODE>
method in the following class.  (This example is simplified from the
specification of Java's <CODE>System.exit</CODE> method.
This specification says that the method can always be called (the
implicit precondition is <CODE>true</CODE>),
may always not return to the caller (i.e., diverge),
and may never return normally, and
may never throw an exception.
Thus the only thing the method can legally do, aside from causing a JVM
error, is to not return to its caller.
</P><P>

<A NAME="IDX1845"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>package org.jmlspecs.samples.jmlrefman;
 
public abstract class Diverges {

    /*@ public behavior
      @    diverges true;
      @    assignable \nothing;
      @    ensures false;
      @    signals (Exception) false;
      @*/
    public static void abort();

}
</pre></td></tr></table></P><P>

The diverges clause is also useful to specify things like methods that
are supposed to abort the program when certain conditions occur,
although that isn't really good practice in Java.  In general, it is
most useful for examples like the one given above, when you want to say when
a method cannot return to its caller.
</P><P>

<A NAME="When Clauses"></A>
<HR SIZE="6">
<A NAME="SEC110"></A>
<H3> 9.9.8 When Clauses </H3>
<!--docid::SEC110::-->
<P>

The <CODE>when</CODE> clause allows concurrency aspects of a method or
constructor to be specified <A HREF="jmlrefman_27.html#BIB74">[Lerner91]</A> <A HREF="jmlrefman_27.html#BIB97">[Rodriguez-etal05]</A>.
A caller of a method will be delayed until the condition given in the
<CODE>when</CODE> clause holds.  What is checked is that the method does not
proceed to its commit point, which is the start of execution of
statement with the label <CODE>commit</CODE>, until the given predicate is
true.
</P><P>

The syntax is as follows.
See section <A HREF="jmlrefman_9.html#SEC104">9.9.2 Requires Clauses</A>, for the syntax of <VAR>pred-or-not</VAR>.
</P><P>

<A NAME="IDX1846"></A>
<A NAME="IDX1847"></A>
<A NAME="IDX1848"></A>
<A NAME="IDX1849"></A>
<A NAME="IDX1850"></A>
<A NAME="IDX1851"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>when-clause</VAR> ::= <VAR>when-keyword</VAR> <VAR>pred-or-not</VAR> <CODE>;</CODE>
<VAR>when-keyword</VAR> ::= <CODE>when</CODE> | <CODE>when_redundantly</CODE>
</pre></td></tr></table></P><P>

<A NAME="IDX1852"></A>
When a when clause is omitted in a specification case, a default when
clause is used.  For a lightweight specification case, the default
when condition is <CODE>\not_specified</CODE>.  The default when condition
for a heavyweight specification case is <CODE>true</CODE>.
</P><P>

See <A HREF="jmlrefman_27.html#BIB97">[Rodriguez-etal05]</A> for more about the <CODE>when</CODE> clause and JML's
plans for support of multithreading.
</P><P>

<A NAME="Assignable Clauses"></A>
<HR SIZE="6">
<A NAME="SEC111"></A>
<H3> 9.9.9 Assignable Clauses </H3>
<!--docid::SEC111::-->
<P>

<A NAME="IDX1853"></A>
<A NAME="IDX1854"></A>
<A NAME="IDX1855"></A>
<A NAME="IDX1856"></A>
<A NAME="IDX1857"></A>
An assignable clause gives a frame axiom for a specification.  It says
that, from the client's point of view, only the locations named, and
locations in the data groups associated with these locations,
can be assigned to during the execution of the method.
The values of all subexpressions used in assignable clauses,
such as <CODE>i-1</CODE> in <CODE>a[i-1]</CODE>,
are computed in the pre-state of the method,
because the assignable clause only talks about locations that exist in
the pre-state.
</P><P>

See section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>, for more about specification of data groups.
However, locations that are local to the method (or methods it calls)
and locations that are created during the method's execution are not
subject to this restriction.
</P><P>

The syntax is as follows.
See section <A HREF="jmlrefman_11.html#SEC162">11.7 Store Refs</A>, for the syntax of <VAR>store-ref-list</VAR>.
</P><P>

<A NAME="IDX1858"></A>
<A NAME="IDX1859"></A>
<A NAME="IDX1860"></A>
<A NAME="IDX1861"></A>
<A NAME="IDX1862"></A>
<A NAME="IDX1863"></A>
<A NAME="IDX1864"></A>
<A NAME="IDX1865"></A>
<A NAME="IDX1866"></A>
<A NAME="IDX1867"></A>
<A NAME="IDX1868"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>assignable-clause</VAR> ::= <VAR>assignable-keyword</VAR> <VAR>store-ref-list</VAR> <CODE>;</CODE>
<VAR>assignable-keyword</VAR> ::= <CODE>assignable</CODE> | <CODE>assignable_redundantly</CODE>
        | <CODE>modifiable</CODE> | <CODE>modifiable_redundantly</CODE>
        | <CODE>modifies</CODE> | <CODE>modifies_redundantly</CODE>
</pre></td></tr></table></P><P>

<A NAME="IDX1869"></A>
<A NAME="IDX1870"></A>
<A NAME="IDX1871"></A>
<A NAME="IDX1872"></A>
<A NAME="IDX1873"></A>
When an assignable clause is omitted in a specification case, a
default assignable clause is used.  This default has a default
<VAR>store-ref-list</VAR>.  For a lightweight specification
case, the default <VAR>store-ref-list</VAR> is
<CODE>\not_specified</CODE>.  The default <VAR>store-ref-list</VAR>
for a heavyweight specification case is <CODE>\everything</CODE>.
</P><P>

<A NAME="IDX1874"></A>
<A NAME="IDX1875"></A>
If one wants the opposite of the default (for a heavyweight
specification case), then one can specify that a method cannot assign to any
locations by writing:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  assignable \nothing;
</pre></td></tr></table>Using the modifier <CODE>pure</CODE> on a method achieves the same effect as
specifying <CODE>assignable \nothing</CODE>, but does so for the method's entire
specification as opposed to a single <VAR>specification-case</VAR>.
</P><P>

<A NAME="IDX1876"></A>
Assignable clauses are subject to several restrictive rules in JML.
The first rule has to do with fields of model objects.
Because model objects are abstract 
and do not have a concrete state or concrete fields, the JML typechecker 
does not allow fields of model objects to be listed in the assignable clause; 
that is, such expressions do not specify a set of locations 
(concrete fields) that can be assigned to. Thus expressions 
like <CODE>f.x</CODE> are not allowed in the assignable clause when <CODE>f</CODE> 
is a model field. 
</P><P>

[[[Flesh out other restrictions.  Refer to
<A HREF="jmlrefman_27.html#BIB87">[Mueller-Poetzsch-Heffter-Leavens03]</A> for details.]]]
</P><P>

<A NAME="Accessible Clauses"></A>
<HR SIZE="6">
<A NAME="SEC112"></A>
<H3> 9.9.10 Accessible Clauses </H3>
<!--docid::SEC112::-->
<P>

<A NAME="IDX1877"></A>
The accessible clause is a seldom-used feature of JML.
Together with the <CODE>assignable</CODE> clause (see section <A HREF="jmlrefman_9.html#SEC111">9.9.9 Assignable Clauses</A>), 
it says what (pre-existing) locations a method may
read during its execution.
It has the following syntax.
</P><P>

<A NAME="IDX1878"></A>
<A NAME="IDX1879"></A>
<A NAME="IDX1880"></A>
<A NAME="IDX1881"></A>
<A NAME="IDX1882"></A>
<A NAME="IDX1883"></A>
<A NAME="IDX1884"></A>
<A NAME="IDX1885"></A>
<A NAME="IDX1886"></A>
<A NAME="IDX1887"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>accessible-clause</VAR> ::= <VAR>accessible-keyword</VAR> <VAR>store-ref-list</VAR> <CODE>;</CODE>
<VAR>accessible-keyword</VAR> ::= <CODE>accessible</CODE> | <CODE>accessible_redundantly</CODE>
</pre></td></tr></table></P><P>

During execution of the method (which includes all directly and
indirectly called methods and constructors),
only locations that either did not exist in the pre-state,
that are local to the method (including the method's formal parameters),
or that are either named in the lists found in the 
<CODE>accessible</CODE> and <CODE>assignable</CODE> clauses
or that are dependees (see section <A HREF="jmlrefman_10.html#SEC118">10. Data Groups</A>) of such locations,
are read from.
Note that locations that are local to the method (or methods it calls)
and locations that are created during the method's execution are not
subject to this restriction and may be read from freely.
</P><P>

<A NAME="IDX1888"></A>
<A NAME="IDX1889"></A>
When an accessible clause is omitted in a code contract specification case, a
default accessible clause is used.  
This default has a default <VAR>store-ref-list</VAR> which is  
<CODE>\everything</CODE>.
</P><P>

See section <A HREF="jmlrefman_15.html#SEC190">15. Specification for Subtypes</A>, for more discussion and examples.
</P><P>

<A NAME="Callable Clauses"></A>
<HR SIZE="6">
<A NAME="SEC113"></A>
<H3> 9.9.11 Callable Clauses </H3>
<!--docid::SEC113::-->
<P>

<A NAME="IDX1890"></A>
The callable clause says what methods may be called, either directly
or indirectly, by the method being specified.  It has the following syntax.
</P><P>

<A NAME="IDX1891"></A>
<A NAME="IDX1892"></A>
<A NAME="IDX1893"></A>
<A NAME="IDX1894"></A>
<A NAME="IDX1895"></A>
<A NAME="IDX1896"></A>
<A NAME="IDX1897"></A>
<A NAME="IDX1898"></A>
<A NAME="IDX1899"></A>
<A NAME="IDX1900"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>callable-clause</VAR> ::= <VAR>callable-keyword</VAR> <VAR>callable-methods-list</VAR> <CODE>;</CODE>
<VAR>callable-keyword</VAR> ::= <CODE>callable</CODE> | <CODE>callable_redundantly</CODE>
<VAR>callable-methods-list</VAR> ::= <VAR>method-name-list</VAR> | <VAR>store-ref-keyword</VAR>
</pre></td></tr></table></P><P>

During execution of a method,
the only methods and constructors that may be called are those listed in the
<CODE>callable</CODE> clause's list.
</P><P>

<A NAME="IDX1901"></A>
<A NAME="IDX1902"></A>
When a callable clause is omitted in a code contract specification case, a
default callable clause is used.  
This default has a default <VAR>callable-methods-list</VAR> which is  
<CODE>\everything</CODE>.
</P><P>

See section <A HREF="jmlrefman_15.html#SEC190">15. Specification for Subtypes</A>, for more discussion and examples.
</P><P>

<A NAME="Measured By Clauses"></A>
<HR SIZE="6">
<A NAME="SEC114"></A>
<H3> 9.9.12 Measured By Clauses </H3>
<!--docid::SEC114::-->
<P>

<A NAME="IDX1903"></A>
A measured by clause can be used in a termination argument for a
recursive specification.  It has the following syntax.
</P><P>

<A NAME="IDX1904"></A>
<A NAME="IDX1905"></A>
<A NAME="IDX1906"></A>
<A NAME="IDX1907"></A>
<A NAME="IDX1908"></A>
<A NAME="IDX1909"></A>
<A NAME="IDX1910"></A>
<A NAME="IDX1911"></A>
<A NAME="IDX1912"></A>
<A NAME="IDX1913"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>measured-clause</VAR> ::= <VAR>measured-by-keyword</VAR> <CODE>\not_specified</CODE> <CODE>;</CODE>
        | <VAR>measured-by-keyword</VAR> <VAR>spec-expression</VAR> [ <CODE>if</CODE> <VAR>predicate</VAR> ] <CODE>;</CODE>
<VAR>measured-by-keyword</VAR> ::= <CODE>measured_by</CODE> | <CODE>measured_by_redundantly</CODE>
</pre></td></tr></table></P><P>

The <VAR>spec-expression</VAR> in a measured by clause must have type
<CODE>int</CODE>.
</P><P>

In both lightweight and heavyweight specification cases, an omitted 
measured by clause means the same as a measured by clause of the
following form.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>    measured_by \not_specified;
</pre></td></tr></table></P><P>

<A NAME="Captures Clauses"></A>
<HR SIZE="6">
<A NAME="SEC115"></A>
<H3> 9.9.13 Captures Clauses </H3>
<!--docid::SEC115::-->
<P>

<A NAME="IDX1914"></A>
</P><P>

The captures clause has the following syntax.
</P><P>

<A NAME="IDX1915"></A>
<A NAME="IDX1916"></A>
<A NAME="IDX1917"></A>
<A NAME="IDX1918"></A>
<A NAME="IDX1919"></A>
<A NAME="IDX1920"></A>
<A NAME="IDX1921"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>captures-clause</VAR> ::= <VAR>captures-keyword</VAR> <VAR>store-ref-list</VAR> <CODE>;</CODE>
<VAR>captures-keyword</VAR> ::= <CODE>captures</CODE> | <CODE>captures_redundantly</CODE>
</pre></td></tr></table></P><P>

The captures clause says that references to the <VAR>store-ref</VAR>s listed can be
retained after the method returns, for example in a field of the
receiver object or in a static field.
Therefore, the captures clause specifies when an object, passed as an 
actual parameter in a method call, may be captured during the call.
</P><P>

An actual parameter object (including the receiver this) is captured if it 
appears on the right-hand side of an assignment statement 
during the call.  
This can also happen indirectly through another method or constructor call 
or by returning the parameter object as the method result (we assume 
the result will be assigned to a field or local variable after the 
call).  
</P><P>

The captures clause is used to prevent certain kinds of representation 
exposure as part of an alias control technique. 
For example, if an object should not be aliased, then   
that object must not be passed to a method that may capture it, 
i.e., may create an alias to it (this includes the receiver). 
Furthermore, objects used as part of the abstract representation of a type
should not be aliased, and thus should not be passed to methods 
that capture it.  
JML tools will eventually prevent such aliasing.
</P><P>

<A NAME="IDX1922"></A>
<A NAME="IDX1923"></A>
When a captures clause is omitted in a method specification case, then a
default captures clause is used.  
This default has a default <VAR>store-ref-list</VAR> which is  
<CODE>\everything</CODE>. 
Thus when omitted, a method is allowed to capture any of the actual 
parameter objects or the receiver.
</P><P>

<A NAME="Working Space Clauses"></A>
<HR SIZE="6">
<A NAME="SEC116"></A>
<H3> 9.9.14 Working Space Clauses </H3>
<!--docid::SEC116::-->
<P>

A <VAR>working-space-clause</VAR> can be used to specify the maximum amount
of heap space used by a method, over and above that used by its
callers.  The clause applies only to the particular specification case
it is in, of course
This is adapted from the work of Krone, Ogden, and Sitaraman on
RESOLVE <A HREF="jmlrefman_27.html#BIB49">[Krone-Ogden-Sitaraman03]</A>.
</P><P>

<A NAME="IDX1924"></A>
<A NAME="IDX1925"></A>
<A NAME="IDX1926"></A>
<A NAME="IDX1927"></A>
<A NAME="IDX1928"></A>
<A NAME="IDX1929"></A>
<A NAME="IDX1930"></A>
<A NAME="IDX1931"></A>
<A NAME="IDX1932"></A>
<A NAME="IDX1933"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>working-space-clause</VAR> ::= <VAR>working-space-keyword</VAR> <CODE>\not_specified</CODE> <CODE>;</CODE>
        | <VAR>working-space-keyword</VAR> <VAR>spec-expression</VAR> [ <CODE>if</CODE> <VAR>predicate</VAR> ] <CODE>;</CODE>
<VAR>working-space-keyword</VAR> ::= <CODE>working_space</CODE> | <CODE>working_space_redundantly</CODE>
</pre></td></tr></table></P><P>

The <VAR>spec-expression</VAR> in a working space clause must have type
<CODE>long</CODE>.  It is to be understood in units of bytes.
</P><P>

<A NAME="IDX1934"></A>
<A NAME="IDX1935"></A>
The <VAR>spec-expression</VAR> in a working space clause may use
<CODE>\old</CODE> and other JML operators appropriate for postconditions.
This is because it is considered to be evaluated in the post-state,
and provides a guarantee of the maximum amount of additional space
used by the call.  In some cases this space may depend on the
<CODE>\result</CODE>, exceptions thrown, or other post-state values.
[[[ There is however no way to identify the exception thrown - DRCok]]]
</P><P>

In both lightweight and heavyweight specification cases, an omitted 
working space clause means the same as a working space clause of the
following form.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>    working_space \not_specified;
</pre></td></tr></table></P><P>

See section <A HREF="jmlrefman_11.html#SEC138">11.4.13 <CODE>\working_space</CODE></A>, for information about the
<CODE>\working_space</CODE> expression that can be used
to describe the working space needed by a
method call.  See section <A HREF="jmlrefman_11.html#SEC137">11.4.12 <CODE>\space</CODE></A>, for information about the
<CODE>\space</CODE> expression that can be used
to describe the heap space occupied by an object.
</P><P>

<A NAME="Duration Clauses"></A>
<HR SIZE="6">
<A NAME="SEC117"></A>
<H3> 9.9.15 Duration Clauses </H3>
<!--docid::SEC117::-->
<P>

A duration clause can be used to specify the maximum (i.e., worst
case) time needed to process a method call in a particular
specification case.  [[[ Tools are simpler if the argument can simply be an arbitrary expression rather than a method call. -- DRCok ]]]
This is adapted from the work of Krone, Ogden, and Sitaraman on
RESOLVE <A HREF="jmlrefman_27.html#BIB49">[Krone-Ogden-Sitaraman03]</A>.
</P><P>

<A NAME="IDX1936"></A>
<A NAME="IDX1937"></A>
<A NAME="IDX1938"></A>
<A NAME="IDX1939"></A>
<A NAME="IDX1940"></A>
<A NAME="IDX1941"></A>
<A NAME="IDX1942"></A>
<A NAME="IDX1943"></A>
<A NAME="IDX1944"></A>
<A NAME="IDX1945"></A>
<TABLE><tr><td>&nbsp;</td><td class=display><pre style="font-family: serif"><VAR>duration-clause</VAR> ::= <VAR>duration-keyword</VAR> <CODE>\not_specified</CODE> <CODE>;</CODE>
        | <VAR>duration-keyword</VAR> <VAR>spec-expression</VAR> [ <CODE>if</CODE> <VAR>predicate</VAR> ] <CODE>;</CODE>
<VAR>duration-keyword</VAR> ::= <CODE>duration</CODE> | <CODE>duration_redundantly</CODE>
</pre></td></tr></table></P><P>

The <VAR>spec-expression</VAR> in a duration clause must have type
<CODE>long</CODE>.  It is to be understood in units of [[[the JVM
instruction that takes the least time to execute, which may be thought
of as the JVM's cycle time.]]]  The time it takes the JVM to execute
such an instruction can be multiplied by the number of such cycles to
arrive at the clock time needed to execute the method in the given
specification case.  [[[This time should also be understood as not
counting garbage collection time.]]]
</P><P>

<A NAME="IDX1946"></A>
<A NAME="IDX1947"></A>
The <VAR>spec-expression</VAR> in a duration clause may use
<CODE>\old</CODE> and other JML operators appropriate for postconditions.
This is because it is considered to be evaluated in the post-state,
and provides a guarantee of the maximum amount of additional space
used by the call.  In some cases this space may depend on the
<CODE>\result</CODE>, exceptions thrown, or other post-state values.
[[[  There is no way to identify the exception thrown -  DRCok]]]
</P><P>

In both lightweight and heavyweight specification cases, an omitted 
duration clause means the same as a duration clause of the
following form.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>    duration \not_specified;
</pre></td></tr></table></P><P>

See section <A HREF="jmlrefman_11.html#SEC136">11.4.11 <CODE>\duration</CODE></A>, for information about the <CODE>\duration</CODE>
expression that can be used in the duration clause to specify the
duration of other methods.
</P><P>

<A NAME="Data Groups"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_9.html#SEC98"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_10.html#SEC118"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_28.html#SEC247">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="jmlrefman_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary Leavens</I> on <I>May, 20  2008</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
