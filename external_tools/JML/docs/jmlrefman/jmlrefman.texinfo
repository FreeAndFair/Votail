\input texinfo  @c -*-texinfo-*-
@comment %**start of header (This is for running Texinfo on a region.)
@setfilename jmlrefman.info
@settitle JML Reference Manual
@c @setchapternewpage odd

@c [[[Notes to authors:
@c
@c Be sure to edit in such a way that no tab characters get into this file.
@c
@c When editing grammar productions, be sure to use the whitespace
@c required at the beginning of lines that continue productions; these
@c lines must start with some blanks and either | or [ or @var.
@c If the conventions aren't followed, then the production won't
@c make it into the appendix with the collected grammar.
@c See collected-grammar.sh for the exact rules.
@c
@c Conversely, you have to be sure that things that aren't in the
@c grammar don't match the rules for automatically collecting the
@c grammar.  To to this, whenever you add a such a line to the file,
@c make the output (e.g., make html) and check the grammar in the
@c section you were editing.
@c
@c All examples (that are not demonstrating errors),
@c no matter how small, should be put in the
@c org.jmlspecs.samples.jmlrefman package and included here.  Don't
@c write them inline, otherwise they won't be checked by tools.
@c
@c If you change the number of chapters, be sure to also change the
@c Makefile's definition of GRAMMAR_HTML to match the file name of the
@c collected grammar section, and also correct this in ../../JML.html.
@c
@c Note that @i{P} and @var{P} are not the same thing.  Use @i{P} for
@c mathematical formula variables, where you would use $P$ in LaTeX.
@c Use @var{P} only for grammar productions, please.
@c
@c If you're not seeing paragraph breaks, then there's something wrong
@c with your texi2html.  One solution is to use the
@c texi2html scripts in JML2/bin-for-developers.
@c
@c                   Thanks! -- Gary]]]

@ifinfo
@format
INFO-DIR-SECTION Programming & development tools
START-INFO-DIR-ENTRY
* JML Reference Manual: (jmlrefman).  Reference for the Java Modeling Language.
END-INFO-DIR-ENTRY
@end format

Copyright @copyright{} 2002-2007 by the authors

Permission is granted for you to make copies of this manual for
educational and scholarly purposes, and for commercial use in
specifying software, but the copies may not be sold or otherwise used
for direct commercial advantage; this permission is granted provided
that this copyright and permission notice is preserved on all copies.
All other rights reserved.

Version Information:
 @@(#) $Id: jmlrefman.texinfo,v 1.231 2008/05/13 20:54:59 leavens Exp $
@end ifinfo

@comment ----- title and copyright pages
@titlepage
@title JML Reference Manual
@subtitle DRAFT, $Revision: 1.231 $
@subtitle $Date: 2008/05/13 20:54:59 $

@author Gary T. Leavens, Erik Poll, Curtis Clifton, Yoonsik Cheon, 
@author Clyde Ruby, David Cok, Peter M@"uller, Joseph Kiniry,
@author Patrice Chalin, Daniel M. Zimmerman

@comment The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2008 by the authors

Department of Computer Science @*
226 Atanasoff Hall @*
Iowa State University @*
Ames, Iowa 50011-1041, USA @*

Permission is granted for you to make copies of this manual for
educational and scholarly purposes, and for commercial use in
specifying software, but the copies may not be sold or otherwise used
for direct commercial advantage; this permission is granted provided
that this copyright and permission notice is preserved on all copies.
All other rights reserved.

Version Information: @*
 @@(#) $Id: jmlrefman.texinfo,v 1.231 2008/05/13 20:54:59 leavens Exp $

@end titlepage

@synindex vr cp
@synindex fn cp
@synindex ky cp
@synindex tp cp

@node Top, Introduction, (dir), (dir)

@ifinfo
@c The following is orientation for the reader of the info file
The Java Modeling Language (JML) is a notation for formally specifying
the behavior and interfaces of Java classes and methods.
The purpose of this manual is to precisely define JML's syntax and semantics.
@end ifinfo

@c to generate the menus below automatically use C-c C-u C-a in emacs

@menu
* Introduction::                
* Fundamental Concepts::        
* Syntax Notation::             
* Lexical Conventions::         
* Compilation Units::           
* Type Definitions::            
* Class and Interface Member Declarations::  
* Type Specifications::         
* Method Specifications::       
* Data Groups::                 
* Predicates and Specification Expressions::  
* Statements and Annotation Statements::  
* Redundancy::                  
* Model Programs::              
* Specification for Subtypes::  
* Refinement::                  
* MultiJava Extensions to JML::  
* Universe Type System::        
* Safe Math Extensions::        
* Deprecated and Replaced Syntax::  
* Grammar Summary::             
* Modifier Summary::            
* Type Checking Summary::       
* Verification Logic Summary::  
* Differences::                 
* Bibliography::                
* Example Index::               
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Behavioral Interface Specifications::  
* A First Example::             
* What is JML Good For?::       
* Status and Plans for JML::    
* Historical Precedents::       
* Acknowledgments::             

Fundamental Concepts

* Types can be Classes and Interfaces::  
* Model and Ghost::             
* Lightweight and Heavyweight Specifications::  
* Privacy Modifiers and Visibility::  
* Instance vs. Static::         
* Locations and Aliasing::      
* Expression Evaluation and Undefinedness::  
* Null is Not the Default::     
* Language Levels::             

Language Levels

* Level 0 Features::            
* Level 1 Features::            
* Level 2 Features::            
* Level 3 Features::            
* Level C Features::            
* Level X Features::            

Lexical Conventions

* White Space::                 
* Lexical Pragmas::             
* Comments::                    
* Annotation Markers::          
* Documentation Comments::      
* Tokens::                      

Compilation Units

* Package Definitions::         
* Import Definitions::          

Type Definitions

* Class and Interface Definitions::  
* Modifiers::                   

Class and Interface Definitions

* Subtyping for Type Definitions::  
* Modifiers for Type Definitions::  

Modifiers

* Suggested Modifier Ordering::  
* Spec Public::                 
* Spec Protected::              
* Pure::                        
* Model::                       
* Ghost::                       
* Instance::                    
* Helper::                      
* Monitored::                   
* Uninitialized::               
* Math Modifiers::              
* Nullity Modifiers::           

Class and Interface Member Declarations

* Java Member Declarations::    
* Class Initializer Declarations::  

Java Member Declarations

* Method and Constructor Declarations::  
* Field and Variable Declarations::  

Method and Constructor Declarations

* Formal Parameters::           
* Model Methods and Constructors::  
* Pure Methods and Constructors::  
* Helper Methods and Constructors::  

Field and Variable Declarations

* JML Modifiers for Fields  ::  
* Type-Specs::                  

Type Specifications

* Introductory ADT Specification Examples::  
* Invariants::                  
* Constraints::                 
* Represents Clauses::          
* Initially Clauses::           
* Axioms::                      
* Readable If Clauses::         
* Writable If Clauses::         
* Monitors For Clause::         

Invariants 

* Static vs. instance invariants::  
* Invariants and Exceptions::   
* Access Modifiers for Invariants::  
* Invariants and Inheritance::  

Constraints 

* Static vs. instance constraints::  
* Access Modifiers for Constraints::  
* Constraints and Inheritance::  

Method Specifications

* Basic Concepts in Method Specification::  
* Organization of Method Specifications::  
* Access Control in Specification Cases::  
* Lightweight Specification Cases::  
* Heavyweight Specification Cases::  
* Behavior Specification Cases::  
* Normal Behavior Specification Cases::  
* Exceptional Behavior Specification Cases::  
* Method Specification Clauses::  

Invariants and constraints 

* Semantics of flat behavior specification cases::  
* Non-helper methods::          
* Non-helper constructors::     
* Helper methods and constructors::  
* Semantics of nested behavior specification cases::  

Exceptional Behavior Specification Cases

* Pragmatics of Exceptional Behavior Specification Cases::  

Method Specification Clauses

* Specification Variable Declarations::  
* Requires Clauses::            
* Ensures Clauses::             
* Signals Clauses::             
* Signals-Only Clauses::        
* Parameters in Postconditions::  
* Diverges Clauses::            
* When Clauses::                
* Assignable Clauses::          
* Accessible Clauses::          
* Callable Clauses::            
* Measured By Clauses::         
* Captures Clauses::            
* Working Space Clauses::       
* Duration Clauses::            

Specification Variable Declarations

* Forall Variable Declarations::  
* Old Variable Declarations::   

Data Groups

* Static Data Group Inclusions::  
* Dynamic Data Group Mappings ::  

Predicates and Specification Expressions

* Predicates::                  
* Specification Expressions::   
* Expressions::                 
* JML Primary Expressions::     
* Set Comprehensions::          
* JML Operators::               
* Store Refs::                  

JML Primary Expressions

* Backslash result::            
* Backslash old and Backslash pre::  
* Backslash not_assigned::      
* Backslash not_modified::      
* Backslash only_accessed::     
* Backslash only_assigned::     
* Backslash only_called::       
* Backslash only_captured::     
* Backslash fresh::             
* Backslash reach::             
* Backslash duration::          
* Backslash space::             
* Backslash working space::     
* Backslash nonnullelements::   
* Informal Predicates::         
* Backslash typeof::            
* Backslash elemtype::          
* Backslash type::              
* Backslash lockset::           
* Backslash max::               
* Backslash is_initialized::    
* Backslash invariant_for::     
* Backslash lblneg and lblpos::  
* Quantified Expressions::      

Quantified Expressions

* Universal and Existential Quantifiers::  
* Generalized Quantifiers::     
* Numerical Quantifier::        
* Executability of Quantified Expressions::  
* Modifiers for Bound Variables::  
* Quantifying over Reference Types::  

JML Operators

* Subtype operator::            
* Equivalence and Inequivalence Operators::  
* Forward and Reverse Implication Operators::  
* Lockset Ordering::            

Statements and Annotation Statements

* Local Declaration Statements::  
* Loop Statements::             
* Assert Statements::           
* JML Annotation Statements::   

Local Declaration Statements

* Modifiers for Local Declarations::  

Loop Statements

* Loop Invariants::             
* Loop Variant Functions::      

JML Annotation Statements

* Assume Statements::           
* Set Statements::              
* Refining Statements::         
* Unreachable Statements::      
* Debug Statements::            
* Hence By Statements::         

Redundancy

* Redundant Implications and Redundantly Clauses::  
* Redundant Examples::          

Model Programs

* Ideas Behind Model Programs::  
* Extracting Model Program Specifications::  
* Details of Model Programs::   
* Nondeterministic Choice Statement::  
* Nondeterministic If Statement::  
* Specification Statements::    

Specification Statements

* Continues Clause::            
* Breaks Clause::               
* Returns Clause::              

Specification for Subtypes

* Method of Specifying for Subclasses::  
* Code Contracts::              

Refinement

* File Name Suffixes::          
* Using Separate Files::        
* Refinement Chains::           
* Type Checking Refinements::   
* Refinement Viewpoints::       

Refinement Viewpoints

* Default Constructor Refinement::  

MultiJava Extensions to JML

* Augmenting Method Declarations::  
* MultiMethods::                

Universe Type System

* Basic Concepts of Universes::  
* Rep and Peer::                
* Readonly::                    
* Ownership Modifiers for Array Types::  
* Default Ownership Modifiers::  
* Ownership Type Rules::        
* Casts and Ownership Types::   

Ownership Type Rules

* Ownership Subtyping::         
* Ownership Typing for Expressions::  

Safe Math Extensions

* Backslash bigint::            
* Backslash real::              

Deprecated and Replaced Syntax

* Deprecated Syntax::           
* Replaced Syntax::             

Differences

* Differences Between JML and Other Tools::  
* Differences Between JML and Java::  

Differences Between JML and Other Tools

* Differences Between JML and ESC/Java2::  

Differences Between JML and Java

* Non-null by Default::         

@end detailmenu
@end menu

@contents

@c ------ chapter Introduction --------
@node Introduction, Fundamental Concepts, Top, Top
@c  node-name,  next,  previous,  up
@chapter Introduction

@cindex goals, of JML
@cindex Java
@cindex Arnold
@cindex Gosling
@cindex Holmes
JML is a notation for formally specifying
the behavior and interfaces of Java [Arnold-Gosling-Holmes00] [Gosling-etal00]
classes and methods.

@cindex purpose, of this reference manual
@cindex Daikon
@cindex ESC/Java
@cindex Burdy
The goal of this reference manual is to precisely record the design of
JML.  We include both informal semantics (intentions) and where possible
[[[we will eventually include]]]
formal semantics (describing when an implementation satisfies a
specification). We also discuss the implications for various tools
(such as the run-time assertion checker, static checkers such as ESC/Java2, and
documentation generators such as jmldoc [Burdy-etal03]).

@cindex Leavens
@cindex Baker
@cindex Ruby
@cindex Cheon
@cindex web site, for JML
@cindex JML web site
In this manual we also try to give examples and explanations, and we
hope that these will 
be helpful to readers trying to learn about formal specification using
JML.
However, this manual is not designed to give all the background needed
to write JML specifications, nor to give the prospective user an
overview of a useful subset of the language.
For this background, we recommend starting with
the papers ``Design by Contract with JML''
[Leavens-Cheon06]
and ``JML: A notation for detailed design''
[Leavens-Baker-Ruby99], and continuing with the
paper ``Preliminary Design of JML'' [Leavens-Baker-Ruby06].
These are all available from the JML web site
@file{http://www.jmlspecs.org/}, where further readings and examples
may also be found.

Readers with the necessary background,
and users wanting more details may, we hope, profit from reading this manual.
We suggest reading this manual starting with chapters 1-3,
skimming chapter 4 quickly,
skimming chapter 5 to get the idea of what declarations mean in JML,
and then reading the chapters on class specifications (chapter 6)
and method specifications (chapter 7),
paying particular attention to the examples.
After that, one can use the rest of this manual as a reference.

The rest of this chapter describes some of the fundamental ideas and
background behind JML.

@menu
* Behavioral Interface Specifications::  
* A First Example::             
* What is JML Good For?::       
* Status and Plans for JML::    
* Historical Precedents::       
* Acknowledgments::             
@end menu

@node Behavioral Interface Specifications, A First Example, Introduction, Introduction
@c  node-name,  next,  previous,  up
@section Behavioral Interface Specifications

@cindex behavioral interface specification
@cindex interface specification
@cindex specification, of interface behavior
@cindex Larch
@cindex Larch style specification language
@cindex Eiffel
@cindex Meyer
@cindex Guttag
@cindex Horning
@cindex Wing
@cindex model-oriented specification
@cindex precondition
@cindex postcondition
@cindex LSL
@cindex Larch Shared Language (LSL)
@cindex vocabulary
@cindex Rosenblum
@cindex Leino
@cindex Nelson
@cindex Saxe
@cindex Lamport
@cindex Leavens
JML is a @dfn{behavioral interface specification language} (BISL)
that builds on the Larch approach [Guttag-Horning93] [Guttag-Horning-Wing85b]
and that found in APP [Rosenblum95] and Eiffel [Meyer92b] [Meyer97].
In this style of specification,
which might be called model-oriented [Wing90a],
one specifies both the interface of a method or abstract data type
and its behavior [Lamport89].
In particular JML builds on the work done by Leavens and others in Larch/C++
[Leavens-Baker99] [Leavens96b] [Leavens97c].
(Indeed, large parts of this manual are adapted wholesale from
the Larch/C++ reference manual [Leavens97c].)
Much of JML's design was heavily influenced by the work of Leino and his
collaborators [Leino95] [Leino95b] [Leino98] [Leino-etal00]
[Leino-Nelson-Saxe00]. 
JML continues to be influenced by ongoing work in formal
specification and verification.
A collection of papers relating directly to JML and its design is
found at 
@file{http://www.jmlspecs.org/papers.shtml}.

@cindex interface
@cindex interface, method
@cindex interface, field
@cindex interface, type
The @dfn{interface} of the method or type is
the information needed to use it from other programs.  In the case of
JML, this is the Java syntax and type information needed to call a
method or use a field or type.  For a method the interface 
includes such things as the name of the method, its modifiers
(including its visibility and whether it is final)
its number of arguments, its return type, what exceptions it may
throw, and so on. 
For a field the interface includes its name and type, and its modifiers.
For a type, the interface
includes its name, its modifiers, its package, whether it is a class
or interface, its supertypes, and the interfaces of the fields and methods it
declares and inherits.
JML specifies all such interface information using Java's syntax.

@cindex behavior
@cindex method, behavior of
@cindex Borgida
@cindex precondition
@cindex postcondition, normal
@cindex postcondition, exceptional
@cindex frame axiom
A @dfn{behavior} of a method or type describes a set of state
transformations that it can perform.
A behavior of a method is specified by describing:
a set of states in which calling the method is defined,
a set of locations that the method is allowed to assign to (and hence change),
and the relations between the calling state and
the state in which it either returns normally, throws an exception,
or for which it might not return to the caller.
The states for which the method is defined are formally described by
a logical assertion, called the method's @dfn{precondition}.
The allowed relationships between these states
and the states that may result from normal return are formally described
by another logical assertion called the method's @dfn{normal postcondition}.
Similarly the relationships between these pre-states
and the states that may result from throwing an exception
are described by the method's @dfn{exceptional postcondition}.
The states for which the method need not return to the caller are
described by the method's @dfn{divergence condition}; however,
explicit specification of divergence is rarely used in JML.
The set of locations the method is allowed to assign to
is described by the method's @dfn{frame axiom} [Borgida-etal95].
In JML one can also specify other aspects of behavior, such as the
time a method can use to execute and the space it may need.

@cindex abstract data type
@cindex ADT
@kindex @code{spec_public}
@kindex @code{spec_protected}
@cindex abstract value, of an ADT
@cindex abstract fields
@cindex Spivey
@cindex Wills
@cindex Cheon
@cindex Hayes
@cindex Fresco
@cindex Z
The behavior of an abstract data type (ADT), which is implemented by a
class in Java, is specified by describing a set of abstract fields for
its objects and by specifying the behavior of its methods (as described
above).  The abstract fields for an object can be specified either by
using JML's model and ghost fields [Cheon-etal05], which are
specification-only fields, or by specifying some of the fields used in
the implementation as @code{spec_public} or @code{spec_protected}.
These declarations allow the specifier using JML to model an
instance as a collection of abstract instance variables,
in much the same way as other specification languages, such as Z [Hayes93]
[Spivey92] or Fresco [Wills92b].

@node A First Example, What is JML Good For?, Behavioral Interface Specifications, Introduction
@c  node-name,  next,  previous,  up
@section A First Example

For example, consider the following JML specification
of a simple Java abstract class @code{IntHeap}. (An explanation of
the notation follows the specification.  This specification, like the
others in this manual, ships with the JML release in the
@file{JML/org/jmlspecs/samples/jmlrefman} directory.)

@pindex @code{IntHeap}
@example
@group
@include local/IntHeap.java.texinfo
@end group
@end example

The interface of this class consists of lines 1, 3, 15, and 18.
Line 3 specifies the class name, and the fact that the class
is both public and abstract. Lines 15 and 18, apart from their comments,
give the interface information for the methods of this class.

@kindex @code{//@@}
@kindex @code{/*@@}
@kindex @code{@@*/}
@kindex @code{*/}
@kindex @code{//}
@cindex annotation comments
@cindex comments, annotations in
The behavior of this class is specified in the JML annotations found
in the special comments that have an at-sign (@code{@@}) as their
first character following the usual comment beginning.
Such lines look like comments to Java, but are interpreted by JML and
its tools.
For example, line 5 starts with an annotation comment marker of the form
@code{//@@}, and this annotation continues until the @code{//} towards
the end of the line, which starts a comment within the annotation
which even JML ignores.
The other form of such annotations can be seen on lines 7 through 14,
line 17, and on lines 15 and 18.
These annotations start with the characters @code{/*@@}
and end with either @code{@@*/} or @code{*/}; within such annotations,
at-signs (@code{@@}) at the beginnings of lines are ignored by JML.
Note that there can be no space between the start of comment marker,
either @code{//} or @code{/*} and the first at-sign;
thus @code{// @@} starts a comment, not an annotation.
(@xref{Lexical Conventions}, for more details about annotations.)

@cindex model field
The first annotation, on line 5 of the figure above,
gives the specification of a field,
named @code{elements}, which is part of this class's behavioral specification.
Ignoring, for the moment the extra JML modifiers,
one should think of this field, in essence, as being declared like:
@example
   public int[] elements;
@end example
@noindent
That is, it is a public field with an integer array type;
within specifications it is treated as such.
However, because it is declared in an annotation, this field cannot be
manipulated by Java code.  Therefore, for example, the fact that the
field is declared public is not a problem, because it cannot be
directly changed by Java code.

@kindex @code{model}
@cindex model fields, of an ADT
@cindex Cheon
Such declarations of fields in annotations should be marked as
specification-only fields, using the JML modifier
@code{model}.@footnote{
This is the usual way to declare a specification-only field;
it is also possible to use the
@code{ghost} modifier (@pxref{Model and Ghost}).
}
A model field should be thought of as an abstraction of a set of concrete
fields used in the implementation of this type and its subtypes.
(@xref{Represents Clauses}, for a discussion of how to specify the
connection between the concrete fields and such model fields.  See also
the paper by Cheon et al. [Cheon-etal05].) That is, we imagine that
objects that are instances of the type @code{IntHeap} have such a field,
whose value is determined by the concrete fields that are known to Java
in the actual object.  Of course at runtime, objects of type
@code{IntHeap} have no such field, the model fields are purely
imaginary.  Model fields are thus a convenient fiction that is useful
for describing the behavior of an ADT.  One does not have to worry about
their cost (in space or time), and should only be concerned with how
they clarify the behavior of an ADT.

@kindex @code{non_null}
The other annotation used on line 5 is @code{non_null}.
This just says that in any publicly-visible
state, the value of @code{elements} must not be @code{null}.
It is thus a simple kind of invariant (@pxref{Invariants}).

@cindex heavyweight specification
@kindex @code{;}
In the above specification of @code{IntHeap},
the specification of each method precedes its interface declaration.
This follows the usual convention of Java tools, such as JavaDoc,
which put such descriptive information in front of the method.  In
JML, it is also possible to put the specification just before the
semicolon (@code{;}) following the method's interface information
(@pxref{Method Specifications}), but
we will usually not to do that in this document.

@cindex public specification
@kindex @code{public}
@cindex Ruby
@cindex Leavens
The specification of the method @code{largest} is given on lines 7
through 15. Line 7 says that this is a public, normal behavior specification.
JML permits several different specifications for a given method,
which can be of different privacy levels [Ruby-Leavens00] [Leavens-Mueller07].
The modifier @code{public} says that the specification is intended for
use by clients.
(If the privacy modifier had been
@code{protected}, for example,
then the specification would have been intended for subclasses.)

@kindex @code{normal_behavior}
@cindex exceptions, prohibiting
@cindex heavyweight specification, vs. lightweight
@cindex lightweight specification, vs. heavyweight
@cindex completeness, of specification
@cindex specification, completeness of
The keyword @code{normal_behavior} tells JML several things.
First, it says that the specification is a heavyweight
method specification, as opposed to a lightweight method specification
like that given on line 17.
A @dfn{heavyweight} specification uses one of JML's behavior keywords,
like @code{normal_behavior}, which tells JML that the method
specification is intended to be complete.  By contrast, a
@dfn{lightweight} specification does not use one of JML's behavior
keywords, and tells JML that the specification is incomplete in the
sense that it contains only some of what the specifier had in mind.@footnote{
Lightweight specifications come from ESC/Java.
}
Second, the keyword @code{normal_behavior} tells JML that when the
precondition of this method is met, then the method must return
normally, without throwing an exception. In other words, it says that
the exceptional postcondition is @code{false}, which prohibits the
method from throwing an exception when the precondition holds.
(Third, it says that the divergence condition defaults to @code{false}.
@xref{Method Specifications}, for more details.)

@cindex requires clause
@cindex assignable clause
@cindex ensures clause
@cindex model fields
@kindex @code{requires}
@kindex @code{assignable}
@kindex @code{ensures}
The heart of the method specification of @code{largest} is found on
lines 7 through 13.  This part of the specification gives the method's
precondition, on line 8, frame axiom, on line 9, and normal postcondition, on
lines 10 through 13.  The precondition is contained in the
@code{requires} clause on line 8.  The frame axiom is contained in the
@code{assignable} clause on line 9.  The normal postcondition is
contained in the @code{ensures} clause on lines 10-13.@footnote{
JML also has various synonyms for these keywords; one can use @code{pre}
for @code{requires}, @code{modifies} or @code{modifiable} for
@code{assignable}, and @code{post} for @code{ensures} if desired.
@xref{Method Specifications}, for more details.
}[[[Doesn't this paragraph just duplicate what has already been said - DRC]]]

@cindex precondition
The precondition in the requires clause on line 8 says that the length of
@code{elements} must be at least 1 before this method can be called.
If that is not true, then the method is under no obligation to fulfill
the rest of the specified behavior.

@cindex frame axiom
@cindex location 
@kindex @code{assignable}
@kindex @code{\nothing}
@cindex @code{\}, convention for expression keywords
The frame axiom in the assignable clause on line 9 says that the method may not
assign to any locations (i.e. fields of objects) that are visible
outside the method and which existed before the method started
execution.  (The method may still modify its local variables.)  This
form of the frame axiom is quite common.@footnote{
However, unlike Larch
BISLs and earlier versions of JML, this is not the default for an
omitted @code{assignable} clause (@pxref{Assignable Clauses}).  Thus
line 9 cannot be omitted without changing the meaning of the
specification.
}
Note that in assignable clauses and in assertions, JML
uses keywords that start with a backslash (@code{\}), to avoid
interfering with identifiers in the user's program.  Examples of this
are @code{\nothing} on line 9 and @code{\result} on line 10.

@kindex @code{\result}
@kindex @code{\max}
@cindex range predicate
@cindex quantifier
@cindex quantifier body
@cindex body, of quantifier
@cindex postcondition
The postcondition in the ensures clause, on lines 10 through 13,
says that the result of the method (@code{\result})
must be equal to the maximum integer found in the array
@code{elements}.
This postcondition uses JML's @code{\max} quantifier (lines 11 through
13).  Such a quantifier is always parenthesized, and can consist of
three parts.  The first part of a quantifier
is a declaration of some quantified variables,
in this case the integer @code{j} on line 11.
The second part is a @dfn{range predicate}, on line 12,
which constrains the quantified variables.  The third part is the @dfn{body} of
the quantifier, on line 13, which in this case describes the elements
of the array from which the maximum value is taken.

@kindex @code{pure}
The methods @code{largest} and @code{size} are both specified
using the JML modifier @code{pure}.  This modifier says that the
method has no side effects, and allows the method to be used in
assertions if desired.

@cindex lightweight specification, example of
The method @code{size} is specified using a lightweight
specification, which is given on line 17.  
The ensures clause on line 17 says nothing about the precondition,
frame axiom, exceptional postcondition, or divergence condition of @code{size},
although the use of @code{pure} on line 18 gives an implicit frame
axiom.  Such a form of specification is useful when one only cares to
state (the important) part of a method's specification.
It is also useful when first learning JML, and when one is using tools,
such as ESC/Java2, that do not need heavyweight specifications.

@cindex completeness, of method specifications
@cindex Meyer
@cindex Liskov
@cindex Guttag 
The specifications of the method @code{largest} above is
very precise: it gives a complete specification of what the method does. 
Even the specification of @code{size} has a fairly complete normal
postcondition.
We can also give JML specifications that are far less detailed.
For example, we could just specify that the result of @code{size} is
non-negative, with a normal postcondition such as
@example
 //@@ ensures \result >= 0;
@end example
@noindent 
instead of the postcondition given earlier.
Such incomplete specifications give considerably more freedom to
implementations, and can often be useful for hiding implementation
details.
However, one should try to write specifications that capture the important
properties expected of callers (preconditions) and implementations
(postconditions) [Meyer92a] [Liskov-Guttag86].

@node What is JML Good For?, Status and Plans for JML, A First Example, Introduction
@c  node-name,  next,  previous,  up
@section What is JML Good For?

@cindex utility, of JML
@cindex usefulness, of JML

JML is a formal specification language tailored to Java.
Its basic use is thus the formal specification of
the behavior of Java program modules.
As it is a behavioral interface specification language,
JML specifies how to use such Java program modules from
@emph{within} a Java program; hence JML is @emph{not} designed
for specifying the behavior of an entire program.
So the question ``what is JML good for?'' really boils down to
the following question: what good is formal specification
for Java program modules?

@cindex benefits, of JML
@cindex Burdy
The two main benefits in using JML are:
@itemize @bullet
@item
the precise, unambiguous specification
of the behavior of Java program modules (i.e., classes and interfaces),
and documentation of Java code,

@item
the possibility of tool support [Burdy-etal03].
@end itemize

@cindex concurrency, lack of support in JML
@cindex threads, specification of
@cindex behavior, sequential
@cindex sequential behavior
Although we would like tools that would help with reasoning about
concurrent aspects of Java programs, the current version of JML
focuses on the sequential behavior of Java code.
While there is work in progress on extending JML to support
concurrency, the current version of JML does not have features that help
specify how Java threads interact with each other.
JML does not, for example, allow the specification of elaborate
temporal properties, such as coordinated access to shared variables or the
absence of deadlock.  Indeed, we assume, in the rest of this manual, that
there is only one thread of execution in a Java program annotated with
JML, and we focus on how the program manipulates object states.  To summarize,
JML is currently limited to sequential specification; we say that JML
specifies the @dfn{sequential behavior} of Java program modules.

In terms of detailed design documentation,
a JML specification can be a completely formal contract about
an interface and its sequential behavior.
Because it is an interface specification,
one can record all the Java details about the interface,
such as the parameter mechanisms, whether the method is @code{final},
@code{protected}, etc.;
if one used a specification language such as VDM-SL or Z,
which is not tailored to Java, then one could not record such details
of the interface, which could cause problems in code integration.
For example, in JML one can specify the precise conditions under
which certain exceptions may be thrown, something which is difficult
in a specification language that is not tailored to Java and that
doesn't have the notion of an exception.

@cindex methodology, and JML
@cindex programming method, and JML
@cindex notation, and methodology
When should JML documentation be written?
That is up to you, the user.
A goal of JML is to make the notation indifferent to the precise
programming method used.
One can use JML either before coding or as documentation of finished code.
While we recommend doing some design before
coding, JML can also be used for documentation after the code is written.

@cindex uses, of JML
@cindex reasons, for formal documentation
@cindex formal specification, reasons for using
@cindex formal documentation
Reasons for formal documentation of interfaces and their
behavior, using JML, include the following.
@itemize @bullet
@item
One can ship the object code for a class library to customers,
sending the JML specifications but not the source code.
Customers would then have documentation that is precise,
unambiguous, but not overly specific.
Customers would not have the code, protecting proprietary rights.
In addition, customers would not rely on details of the implementation
of the library that they might otherwise glean from the code,
easing the process of improving the code in future releases.

@item
@cindex Guttag
@cindex Horning
@cindex Hall
One can use a formal specification to analyze certain properties of
a design carefully or formally
(see [Hall90] and Chapter 7 of [Guttag-Horning93]).
In general, the act of formally specifying a program module has
salutary effects on the quality of the design.

@item
@cindex Huisman
@cindex Poll
@cindex Jacobs
One can use the JML specification as an aid to careful reasoning
about the correctness of code, or even for formal verification
[Huisman01] [Jacobs-Poll01] [Ruby06].
@c [[[Erik, you can add more refs for this also if you like...]]]

@item
@cindex Burdy
JML specifications can be used by several tools that can help debug
and improve the code [Burdy-etal03].
@end itemize

@cindex documentation, of design decisions
@cindex design, documentation of
@cindex Ruby
@cindex Leavens
There is one additional benefit from using JML.
It is that JML allows one to record not just public interfaces
and behavior, but also some detailed design decisions.
That is, in JML, one can specify not just the public
interface of a Java class,
but also behavior of a class's protected and private interfaces.
Formally documenting a base class's protected interface
and ``subclassing contract''
allows programmers to implement derived
classes of such a base class without looking at its code
[Ruby-Leavens00] [Ruby06].

Recording the private interface of a class may be helpful
in program development or maintenance.
Usually one would expect that the public interface of a class would
be specified, and then separate, more refined specifications would
be given for use by derived classes and for detailed implementation
(and friend classes).
(@xref{Refinement}, for how to record each level in JML.)

@cindex goals, of JML
@cindex Ruby
@cindex Leavens
@cindex Baker
The reader may also wish to consult
the ``Preliminary Design of JML'' [Leavens-Baker-Ruby06]
for a discussion of the goals that are behind JML's design.
Apart from the improved precision in the specifications and
documentation of code, the main advantage of using a formal specification 
language, as opposed to informal natural language, is the possibility of 
tool support.
One specific goal that has emerged over time is that JML should be
able to unify several different tool-building efforts in the area of
formal methods.  

@cindex tool support
@cindex parsing
@cindex type checking
@cindex visibility
@kindex @code{public}
@kindex @code{private}
The most basic tool support for JML -- simply parsing and typechecking --
is already useful.
Whereas informal comments in code are typically not kept up to date
as the code is changed, the simple act of running the typechecker
will catch any JML assertions referring to parameter or field names 
that no longer exist, and all other typos of course.
Enforcing the visibility rules can also provide useful feedback;
for example, a precondition of a @code{public} method which refers
to a @code{private} field of an object is suspect.

@cindex tool support
@cindex Leino
@cindex Huisman
@cindex Jacobs
@cindex Ernst
@cindex Cheon
@cindex Leavens
@cindex Daikon
@cindex LOOP
@cindex ESC/Java
@cindex jmldoc
@cindex Burdy
@cindex jmlc
Of course, there are more exciting forms of tool support than just 
parsing and typechecking.  In particular JML is designed to support static
analysis (as in ESC/Java [Leino-etal00]), formal verification
(as in the LOOP tool [Huisman01] [Jacobs-etal98]),
recording of dynamically obtained invariants (as in Daikon [Ernst-etal01]),
runtime assertion checking (as in JML's runtime assertion checker,
jmlc [Cheon-Leavens02b] [Cheon03]), unit testing [Cheon-Leavens02],
and documentation (as in JML's jmldoc tool).
The paper by Burdy et al.@ [Burdy-etal03] is a recent survey of tools
for JML.
The utility of these tools is the ultimate answer to the question of
what JML is good for.

@node Status and Plans for JML, Historical Precedents, What is JML Good For?, Introduction
@c  node-name,  next,  previous,  up
@section Status and Plans for JML

@cindex JML, status
@cindex JML, plans
@cindex status, of JML
@cindex JML status and plans
@cindex plans, for JML
[[[This section needs updating.]]]JML is still in development.
As you can see, this reference manual is still a draft,
and there are some holes in it.
[[[And some notes for the authors by the authors that look like this.]]]

@cindex influences, on JML evolution
@cindex JML, evolution
@cindex MultiJava
@cindex Clifton
@cindex Corbett
@cindex Bandera
Influences on JML that may lead to changes in its design include
our desire to specify programs written using the unique features of
MultiJava
[Clifton-etal00],
an eventual integration with Bandera [Corbett-etal00] or other tools for
specification of concurrency, aspect-oriented programming,
and the evolution of Java itself.
Another influence is the ongoing effort to use JML on examples,
in designing the JML tools, and efforts to give a formal semantics
to JML.

@node Historical Precedents, Acknowledgments, Status and Plans for JML, Introduction
@c  node-name,  next,  previous,  up
@section Historical Precedents

@cindex Meyer
@cindex Wing
@cindex Larch
@cindex Eiffel
@cindex Guttag
@cindex Horning
@cindex Leavens
@cindex refinement calculus
@cindex Back
@cindex von Wright
@cindex Morgan
@cindex Vickers
JML combines ideas from Eiffel [Meyer92a] [Meyer92b] [Meyer97]
with ideas from model-based specification languages such as
VDM [Jones90] and the Larch family
[Guttag-Horning93] [LeavensLarchFAQ] [Wing87] [Wing90a].
It also adds some ideas from the refinement calculus
[Back88] [Back-vonWright89a] [Back-vonWright98] [Morgan-Vickers94] [Morgan94]
(@pxref{Refinement}).
In this section we describe the advantages and disadvantages
of these approaches.
Readers unfamiliar with these historical precedents may want to skip
this section.

@cindex Hoare
@cindex abstract value
@cindex value, abstract
@cindex operation
@cindex type, abstract
@cindex datatype
@cindex abstract data type
@cindex precondition
@cindex postcondition
Formal, model-based languages such as those typified by the
Larch family build on ideas found originally in Hoare's work.
Hoare used pre- and postconditions to describe the semantics of computer
programs in his famous article [Hoare69].
Later Hoare adapted these axiomatic techniques to the specification
and correctness proofs of abstract data types [Hoare72a].
To specify an ADT, Hoare described a mathematical set of abstract values
for the type, and then specified pre- and postconditions for each of the
operations of the type in terms of how the abstract values of objects
were affected.
For example, one might specify a class @code{IntHeap}
using abstract values of the form @code{empty} and @code{add(i,h)},
where @code{i} is an @code{int} and @code{h} is an @code{IntHeap}.
These notations form a mathematical vocabulary used in the rest of the
specification.

@cindex Meyer
@cindex Liskov
@cindex Guttag
@cindex Parnas
There are two advantages to writing specifications with abstract values
instead of directly using Java variables and data structures.
The first is that by using abstract values,
the specification does not have to be
changed when the particular data structure used in the program is changed.
This permits different implementations of the same specification
to use different data structures.
Therefore the specification forms a contract between the rest
of the program in the implementation, which ensures that the rest of the
program is also independent of the particular data structures used
[Liskov-Guttag86] [Meyer97] [Meyer92a] [Parnas72].
Second, it allows the specification to be written even when
there are no implementation data structures, as is the case for @code{IntHeap}.

@cindex VDM
@cindex Z
@cindex trait function
@cindex operator, of LSL
@cindex LSL Handbook
@cindex handbook, for LSL
@cindex Handbook, for LSL
@cindex trait
@cindex VDM-SL
@cindex Fitzgerald
@cindex Larsen
@cindex ISO
@cindex Jones
@cindex Guttag
@cindex Horning
@cindex Hayes
@cindex Spivey
This idea of model-oriented specification has been followed in VDM
[Jones90], VDM-SL [Fitzgerald-Larsen98] [ISO96], Z [Hayes93] [Spivey92],
and the Larch family [Guttag-Horning93].
In the Larch approach,
the essential elaboration of Hoare's original idea is that
the abstract values also come with a set of operations.
The operations on abstract values
are used to precisely describe the set of abstract values
and to make it possible to abbreviate interface specifications
(pre- and postconditions for methods).
In Z one builds abstract values using tuples, sets, relations, functions,
sequences, and bags; these all come with pre-defined operations that
can be used in assertions.
In VDM one has a similar collection of mathematical tools to describe
abstract values, and another set of pre-defined operations.
In the Larch approach, there are some pre-defined kinds of abstract values
(found in Guttag and Horning's LSL Handbook, Appendix A of [Guttag-Horning93]),
but these are expected to be extended as needed.
(The advantage of being able to extend the mathematical vocabulary is
similar to one advantage of object-oriented programming:
one can use a vocabulary that is close to the way one thinks about a
problem.)

@cindex Hoare
@cindex Meyer
@cindex Larch/C++
@cindex VDM
However, there is a problem with using mathematical notations for
describing abstract values and their operations.  The problem is that
such mathematical notations are an extra burden on a programmer who is
learning to use a specification language.
The solution to this problem
is the essential insight that JML takes from the Eiffel
language [Meyer92a] [Meyer92b] [Meyer97].
Eiffel is a programming language with built-in specification
constructs.  It features pre- and postconditions, although it has no
direct support for frame axioms.
Programmers like Eiffel because they can easily read the assertions,
which are written in Eiffel's own expression syntax.  However, Eiffel
does not provide support for specification-only variables, and it does
not provide much explicit support for describing abstract values.
Because of this, it is difficult to write specifications that are as
mathematically complete in Eiffel as one can write in a language like
VDM or Larch/C++.

JML attempts to combine the good features of these approaches.  From
Eiffel we have taken the idea that assertions can be written in a
language that is based on Java expressions.
@kindex @code{\old}
We also adopt the ``@code{old}'' notation from Eiffel, which appears
in JML as @code{\old}, instead of the Larch-style annotation of names
with state functions.  To make it easy to write more complete
specifications, however, we use various semantic ideas from
model-based specification languages.  In particular we use a variant
of abstract value specifications, where one describes the abstract
value of an object implicitly using several model fields.  These
specification-only fields allow one to implicitly partition the
abstract value of an object into smaller chunks, which helps in
stating frame axioms.  More importantly, we hide the mathematical
notation behind a facade of Java classes.  This makes it so the
operations on abstract values appear in familiar (although perhaps
verbose) Java notation, and also insulates JML from the details of the
particular mathematical logic used to do reasoning.


@node Acknowledgments,  , Historical Precedents, Introduction
@c  node-name,  next,  previous,  up
@section Acknowledgments

@cindex acknowledgments
@cindex NSF
@cindex Rockwell International Corporation
The work of Leavens and Ruby was supported in part by
a grant from Rockwell International Corporation
and by NSF grant CCR-9503168.
Work on JML by Leavens, and Ruby was also supported in part by
NSF grant CCR-9803843.
Work on JML by Cheon, Clifton, Leavens, Ruby, and others
has been supported in part by NSF grants CCR-0097907, CCR-0113181,
CCF-0428078, and CCF-0429567. 
The work of Poll is partly supported by the Information Society Technologies 
(IST) Programme of the European Union,
as part of the VerifiCard project, IST-2000-26328.

@cindex Jacobs
@cindex Leino
@cindex M@"uller
@cindex van den Berg
@cindex Stata
@cindex Poetzsch-Heffter
Thanks to Bart Jacobs, Rustan Leino, @c Peter M@"uller,
Arnd Poetzsch-Heffter,
and Joachim van den Berg,
for many discussions about the semantics of JML specifications.
Thanks for Raymie Stata for
spearheading an effort at Compaq SRC to unify JML and ESC/Java, and to
Rustan and Raymie for many interesting ideas and discussions that have
profoundly influenced JML.
@cindex Freitas
@cindex Greene
@cindex Ravelo
Thanks to Leo Freitas, Robin Greene, and Jesus Ravelo
for comments and questions on earlier versions of this document.
@cindex Dietl
Thanks to Werner Dietl for corrections to the chapter on the Universe
Type System.
Thanks to the many who have worked on the
JML checker used to check the specifications in this document.
@c @cindex Kiniry
@c Thanks to David and Joe Kiniry for various corrections to this document.

See the ``Preliminary Design of JML'' [Leavens-Baker-Ruby06]
for more acknowledgments relating to the earlier history, design,
and implementation of JML.

@c ------ chapter Fundamental Concepts --------
@node Fundamental Concepts, Syntax Notation, Introduction, Top
@c  node-name,  next,  previous,  up
@chapter Fundamental Concepts

@cindex concepts, fundamental
@cindex fundamental concepts
This chapter discusses fundamental concepts that are used in
explaining the semantics of JML.

@menu
* Types can be Classes and Interfaces::  
* Model and Ghost::             
* Lightweight and Heavyweight Specifications::  
* Privacy Modifiers and Visibility::  
* Instance vs. Static::         
* Locations and Aliasing::      
* Expression Evaluation and Undefinedness::  
* Null is Not the Default::     
* Language Levels::             
@end menu

@node Types can be Classes and Interfaces, Model and Ghost, Fundamental Concepts, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Types can be Classes and Interfaces

@cindex type
@cindex primitive value type
In this manual we use @dfn{type} to mean either a class, interface, or
primitive value type in Java.  (Primitive value types include
@code{boolean}, @code{int}, etc.)

@cindex reference type
A @dfn{reference type} is a type that is not a primitive value type,
that is either a class or interface.  When it is not necessary to
emphasize that primitive value types are not included, we often shorten
``reference type'' to just ``type''.

@node Model and Ghost, Lightweight and Heavyweight Specifications, Types can be Classes and Interfaces, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Model and Ghost

@cindex model features
@cindex ghost features
@kindex @code{model}
@kindex @code{model import}
@kindex @code{ghost}
In JML one can declare various names with the modifier @code{model}; for
example one can declare model fields, methods, and even types.
One can also declare some fields as @code{ghost} fields.
JML also has a @code{model import} directive (@pxref{Compilation Units}).

@cindex model, meaning of
The meaning of a feature declared with @code{model} is that it is only
present for specification purposes.  For example a model field is an
imaginary field that is only used for specifications and is not
available for use in Java code outside of annotations.
Similarly, a model method is a method that can be used in annotations,
but cannot be used in ordinary Java code.  A model import directive
imports names that can be used only within annotations.

@cindex model field
@cindex abstract field
@cindex concrete field
@cindex Cheon
@cindex Leino
@cindex Hoare
The most common and useful model declarations are model fields.
A model field should be thought of as the abstraction of one or more
non-model (i.e., Java or @dfn{concrete}) fields [Cheon-etal05].
(By contrast, some authors refer to what JML calls model fields as
``abstract fields'' [Leino98].)
The value of a model field is determined by the concrete fields it
abstracts from; in JML this relationship is specified by a
@code{represents} clause (@pxref{Represents Clauses}).
(Thus the values of the model fields in an object determines its
``abstract value'' [Hoare72a].) 
A model field also defines a data group [Leino98],
which collects model and concrete fields and is used to tell JML what
concrete fields may be assigned by various methods (@pxref{Data Groups}).

@cindex model method
@cindex model type
Unlike model fields, model methods and model types are not
abstractions of non-model methods or types.  They are simply methods or
types that we imagine that the program has, to help in a specification.

@cindex ghost fields
@kindex @code{ghost}
A @code{ghost} field is similar to a model field, in that it is
also only present for purposes of specification and thus cannot be
used outside of annotations.
However, unlike a model field, a ghost field does not have a value
determined by a represents clause; instead its value is directly
determined by its initialization or by a @var{set-statement}
(@pxref{Statements and Annotation Statements}).

@cindex model features, and namespace issues
@cindex namespace, for model features
@cindex namespace, for ghost fields
@cindex ghost fields, and namespace
@cindex name clash, between Java and JML-only names, resolving
@cindex Java vs. JML-only names, resolving conflicts
@cindex JML-only vs. Java names, resolving conflicts
Although these model and ghost names are used only for specifications,
JML uses the same namespace for such names as for normal Java names.
Thus, one cannot declare a field to be both a model (or ghost) field and
a normal Java field in the same class (or in a refinement, @pxref{Refinement}).
Similarly, a method is either a model method or not.
In part, this is done because JML has no syntactic distinction between
Java and JML field access or method calls.
This decision makes it an error for someone to use the same name as a
model or ghost feature in an implementation.
In such a case if the Java code is considered to be the goal, one can
either change the name of the JML feature or have one declaration in which
the Java feature is modified with the JML modifier @code{spec_public}.
@xref{Privacy Modifiers and Visibility}, for more about @code{spec_public}.

@node Lightweight and Heavyweight Specifications, Privacy Modifiers and Visibility, Model and Ghost, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Lightweight and Heavyweight Specifications

@cindex lightweight specification
@cindex heavyweight specification
@cindex specification, lightweight
@cindex specification, heavyweight
In JML one is not required to specify behavior completely.  Indeed, JML
has a style of method specification case, called @dfn{lightweight}, in
which the user only says what interests them.  On the other hand, in a
@dfn{heavyweight} specification case, JML expects that the user is fully
aware of the defaults involved. In a heavyweight specification case,
JML expects that a user only omits parts of the specification case
when the user believes that the default is appropriate.

@kindex @code{normal_behavior}
@kindex @code{exceptional_behavior}
@kindex @code{behavior}
Users distinguish these between such cases of method specifications by
using different syntaxes. @xref{Organization of Method Specifications},
for details, but in essence in a method specification case that
uses one of the behavior keywords (such as @code{normal_behavior},
@code{exceptional_behavior}, or @code{behavior}) is heavyweight,
while one that does not use such a keyword is lightweight.

@node Privacy Modifiers and Visibility, Instance vs. Static, Lightweight and Heavyweight Specifications, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Privacy Modifiers and Visibility

@cindex access control rules
@cindex privacy modifiers
@cindex visibility
@kindex @code{public}
@kindex @code{protected}
@kindex @code{private}
@cindex default access
@cindex package visibility
@cindex Gosling
Java code that is not within an annotation uses the usual access control
rules for
determining visibility (or accessibility) of Java [Arnold-Gosling-Holmes00]
[Gosling-etal00].
That is, a name declared in package @i{P} and type @i{P.T}
may be referenced from outside @i{P}
only if it is declared as @code{public},
or if it is declared as @code{protected}
and the reference occurs within a subclass of @i{P.T}.
This name may be referenced from within @i{P}
but outside of @i{P.T}
only if it is declared as @code{public}, default access,
or @code{protected}.
Such a name may always be referenced from within @i{P.T},
even if it is declared as @code{private}.
See the Java language specification [Gosling-etal00]
for details on visibility rules
applied to nested and inner classes.

@cindex Leavens
@cindex Baker
@cindex Ruby
@cindex visibility, in JML
@cindex access control, in JML
@cindex annotation context
Within annotations, JML imposes some extra rules in addition
to the usual Java visibility rules [Leavens-Baker-Ruby06].
These rules depend not just on the declaration of the name but also on
the visibility level of the context that is referring to the name in
question. 
For purposes of this section, the @dfn{annotation context} of a
reference to a name is the smallest grammatical unit with an attached
(or implicit) visibility.  For example, this annotation context can be a method
specification case, an invariant, a history constraint, or a field declaration.
The visibility level of such an annotation context can be @code{public}, 
@code{protected}, @code{private}, or default (package) visibility. 

The JML rule, in essence, is that an annotation context cannot refer to names
that are more hidden than the context's own visibility.
That is, for a reference to a name @i{x} to be legal,
the visibility of the annotation context that contains the
reference to @i{x} must be at least as permissive as the declaration
of @i{x} itself.  The reason for this restriction is that
the people who are allowed to see the annotation should be able to
see each of the names used in that annotation [Meyer97],
otherwise they might not understand it.  For example, public clients
should be able to see all the declarations of names in publicly
visible annotations, hence public annotations should not contain
protected, default access, or private names.

In more detail, 
suppose @i{x} is a name declared in package @i{P} and type @i{P.T}.
@itemize @bullet
@item
An expression in a public annotation context
(e.g., in  a public method specification)
can refer to @i{x} only if @i{x} is declared as @code{public}.

@item
An expression in a protected annotation context
(e.g., in a protected method specification)
can refer to @i{x} only if @i{x} is declared as @code{public}
or @code{protected}, and @i{x} must also be visible according to
Java's rules (so if @i{x} is @code{protected},
then the reference must either be from within @i{P}
or, if it is from outside @i{P},
then the reference must occur in a subclass of @i{P.T}).

@item
An expression in a default (package) visibility annotation context
(e.g., in a default visibility method specification)
can refer to @i{x} only if @i{x} is declared as @code{public},
@code{protected}, or with default visibility,
and @i{x} must also be visible according to
Java's rules (so if @i{x} has default visibility,
then the reference must be from within @i{P}).

@item
An expression in a @code{private} visibility annotation context
(e.g., in a private method specification)
can refer to @i{x} only if @i{x} is visible according to
Java's rules (so if @i{x} has private visibility,
then the reference must be from within @i{P.T}).
@end itemize

In the following example, the comments on the right show which uses of
the various privacy level names are legal and illegal.  Similar
examples could be given for method specifications, history
constraints, and so on.

@pindex @code{PrivacyDemoLegalAndIllegal}
@example
public class PrivacyDemoLegalAndIllegal @{
   public int pub;
   protected int prot;
   int def;
   private int priv;

   //@@ public invariant pub > 0;      // legal
   //@@ public invariant prot > 0;     // illegal!
   //@@ public invariant def > 0;      // illegal!
   //@@ public invariant priv < 0;     // illegal!

   //@@ protected invariant pub > 1;   // legal
   //@@ protected invariant prot > 1;  // legal
   //@@ protected invariant def > 1;   // illegal!
   //@@ protected invariant priv < 1;  // illegal!

   //@@ invariant pub > 1;              // legal
   //@@ invariant prot > 1;             // legal
   //@@ invariant def > 1;              // legal
   //@@ invariant priv < 1;             // illegal!

   //@@ private invariant pub > 1;      // legal
   //@@ private invariant prot > 1;     // legal
   //@@ private invariant def > 1;      // legal
   //@@ private invariant priv < 1;     // legal
@}
@end example

@cindex visibility, in lightweight specifications
@cindex access control, in lightweight specifications
@cindex lightweight specifications and access control
@cindex Leavens
@cindex Baker
@cindex Ruby
@cindex M@"ueller
Note that in a lightweight method specification,
the privacy level is assumed to be the same privacy level as the
method itself.  That is, for example, a protected method with a
lightweight method specification is considered to be
a protected annotation context for purposes of checking proper visibility usage
[Leavens-Baker-Ruby06] [Mueller02].
@xref{Lightweight and Heavyweight Specifications}, for more about the
differences between lightweight and heavyweight specification cases.

@cindex ESC/Java2
@cindex ESC/Java
@cindex Leino
@cindex Nelson
@cindex Saxe
The ESC/Java2 system has the same visibility rules as described above.
(However, this was not true of the old version of ESC/Java
[Leino-Nelson-Saxe00].)

@kindex @code{spec_public}
@kindex @code{spec_protected}
The JML keywords @code{spec_public} and @code{spec_protected} provide
a way to make a declaration 
that has different visibilities for Java and JML.  For example, the
following declaration declares an integer field that Java regards as
private but JML regards as public.

@example
    private /*@@ spec_public @@*/ int length;
@end example

@noindent
Thus for example, @code{length} in the above declaration
could be used in a public method specification or invariant.

@cindex @code{spec_public}, as a model field shorthand
@cindex model fields, from @code{spec_public}
However, @code{spec_public} is more than just a way to change the
visibility of a name for specification purposes.  When applied to
fields it can be considered to be shorthand for the declaration of a
model field with the same name.  That is, the declaration of @code{length}
above can be thought of as equivalent to the following
declarations, together with a rewrite of the Java code that uses
@code{length} to use @code{_length} instead
(where we assume @code{_length} is fresh, i.e., not used elsewhere).

@example
  //@@ public model int length;
  private int _length; //@@ in length;
  //@@ private represents length <- _length;
@end example

The above desugaring allows one to change the underlying field without
affecting the readers of the specification.

@cindex @code{spec_protected}, as a model field shorthand
@cindex model fields, from @code{spec_protected}
The desugaring of @code{spec_protected} is the same as for
@code{spec_public}, except that one uses @code{protected}
instead of @code{public} in the desugared form.

@node Instance vs. Static, Locations and Aliasing, Privacy Modifiers and Visibility, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Instance vs. Static

@cindex static features
@kindex @code{static}
In Java, a feature of a class or interface may declared to be
@code{static}.  This means that the feature is not part of instances
of that type, and it means that references to that feature (from
outside the type and its subtypes) must use a qualified name of the
form @i{T.f}, which refers to the static feature @i{f} in type @i{T}.

@cindex instance features
A feature, such as a field or method, of a type that is not static is
an @dfn{instance} feature.  For example, in a Java interface, all the
methods declared are instance methods, although fields are static by
default.  In a Java class the default is that all features are
instance features, unless the modifier @code{static} is used.

@kindex @code{instance}
In JML declarations follow the normal Java rules for determining
whether they are instance or static features of a type.  However,
within annotations it is possible to explicitly label features as
@code{instance} (@pxref{Type Definitions} for the syntax).
The use of the @code{instance} modifier is necessary to declare model
and ghost instance fields in interfaces, since otherwise the Java
default modifier for fields in interfaces (static) would apply.

It is also useful, in JML, to label invariants as either static or
instance invariants. @xref{Static vs. instance invariants}, for more
on this topic.

@node Locations and Aliasing, Expression Evaluation and Undefinedness, Instance vs. Static, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Locations and Aliasing

@cindex location
A @dfn{location} is a field of an object or a local variable.  A
@dfn{local variable} is either a variable declared inside a method or
a formal parameter of a method.

@cindex access path
An @dfn{access path} is an expression either of the form @i{x}, where 
@i{x} is an identifier, or @i{p}@code{.}@i{x}, where @i{p} is an access
path and @i{x} is an identifier.@footnote{
By an identifier, we technically mean an @var{ident} in the Java
grammar. @xref{Tokens}, for details.}
(In forming an access path, we ignore visibility.)

@cindex aliased location
@cindex aliases
In a given program state, @i{s}, a location @i{l} is @dfn{aliased} if there
are two or more access paths that, in @i{s}, both denote @i{l}.
The access paths in question are said to be @dfn{aliases} for @i{l}.
Similarly, we say that an object @i{o} is aliased in a state @i{s}
if there are two access paths that, in @i{s}, both have @i{o} as their value.
In Java, it is impossible to alias local variables, so the only
aliasing possible involves objects and their fields.

@node Expression Evaluation and Undefinedness, Null is Not the Default, Locations and Aliasing, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Expression Evaluation and Undefinedness

@cindex meaning of expressions in JML
@cindex expressions, semantics in JML
@cindex Gosling
@cindex Chalin
@cindex Rioux
Within JML annotations, Java expressions have the values that
are defined in the Java Language Specification [Gosling-etal00].
@c
@cindex validity, of assertions
@cindex assertions, validity of
@cindex exceptions in assertions
@cindex expressions, and exceptions
@cindex predicates, and exceptions
This has consequences on the interpretation of assertion expressions
[Chalin07] [Rioux-Chalin07]:
an assertion is taken to be valid if and only if its interpretation
@itemize @bullet
@item
does not cause an exception to be raised, and
@item
yields the value true.
@end itemize
@c
@cindex undefinedness, in expression evaluation
@cindex assertions, and exceptions
@cindex Leavens
@cindex Baker
@cindex Ruby
@cindex underspecified total functions
@cindex Gries
@cindex Schneider
@cindex Chalin
@cindex Rioux
@cindex logic, two-valued
@cindex logic, three-valued
@cindex two-valued logic
@cindex logical rules, valid in JML
@cindex validity, strong
@cindex strong validity
@c
Note that this interpretation of assertions, said to be based on
``strong validity'' [Chalin07], was made the default assertion
semantics for JML in 2007.  Prior to that, assertions were interpreted
using a classical defintion of validity [Leavens-etal05]
[Leavens-Baker-Ruby06] [Gries-Schneider95] [Jones95e].

The strong validity semantics for assertion evaluation means that
exceptions may arise during evaluation of subexpressions within assertions.
These exceptions should be avoided by the specifier and tools are
encouraged to warn users when they detect that an exception may arise
during assertion evalution.

@cindex protective specifications
@cindex exceptions, avoiding in assertion evaluation
@cindex guidelines, for writing assertions
@kindex @code{&&}
@kindex @code{||}
@kindex @code{==>}
@kindex @code{<==}
@kindex @code{requires}
@cindex precondition, protective
@cindex Leavens
@cindex Wing
To avoid exceptions during assertion evaluation, specifiers should
practice good Java coding habits, and write specifications that
prevent such exceptions. 
To do this, one can use left-to-right ordering of evaluation of
subexpressions and the short-curcuit nature of the Java 
operators @code{&&} and @code{||}.
JML also evaluates the its two implication operators,
@code{==>} and @code{<==} in short-curcuit fashion.
Within a specification case, the precondition can
protect the rest of the specification from exceptions
[Leavens-Wing98].
That is, one can assume that the precondition holds in the remainder
of the clauses in a specification case.
JML also evaluates multiple occurrences of clauses of the same kind
(such as @code{requires} or @code{ensures}) within a spec case in top
to bottom order, so earlier clauses can protect later ones, just as if they
were combined with @code{&&}.

@node Null is Not the Default, Language Levels, Expression Evaluation and Undefinedness, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Null is Not the Default

One common problem that occurs in Java and JML specifications
is the possibility of @code{null} dereferences.  For example,
if @code{x} is @code{null} then @code{x.f} and @code{x.m()} both
result in a @code{NullPointerException}.
Such null pointer exceptions cause undefinedness
in expression evaluation, as described above
(@pxref{Expression Evaluation and Undefinedness}).

@kindex @code{non_null}
@kindex @code{nullable}
To avoid having to constantly specify that declarations (other than
local variables) are non-null, JML makes them implicitly @code{non_null} by default.
That is, unless a 
@itemize @bullet

@item member field (@pxref{Field and Variable Declarations}),
@item formal parameter, (@pxref{Formal Parameters}),
@item method return type (@pxref{Method and Constructor Declarations}), or 
@item bound variable (@pxref{Modifiers for Bound Variables})
@end itemize
@noindent
is explicitly annotated with the
modifier @code{nullable}, that declaration is assumed to be @code{non_null}.

For a field whose type is an array of reference types, such as a field
of type @code{Object[]}, both the field that refers to the array and
the elements of the array are @code{non_null} by default.
If a field whose type is an array of reference types is declared as
@code{nullable}, then both the reference to the array and all of its
elements may potentially be null.  To specify that the field is not
null but the elements may be null, use an invariant to state that the
field cannot contain null, as follows.

@example
private /*@@ spec_public nullable @@*/ Object[] a;
//@@ public invariant a != null;
@end example

While these defaults differ from Java, research has
found that in most cases a declaration is expected to
be non-null [Chalin-Rioux05].
More importantly, since
one of the most common mistakes in JML specifications (and in Java
programs) is forgetting to specify that a declaration
is non-null, making the default be that they cannot hold null
helps eliminate a source of common errors in specifications.

@xref{Nullity Modifiers}, for more details on the nullity modifiers.

@node Language Levels,  , Null is Not the Default, Fundamental Concepts
@c  node-name,  next,  previous,  up
@section Language Levels

@cindex language levels
@cindex levels, of language support
One of JML's goals is to provide a single language that can be used
with a variety of different tools.  However, JML is also
an evolving language that is used as a research vehicle
by many groups.  The evolution of JML means that some features are not
completely documented or implemented.  Use of JML in research means
that some tools will have features that are not supported by other
tools.  All of this has the potential to threaten portability and to
make JML more difficult to learn and use.

The research groups working on JML are committed to making these
problems as invisible to non-researchers as possible, and for this
reason have defined several @dfn{language levels}.  The goal of defining these
language levels is to make it easier to learn and use JML and its
various tools.

We define the following language levels.@footnote{
Thanks to Patrice Chalin for pushing to define these. Patrice,
Joe Kiniry, Peter M@"uller, Adam Darvas, and David Naumann
participated in the initial discussions about what should be in each level.}
@itemize
@item
@cindex level 0, JML features
Level 0 should be supported by all JML tools and constitutes the
heart of JML.  All users should be familiar with these level 0
features.
They are fundamental to all uses of JML, including its use as a design by
contract language, as documentation, and as formal specification for
formal verification efforts.  Thus the level 0 features
should be the ones that tutorial materials concentrate on.  Users
should be able to count on these features
being understood and checked by all tools.

@c [[[I included everything in Patrice's note that was not crossed out
@c in level 0.  I believe the highlighting is for core features that
@c will be used in semantic studies; please correct me if I'm wrong
@c about that.  I added store-refs as well, as they seemed necessary
@c for assignable clauses and functional represents clauses and static
@c data groups, which we agreed were in level 0. -- Gary]]]

@item
@cindex level 1, JML features
Level 1 should be supported by most JML tools and should be a first
priority for developers after implementing the Level 0 features.
There are three categories of features that level 1 adds to level 0.
The first is the redundancy features of JML, which are useful in
documentation, but not absolutely vital.
The second is features that are sugars for features present in level 0.
The third is various features for which modular static verification
is still problematic, although a runtime assertion checking semantics
has been implemented.  This includes the use of methods and constructor
calls in assertions.

@c [[[I included everything in level 1 that was explicitly marked as
@c level 1, and also set comprehensions, which seemed to go here. -- Gary]]]

@item
@cindex level 2, JML features
Level 2 contains features
that are more specialized to particular uses of JML, but are
still useful for several different tools.  It also contains some
features that are mainly needed to explain JML's semantics, and have
not been heavily used (so far).  

@c [[[I included everything in level 2 that was explicitly marked as
@c level 2, and also anything crossed out that is already somewhat
@c implemented and checked in the ISU JML tools release. -- Gary]]]

@item
@cindex level 3, JML features
Level 3 features are even less commonly used and more exotic features.  The
semantics of some of these features are not yet well understood, and
the features are not implemented by many tools.
@c [[[I included here all of the non-concurrent features and new stuff
@c that is not really implemented, but somewhat present already, and
@c not marked as experimental. -- Gary]]]

@item
@cindex level C, JML features
Level C contains features related to specification and verification of
concurrent Java programs.  Some of these are from ESC/Java
[Leino-Nelson-Saxe00], and others are from [Rodriguez-etal05].

@item
@cindex level X, JML features
Level X contains experimental features, which may eventually be moved
to other levels.  Many tools will have other experimental features not
documented here.

@c [[[I included here only experimental features that we believe are
@c currently experimental. -- Gary]]]
@c [[[I think this is a good idea.  Too bad we cannot have a level XX
@c and level XXX.  That might get us some new users. <g> -- Joe]]]
@c [[[(Yes, I suppose it might... ;-) -- Gary]]]

@end itemize

@cindex learning JML, and language levels
@cindex language levels, and learning JML
When learning JML, one should focus on
levels 0 features first, as these form the heart of the language
which should be understood by all JML tools.
Features at level 1 are next in importance and should be supported by
most tools that are interested in having a large user base.  Features
at higher levels are less important and may not be present in all
tools.  Users should feel free to ignore them unless they meet some
specific need.

@cindex language levels, and tools
@cindex tools, advice for builders of
@cindex portability, and language levels
@cindex experimental, features of JML
The language levels also provide guidance for tool designers.  JML
tools should parse all of the syntax in this reference manual that is
not marked as experimental.  This is the most important way to
guarantee portability for users, and the easiest way for tools to get
feedback.   In addition, tools should check at least level 0, and
preferably level 1 features.  Features at levels 2 and 3 are
candidates for the tool to just parse and ignore, if they are not
features of interest for that tool.  Experimental features may ignored
(or added) by any tool.

Many tool developers may want to start off supporting only a subset of
JML defined by level 0 and then move on to higher levels.

It is also suggested that tools give users optional feedback, perhaps
in a verbose mode, as to which features are fully and partially 
supported.  Clearly stating which JML levels are supported in a 
tool release is also very important.

More details are provided in the subsections below.

@menu
* Level 0 Features::            
* Level 1 Features::            
* Level 2 Features::            
* Level 3 Features::            
* Level C Features::            
* Level X Features::            
@end menu

@node Level 0 Features, Level 1 Features, Language Levels, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level 0 Features

@cindex level 0, JML features
@cindex features, level 0
@cindex language level 0 features
The features in this level form the core of JML and should be
understood and checked by all JML tools.  Beginning users should pay
the most attention to these features.  These features include all of Java and
the syntax described in the rest of this section. 

Many, but not all, of the JML additions to Java's @var{modifier}s
(@pxref{Modifiers}) are level 0 features. The following modifiers are
included in level 0.

@itemize @bullet
@item
The @var{modifier} @code{spec_public} (@pxref{Spec Public}).

@item
The @var{modifier} @code{spec_protected} (@pxref{Spec Protected}).

@item
The @var{modifier} @code{instance} (@pxref{Instance}).

@item
The @var{modifier} @code{model} (@pxref{Model}), as applied to field
declarations (@pxref{JML Modifiers for Fields}).
Note that this modifier as applied to other
declarations is not a level 0 feature.

@item
The @var{modifier} @code{ghost} (@pxref{Ghost}), as applied to both
field and variable declarations (@pxref{Field and Variable Declarations}).

@item
The @var{modifier} @code{helper} (@pxref{Helper}).
@end itemize

Type specifications (@pxref{Type Specifications}) are a level 0
feature, although not all clauses and features of type
specifications are level 0.  The following type-level clauses are
included in level 0.

@itemize @bullet
@item
Object invariants, that is an @var{invariant} (@pxref{Invariants})
that is either written in an interface using the
@var{modifier} @code{instance} (@pxref{Instance}) or one that is
written in a class and that does not use the @var{modifier} @code{static}
(@pxref{Static vs. instance invariants}).

@item
The functional form of a @var{represents-clause} (@pxref{Represents Clauses}).
That is, a represents
clause that uses @var{l-arrow-or-eq} and (not @code{\such_that}).

@item
The @var{initially-clause} (@pxref{Initially Clauses}).

@item
The @var{type-spec} @code{\TYPE} (optionally, as a type of array
element).
@xref{Type-Specs}, for more details.
@end itemize

Method specifications (@pxref{Method Specifications}) are a level 0
feature.
This includes the ability to combine specification cases using
@code{also}
(@pxref{Semantics of nested behavior specification cases})
and specification inheritance [Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b].
It also includes the use of @code{\not_specified} for all
specification clauses that are at level 0.
However, not all clauses and features of method
specifications are level 0. The following parts of method
specifications are included in level 0.
Redundancy features of method specifications are only present at
level 1, not at level 0.  The details are described below.

@itemize @bullet
@item
Lightweight specification cases (@pxref{Lightweight Specification Cases}),
although not all clauses that are allowed in the syntax are
in level 0.

@item
Heavyweight specification cases (@pxref{Heavyweight Specification Cases}) 
that do not use the keyword @code{code}.
This includes 
@var{behavior-spec-case} (@pxref{Behavior Specification Cases}),
@var{normal-behavior-spec-case}
(@pxref{Normal Behavior Specification Cases}),
and 
@var{exceptional-behavior-spec-case}
(@pxref{Exceptional Behavior Specification Cases}).
However, note that not all clauses that are allowed in the syntax are
in level 0.

@item
The @var{requires-clause} (@pxref{Requires Clauses}).
The redundant form of this clause
(@code{requires_redundantly}, @code{pre_redundantly}) is a level 1 feature.

@item
The @var{ensures-clause} (@pxref{Ensures Clauses}).
The redundant form of this clause
(@code{ensures_redundantly}, @code{post_redundantly}) is a level 1 feature.

@item
The @var{signals-clause} (@pxref{Signals Clauses}).
The redundant form of this clause
(@code{signals_redundantly}, @code{exsures_redundantly}) is a level 1 feature.

@item
The @var{signals_only-clause} (@pxref{Signals-Only Clauses}).
The redundant form of this clause
(@code{signals_only_redundantly}) is a level 1 feature.

@item
The @var{assignable-clause} (@pxref{Assignable Clauses}).
The redundant form of this clause
(@code{assignable_redundantly}, @code{modifiable_redundantly},
@code{modifies_redundantly}) is a level 1 feature. 
@end itemize

Only static data groups (@pxref{Data Groups}) are part of level 0.

@itemize @bullet
@item
The @var{in-group-clause} (@pxref{Static Data Group Inclusions})
kind of @var{jml-data-group-clause}
that attaches to field declarations 
(@pxref{Field and Variable Declarations}).
@end itemize

Some of JML's extensions to Java's @var{expression} syntax
(@pxref{Predicates and Specification Expressions}), but not all of them,
can be used at level 0.  Note that
calls to pure methods and constructors in @var{spec-expression}s are
@emph{not} part of level 0, but are only found at level 1.
We describe the level 0 specification
expressions below. 

@itemize @bullet
@item
The @var{result-expression} (@pxref{Backslash result}).

@item
The @var{old-expression} (@pxref{Backslash old and Backslash pre}).

@item
The @var{fresh-expression} (@pxref{Backslash fresh}).

@item
The @var{nonnullelements-expression} (@pxref{Backslash nonnullelements}).
@c [[[Not sure about this one, but we marked it as level 0.]]]

@item
The @var{informal-description} (@pxref{Informal Predicates}).

@item
The @var{typeof-expression} (@pxref{Backslash typeof}).

@item
The @var{elemtype-expression} (@pxref{Backslash elemtype}).

@item
The @var{type-expression} (@pxref{Backslash type}).

@item
The @var{spec-quantified-expr} (@pxref{Quantified Expressions}) forms
that use the @var{quantifier} keywords
@code{\forall} and @code{\exists}
(@pxref{Universal and Existential Quantifiers}). 

(The @var{quantifier} keywords
@code{\max}, @code{\min}, @code{\product}, and @code{\sum}
(@pxref{Generalized Quantifiers}), as well as @code{\num_of}
(@pxref{Numerical Quantifier}, are all level 1 features.)

@item
The @code{<:} operator (@pxref{Subtype operator}).

@item
The @code{<==>} and @code{<=!=>} operators
(@pxref{Equivalence and Inequivalence Operators}).

@item
The @code{==>} and @code{<==} operators
(@pxref{Forward and Reverse Implication Operators}).

@item
The syntax for @var{store-ref}s (@pxref{Store Refs}).
@end itemize

All of the Java statements and most of the JML extensions
for adding assertions to statements and annotation statements
(@pxref{Statements and Annotation Statements}) are at level 0.  But redundancy
features of the JML extensions are only present at 
level 1, not at level 0. 
We describe the level 0 extension to statements below.

@itemize @bullet
@item
Using the @var{modifier} @code{ghost} in @var{local-declaration}s
(@pxref{Modifiers for Local Declarations}).

@item
The @var{possibly-annotated-loop} statement (@pxref{Loop Statements}),
with a @var{loop-invariant} (@pxref{Loop Invariants}).
The redundant forms of @var{loop-invariant}s, namely those
that use the keywords @code{maintaining_redundantly} and
@code{loop_invariant_redundantly} are level 1 features.
Furthermore, the @var{variant-function} is a level 1 feature.

@item
The @var{assert-statement} (@pxref{Assert Statements}).
Note that the @var{assert-redundantly-statement},
which uses the keyword @code{assert_redundantly}, is in level 1.

@item
The non-redundant form of the @var{assume-statement}
(@pxref{Assume Statements}).
Use of the keyword @code{assume_redundantly} is a level 1 feature.

@item
The @var{set-statement} (@pxref{Set Statements}).
@end itemize

The ability to
use a @code{.spec} file (@pxref{File Name Suffixes})
to give a separate specification for a
compilation unit that only appears in binary form (e.g., in a
@code{.class} file) is a level 0 feature.
Use of the @var{refine-prefix} (@pxref{Refinement}) is a
level 1 feature.

Some syntax from the Universe type system
(@pxref{Universe Type System}) is included in level 0.
However, @code{readonly} is considered to be in level X, as is the semantics
of the Universe type system.  The @code{rep} and @code{peer} modifiers
are included in level 0 because, in some form, they are important to
the semantics of several level 0 features
[Mueller-Poetzsch-Heffter-Leavens03] [Mueller-Poetzsch-Heffter-Leavens06].

@itemize @bullet
@item
The @code{\rep} and @code{rep} @var{ownership-modifier}s
(@pxref{Rep and Peer}).

@item
The @code{\peer} and @code{peer} @var{ownership-modifier}s
(@pxref{Rep and Peer}).
@end itemize

@c [[[How can we ensure that we have/maintain full language coverage in 
@c this discussion going forward?  Any bright ideas?  Perhaps make sure
@c to index all expressions per level and then do some kind of sorted 
@c grep with a diff?  How about annotating the tools with the levels as
@c well, to guarantee consistency.  I am sure we'll do something like
@c that in ESC/Java2 or ESC/Java3 and/or the MOBIUS tool. -- Joe]]]
@c [[[I was planning to cross reference this so that each feature's
@c description would include the level, once we make the decisions
@c more final. -- Gary]]]

@node Level 1 Features, Level 2 Features, Level 0 Features, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level 1 Features

@cindex level 1, JML features
@cindex features, level 1
@cindex language level 1 features
The features in this level will be 
understood and checked by many JML tools.  They are quite important in
practice, especially the use of methods and constructors in writing
the specifications of other methods and constructors. 
Also useful are all of JML's redundancy features
(@pxref{Redundancy}), which are included here for level 0 features and
for other features at level 1.

@c [[[It is not clear to me that permitting constructors in
@c specifications should be at level 1. -- Joe]]]
@c [[[Why should that be different than using methods in
@c specifications? Using methods without constructors doesn't prevent
@c storage allocation. -- Gary]]]

The following additions to Java's @var{modifier}s
(@pxref{Modifiers}) are level 1 features.

@itemize @bullet
@item
Method or constructor declarations that use the
@var{modifier} @code{model} (@pxref{Model Methods and Constructors}).
However, note that using @code{model} on a field
declarations is a level 0 feature and that using @code{model} on a
type declaration is a level 2 feature.

@item
@var{import-definition}s that use the modifier @code{model}
(@pxref{Import Definitions}).

@item
The @var{modifier} @code{pure} (@pxref{Pure}).

@c [[[But which "pure"? <grin> -- Joe]]]
@c [[[I would like to add ``query'' as a keyword, and David Cok and I
@c are working on a proposal for that, to address this issue. -- Gary]]]

@item
The @var{modifier} @code{uninitialized} (@pxref{Uninitialized}).
@end itemize

The following type-level clauses
(@pxref{Type Specifications}) are included in level 1.

@itemize @bullet
@item
Attaching a @var{method-specification} to a
@var{class-initializer-decl} (@pxref{Class Initializer Declarations}).

@item
Static invariants, that is an @var{invariant} (@pxref{Invariants})
that is either written in an interface without using the
@var{modifier} @code{instance} (@pxref{Instance}), or one that is
written in a class and that uses the @var{modifier} @code{static}
(@pxref{Static vs. instance invariants}).

@item
Both object and static @var{history-constraint}s (@pxref{Constraints}).

@item
The @var{axiom-clause} (@pxref{Axioms}).

@item
The @var{maps-into-clause} (@pxref{Dynamic Data Group Mappings})
kind of @var{jml-data-group-clause}
that attaches to field declarations (@pxref{Field and Variable Declarations}).
@end itemize

The following features of method specifications
(@pxref{Method Specifications}) are included in level 1.

@itemize @bullet
@item
The @var{spec-var-decls} that may occur in a specification case
(@pxref{Specification Variable Declarations}).

@item
The @var{redundant-spec} parts of a method specification
(@pxref{Redundancy}) are also included in level 1.
The following describes these parts.

@itemize @bullet
@item
The @var{implications} (@code{implies_that}) part of a @var{redundant-spec}
(@pxref{Redundant Implications and Redundantly Clauses}).

@item
The @var{examples} (@code{for_example}) part of a @var{redundant-spec}.
@end itemize
@end itemize

The following extensions to Java's @var{expression} syntax
(@pxref{Predicates and Specification Expressions})
are included in level 1.

@itemize @bullet
@item
The @var{spec-quantified-expr} (@pxref{Quantified Expressions}) forms
that use the @var{quantifier} keywords
@code{\max}, @code{\min}, @code{\product}, and @code{\sum}
(@pxref{Generalized Quantifiers}), as well as @code{\num_of}
(@pxref{Numerical Quantifier}).

(Note that the @code{\max} quantifier is distinct from the
@var{max-expression} (@pxref{Backslash max}), which is a level C
feature.
Also, note that the @var{quantifier} keywords @code{\forall} and
@code{\exists} are level 0 features.)

@item
Calls to pure methods and constructors 
(@pxref{Pure Methods and Constructors})
in @var{spec-expression}s (@pxref{Predicates and Specification Expressions}).

@item
The @var{set-comprehension} expression (@pxref{Set Comprehensions}).
@end itemize

The following additions to Java's statement syntax 
(@pxref{Statements and Annotation Statements})
are included in level 1.

@itemize @bullet
@item
The use of redundant forms of @var{loop-invariant}s (@pxref{Loop Invariants})
namely those that use the keywords @code{maintaining_redundantly} and
@code{loop_invariant_redundantly}.
Non-redundant @var{loop-invariant}s are in level 0.

@item
The @var{possibly-annotated-loop} statement (@pxref{Loop Statements}),
with a @var{variant-function} (@pxref{Loop Variant Functions}).

@item
The @var{assert-redundantly-statement} (@pxref{Assert Statements});
that is, assert statements that use the keyword @code{assert_redundantly}.
The non-redundant @var{assert-statement}s are a level 0 feature.

@item
The redundant form of the @var{assume-statement}
(@pxref{Assume Statements}); that is, assume statements that use
the keyword @code{assume_redundantly}.
The non-redundant @var{assume-statement}s are a level 0 feature.
@end itemize

The @var{refine-prefix} (@pxref{Refinement}).  However, the ability to
use a @code{.spec} file to give a separate specification for a
compilation unit that only appears in binary form (e.g., in a
@code{.class} file) is a level 0 feature.

The @code{\bigint} type (@pxref{Backslash bigint})
from the safe math extensions (@pxref{Safe Math Extensions}) is a level 1
feature.

@c [[[Does this mean Patrice didn't win his argument with Peter? -- Joe]]]

@node Level 2 Features, Level 3 Features, Level 1 Features, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level 2 Features

@cindex level 2, JML features
@cindex features, level 2
@cindex language level 2 features
Level 2 contains features that are more specialized to particular uses
of JML, but are still useful for several different tools.  It also
contains some features that are mainly needed to explain JML's
semantics, and have not been heavily used (so far).

The @var{nowarn-pragma} (@pxref{Lexical Pragmas}).

The following type-level clauses
(@pxref{Type Specifications}) are included in level 2.

@itemize @bullet
@item
The relational form of a @var{represents-clause} (@pxref{Represents Clauses}).
That is, a represents
clause that uses @code{\such_that}.
Note that the functional form of such represents clauses is a level 0
feature.

@item
The @var{readable-if-clause} clause (@pxref{Readable If Clauses}).

@item
The @var{writable-if-clause} clause (@pxref{Writable If Clauses}).
@end itemize

The following features of method specifications
(@pxref{Method Specifications}) are included in level 2.

@itemize @bullet
@item
The @var{diverges-clause} (@pxref{Diverges Clauses}).

@item
The @var{accessible-clause} (@pxref{Accessible Clauses}).

@item
The @var{callable-clause} (@pxref{Callable Clauses}).

@item
The @var{measured-by-clause} (@pxref{Measured By Clauses}).

@item
The @var{captures-clause} (@pxref{Captures Clauses}).

@item
The @var{working-space-clause} (@pxref{Working Space Clauses}).

@item
The @var{duration-clause} (@pxref{Duration Clauses}).

@item
The @var{model-program} style of method specification
(@pxref{Model Programs}).

@item
The @var{refining-statement} (@pxref{Refining Statements}).

@item
The @code{extract} modifier (@pxref{Extracting Model Program Specifications}).
@end itemize

The following extensions to Java's @var{expression} syntax
(@pxref{Predicates and Specification Expressions})
are included in level 2.

@itemize @bullet
@item
The @var{not-assigned-expression} (@pxref{Backslash not_assigned}).

@item
The @var{not-modified-expression} (@pxref{Backslash not_modified}).

@item
The @var{only-accessed-expression} (@pxref{Backslash only_accessed}).

@item
The @var{only-assigned-expression} (@pxref{Backslash only_assigned}).

@item
The @var{only-called-expression} (@pxref{Backslash only_called}).

@item
The @var{only-captured-expression} (@pxref{Backslash only_captured}).

@item
The @var{reach-expression} (@pxref{Backslash reach}).

@item
The @var{is-initialized-expression} (@pxref{Backslash is_initialized}).

@item
The @var{invariant-for-expression} (@pxref{Backslash invariant_for}).

@item
The @var{lblneg-expression} and the @var{lblpos-expression}
(@pxref{Backslash lblneg and lblpos}).
@end itemize

The following additions to Java's statement syntax 
(@pxref{Statements and Annotation Statements})
are included in level 2.

@itemize @bullet
@item
The @var{unreachable-statement} (@pxref{Unreachable Statements}).

@item
The @var{debug-statement} (@pxref{Debug Statements})

@item
The @var{hence-by-statement} (@pxref{Hence By Statements}).
@end itemize

Note that all the @var{model-prog-statement}s (@pxref{Model Programs})
are at level 2, because the model program style of method specification
is at this level.

Aside from the @code{\bigint} type (@pxref{Backslash bigint}),
which is a level 1 feature, the rest of the safe math extensions
(@pxref{Safe Math Extensions}) are level 2
features.  This includes the following particulars.

@itemize @bullet
@item
The @code{\real} type (@pxref{Backslash real}).

@item
The @var{modifier}s  @code{code_bigint_math}, @code{code_java_math}, 
@code{code_safe_math}, @code{spec_bigint_math},
@code{spec_java_math}, and @code{spec_safe_math} (@pxref{Math Modifiers}).
@end itemize

@node Level 3 Features, Level C Features, Level 2 Features, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level 3 Features

@cindex level 3, JML features
@cindex features, level 3
@cindex language level 3 features
Level 3 features are more exotic and even less commonly used.  The
semantics of some of these features are not yet well understood, and
the features are not implemented by many tools.

@itemize @bullet
@item
@var{type-definition}s that use the modifier @code{model}
(@pxref{Modifiers for Type Definitions}).

@item
The @var{duration-expression} (@pxref{Backslash duration}).

@item
The @var{space-expression} (@pxref{Backslash space}).

@item
The @var{working-space-expression} (@pxref{Backslash working space}).
@end itemize

@node Level C Features, Level X Features, Level 3 Features, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level C Features

@cindex level C, JML features
@cindex features, level C
@cindex language level C features
The features in this level are related to the specification of concurrency.
This includes features inherited from ESC/Java having to do with
concurrency.  The features of this level are as follows.

@itemize @bullet
@item
The @var{monitors-for-clause} clause (@pxref{Monitors For Clause}).

@item
The @var{when-clause} (@pxref{When Clauses}).

@item
The @var{lockset-expression} (@pxref{Backslash lockset}).

@item
The @var{max-expression} (@pxref{Backslash max}).  Note that this is
@emph{not} the quantifier @code{\max}
(@pxref{Generalized Quantifiers}), which is a level 1 feature. 

@item
The @code{<} and @code{<=} operators applied to test ordering of locks
(@pxref{Lockset Ordering}).
@end itemize

@node Level X Features,  , Level C Features, Language Levels
@c  node-name,  next,  previous,  up
@subsection Level X Features

@cindex level X, JML features
@cindex features, level X
@cindex language level X features
The features in this level are experimental.
They are as follows.

@itemize @bullet
@item
The MultiJava extensions to JML (@pxref{MultiJava Extensions to JML}),
including the syntax for @var{multijava-top-level-declaration}
(@pxref{Augmenting Method Declarations})
and @var{multijava-param-declaration} (@pxref{MultiMethods}).

@item
The @code{\readonly} and @code{readonly} @var{ownership-modifier}s
from the Universe type system (@pxref{Universe Type System}).
Note that the @code{\peer} and @code{\rep} modifiers are level 0 features.
@end itemize

@c ------ chapter Syntax Notation
@node Syntax Notation, Lexical Conventions, Fundamental Concepts, Top
@c  node-name,  next,  previous,  up
@chapter Syntax Notation

@cindex syntax notations
@cindex grammar notations
@cindex notations, syntax
@cindex notations, grammar
@cindex @dots{}
@cindex []
@iftex
@cindex `'
@end iftex
@cindex BNF notation
@cindex Ledgard
@cindex Backus
@cindex Naur
We use an extended Backus-Naur Form (BNF) grammar
to describe the syntax of JML.
The extensions are as follows [Ledgard80].

@cindex nonterminal symbols, notation
@cindex terminal symbols, notation
@cindex optional elements in syntax
@cindex repeated elements in syntax
@itemize @bullet
@item
Nonterminal symbols are written as follows: @var{nonterminal}.
@iftex
That is, nonterminal symbols appear in an @var{italic} font
(in the printed manual).
@end iftex
@ifinfo
That is, nonterminal symbols appear in @var{UPPER-CASE}.
@end ifinfo

@item
Terminal symbols are written as follows: @code{terminal}.
@iftex
In a few cases it is also necessary to quote terminal symbols,
such as when using `@code{|}' as a terminal symbol instead of a
meta-symbol.
@end iftex

@item
Square brackets ([ and ]) surround optional text. Note that @code{[}
and @code{]} are terminals.

@item
The notation @dots{} means that the preceding nonterminal
or group of optional text can be repeated zero (0) or more times.
@end itemize

For example, the following gives a production for a non-empty list of
@var{init-declarator}s, separated by commas.

@display
@var{init-declarator-list} ::= @var{init-declarator} [ @code{,} @var{init-declarator} ] @dots{}
@end display

@c [[[Authors, note the following convention, please]]]
To remind the reader that the notation `@dots{}' means zero or more
repetitions, we try to use `@dots{}' only following optional text,
although, in cases such as the following, the brackets could have been omitted.

@display
@var{modifiers} ::= [ @var{modifier} ] @dots{}
@end display

@kindex @code{,}
@cindex @var{-seq} suffix
@cindex @var{-list} suffix
@cindex grammar, conventions for lists
@cindex list vs. sequence, in grammar
@cindex sequence vs. list, in grammar
As in the above examples, we follow the C++ standard's conventions
[ANSI95] in using nonterminal names of the form @var{X-list} to mean a
comma-separated list, and nonterminal names of the form @var{X-seq} to
mean a sequence not separated by commas.  An example of a sequence is
the following

@display
@var{spec-case-seq} ::= @var{spec-case} [ @code{also} @var{spec-case} ] @dots{}
@end display

@cindex @i{//}
We use ``@i{//}'' to start a comment (to you, the reader) in the grammar.

A complete summary of the JML grammar appears in 
an appendix (@pxref{Grammar Summary}).  When reading the
HTML version of this appendix, one can click on the names
of nonterminals to bring that nonterminal's definition to the top of
the browser's window.  This is helpful when dealing with such a large
grammar.

Another help in dealing with the grammar is to use the index
(@pxref{Concept Index}).  Every
nonterminal and terminal symbol in the grammar is found in the
index, and each definition and use is noted.
[[[Or rather, it will be...]]]

@c ------ chapter Lexical Conventions
@node Lexical Conventions, Compilation Units, Syntax Notation, Top
@c  node-name,  next,  previous,  up
@chapter Lexical Conventions

@cindex lexical conventions
This chapter presents the lexical conventions of JML,
that is, the microsyntax of JML.

@cindex microsyntax
@cindex white space
@cindex space
Throughout this chapter,
grammatical productions are to be understood lexically.
That is, no @var{white-space} (@pxref{White Space}) may intervene between the
characters of a token.  (However, outside this chapter, the opposite
of this convention is in force.)

@cindex Watt
The microsyntax of JML
is described by the production @var{microsyntax} below;
it describes what a program looks like from the point of view of
a lexical analyzer [Watt91].

@cindex @var{microsyntax}, defined
@cindex @var{lexeme}, defined
@cindex @var{token}, defined
@cindex @var{lexeme}, used
@cindex @var{white-space}, used
@cindex @var{newline}, used
@cindex @var{comment}, used
@cindex @var{annotation-marker}, used
@cindex @var{lexical-pragma}, used
@cindex @var{doc-comment}, used
@cindex @var{token}, used
@cindex @var{ident}, used
@cindex @var{keyword}, used
@cindex @var{special-symbol}, used
@cindex @var{java-literal}, used
@cindex @var{informal-description}, used
@display
@var{microsyntax} ::= @var{lexeme} [ @var{lexeme} ] @dots{}
@var{lexeme} ::= @var{white-space} | @var{lexical-pragma} | @var{comment}
        | @var{annotation-marker} | @var{doc-comment} | @var{token} 
@var{token} ::= @var{ident} | @var{keyword} | @var{special-symbol}
        | @var{java-literal} | @var{informal-description}
@end display

In the rest of this section we provide more details on each of the major
nonterminals used in the above grammar.

@c The nonterminals all correspond to things in the files
@c org/jmlspecs/checker/Jml.g (see the
@c JmlLexer class specification at the end of the file), JmlML.g,
@c JMLSL.g, and JavadocJml.g, and JMLJD.g.
@c These specifications can be consulted to verify the lexical grammar.

@menu
* White Space::                 
* Lexical Pragmas::             
* Comments::                    
* Annotation Markers::          
* Documentation Comments::      
* Tokens::                      
@end menu

@node White Space, Lexical Pragmas, Lexical Conventions, Lexical Conventions
@c  node-name,  next,  previous,  up
@section White Space

@cindex blank
@cindex tab
@cindex vertical tab
@cindex carriage return
@cindex formfeed
@cindex newline
Blanks, horizontal and vertical tabs, carriage returns, formfeeds,
and newlines, collectively called @dfn{white space},
are ignored except as they serve to separate tokens.
Newlines and carriage returns
are special in that they cannot appear in some contexts where
other whitespace can appear, and are also used to end Java-style comments
(@pxref{Comments}).

@cindex white space
@cindex @var{white-space}, defined
@cindex @var{non-nl-white-space}, defined
@cindex @var{end-of-line}, defined
@cindex @var{newline}, defined
@cindex @var{carriage-return}, defined
@cindex @var{non-nl-white-space}, used
@cindex @var{end-of-line}, used
@cindex @var{newline}, used
@cindex @var{carriage-return}, used
@display
@var{white-space} ::= @var{non-nl-white-space} | @var{end-of-line}
@var{non-nl-white-space} ::= a blank, tab, or formfeed character
@var{end-of-line} ::= @var{newline} | @var{carriage-return}
        | @var{carriage-return} @var{newline}
@var{newline} ::= a newline character
@var{carriage-return} ::= a carriage return character
@end display

@node Lexical Pragmas, Comments, White Space, Lexical Conventions
@comment  node-name,  next,  previous,  up
@section Lexical Pragmas

ESC/Java [Leino-etal00] has a single kind of ``lexical pragma'', @code{nowarn},
whose syntax is described below in general terms.
The JML checker currently ignores these lexical pragmas,
but @code{nowarn} is only recognized within an annotation.
Note that, unlike ESC/Java, the semicolon is mandatory.
This restriction seems to be necessary to prevent lexical ambiguity.

@cindex @var{lexical-pragma}, defined
@cindex @var{nowarn-pragma}, defined
@cindex @var{spaces}, defined
@cindex @var{nowarn-label-list}, defined
@cindex @var{nowarn-label}, defined
@cindex @var{nowarn-pragma}, used
@cindex @var{spaces}, used
@cindex @var{nowarn-label-list}, used
@cindex @var{non-nl-white-space}, used
@cindex @var{nowarn-label}, used
@cindex @var{letter}, used
@kindex @code{nowarn}
@kindex @code{;}
@display
@var{lexical-pragma} ::= @var{nowarn-pragma}
@var{nowarn-pragma} ::= @code{nowarn} [ @var{spaces} ] [ @var{nowarn-label-list} ] @code{;}
@var{spaces} ::= @var{non-nl-white-space} [ @var{non-nl-white-space} ] @dots{}
@var{nowarn-label-list} ::= @var{nowarn-label} [ @var{spaces} ]
             [ @code{,} [ @var{spaces} ] @var{nowarn-label} [ @var{spaces} ] ] @dots{}
@var{nowarn-label} ::= @var{letter} [ @var{letter} ] @dots{}
@end display

@xref{Tokens}, for the syntax of @var{letter}.

@node Comments, Annotation Markers, Lexical Pragmas, Lexical Conventions
@comment  node-name,  next,  previous,  up
@section Comments

@cindex comment, syntax of
@cindex C-Style comment
@cindex multiline comment, see C-Style comment
@cindex single line comment, see C++-Style comment
Both kinds of Java comments are allowed in JML: multiline C-style
comments and single line C++-style comments.
However, if what looks like a comment starts with the at-sign (@code{@@})
character, or with a plus sign and an at-sign (@code{+@@}),
then it is considered to be the start of an annotation by JML,
and not a comment.
Furthermore, if what looks like a comment starts with an asterisk (@code{*}),
then it is a documentation comment, which is parsed by JML.

@cindex @var{comment}, defined
@cindex @var{C-style-comment}, defined
@cindex @var{C-style-body}, defined
@cindex @var{non-stars-slash}, defined
@cindex @var{non-star-slash}, defined
@cindex @var{stars-non-slash}, defined
@cindex @var{non-at-plus-star}, defined
@cindex @var{non-at}, defined
@cindex @var{non-star}, defined
@cindex @var{non-slash}, defined
@cindex @var{C-style-end}, defined
@cindex @var{C++-style-comment}, defined
@cindex @var{non-end-of-line}, defined
@cindex @var{non-at-plus-end-of-line}, defined
@cindex @var{non-at-end-of-line}, defined
@cindex @var{C-style-comment}, used
@cindex @var{C++-style-comment}, used
@cindex @var{C-style-body}, used
@cindex @var{C-style-end}, used
@cindex @var{non-at-plus-star}, used
@cindex @var{non-star-slash}, used
@cindex @var{non-stars-slash}, used
@cindex @var{non-at}, used
@cindex @var{stars-non-slash}, used
@cindex @var{non-star}, used
@cindex @var{non-slash}, used
@cindex @var{end-of-line}, used
@cindex @var{non-at-plus-end-of-line}, used
@cindex @var{non-end-of-line}, used
@kindex @code{/*}
@kindex @code{+}
@kindex @code{*}
@kindex @code{@@}
@kindex @code{/}
@kindex @code{*/}
@kindex @code{//}
@cindex newline
@cindex carriage return
@cindex return, carriage
@display
@var{comment} ::= @var{C-style-comment} | @var{C++-style-comment}
@var{C-style-comment} ::= @code{/*} [ @var{C-style-body} ] @var{C-style-end}
@var{C-style-body} ::= @var{non-at-plus-star} [ @var{non-stars-slash} ] @dots{}
        | @code{+} @var{non-at} [ @var{non-stars-slash} ] @dots{}
        | @var{stars-non-slash} [ @var{non-stars-slash} ] @dots{}
@var{non-stars-slash} ::= @var{non-star}
        | @var{stars-non-slash}
@var{stars-non-slash} ::= @code{*} [ @code{*} ] @dots{} @var{non-star-slash}
@var{non-at-plus-star} ::= any character except @code{@@}, @code{+}, or @code{*}
@var{non-at} ::= any character except @code{@@}
@var{non-star} ::= any character except @code{*}
@var{non-slash} ::= any character except @code{/}
@var{non-star-slash} ::= any character except @code{*} or @code{/}
@var{C-style-end} ::= [ @code{*} ] @dots{} @code{*/}
@var{C++-style-comment} ::= @code{//} [ @code{+} ] @var{end-of-line}
        | @code{//} @var{non-at-plus-end-of-line} [ @var{non-end-of-line} ] @dots{} @var{end-of-line}
        | @code{//+} @var{non-at-end-of-line} [ @var{non-end-of-line} ] @dots{} @var{end-of-line}
@var{non-end-of-line} ::= any character except a newline or carriage return
@var{non-at-plus-end-of-line} ::= any character except @code{@@}, @code{+}, newline, or carriage return
@var{non-at-end-of-line} ::= any character except @code{@@}, newline, or carriage return
@end display

@node Annotation Markers, Documentation Comments, Comments, Lexical Conventions
@comment  node-name,  next,  previous,  up
@section Annotation Markers

@cindex annotation markers, syntax
@kindex @code{@@}
@cindex annotation
@kindex @code{/*@@}
@kindex @code{/*+@@}
@kindex @code{*/}
@kindex @code{@@*/}
@kindex @code{@@+*/}
If what looks to Java like a comment starts with an at-sign (@code{@@})
as its first character, then it is not considered a comment by JML.
We refer to the tokens between @code{//@@} and the following
@var{end-of-line}, and between pairs of 
annotation start ( @code{/*@@} or @code{/*+@@} ) and 
end ( @code{*/} or @code{@@*/} or @code{@@+*/} ) markers
as @dfn{annotations}.

@cindex annotations, splitting across lines
@cindex ESC/Java
@cindex ESC/Java2
@cindex Leino
@cindex Nelson
@cindex Saxe
Annotations must hold entire grammatical units of JML specifications,
in the sense that the text of some nonterminals may not be split across
two separate annotations.
For example the following is illegal, because the 
@var{postcondition} of the ensures clause is split over two annotations,
and thus each contains a fragment instead of a complete grammatical unit.
@example
  //@@ ensures 0 <= x             // illegal!
  //@@      && x < a.length;
@end example
Implementations are not required to check for such errors.
However, note that ESC/Java [Leino-Nelson-Saxe00] and ESC/Java2
assume that nonterminals that define clauses are not split into
separate annotations, and so effectively do check for them.

@cindex annotations vs. comments
@cindex comments vs. annotations
@cindex annotations and tools
@cindex tools and annotations 
@kindex @code{/*@@}
@kindex @code{/*+@@}
@kindex @code{//@@}
@kindex @code{//+@@}
@kindex @code{@@+*/}
@kindex @code{@@*/}
@kindex @code{*/}
Annotations look like comments to Java, and are thus ignored by it,
but they are significant to JML.
One way that this can be achieved is by having JML drop (ie., ignore)
the character sequences that are @var{annotation-marker}s:
@code{//@@}, @code{//+@@}, @code{/*@@}, @code{/*+@@}, and @code{@@+*/},
@code{@@*/}. 
The at-sign (@code{@@}) in @code{@@*/} is optional, and more than one
at-sign may appear in it and the other annotation markers.
However, JML will recognize @var{jml-keywords} only within annotations.

@cindex @code{@@}, ignored at beginning of annotation line
Within annotations, on each line,
initial white-space and any immediately following at-signs (@code{@@})
are ignored. 
The definition of an annotation marker is given below.

@cindex @var{annotation-marker}, defined
@cindex @var{ignored-at-in-annotation}, defined
@kindex @code{//@@}
@kindex @code{//+@@}
@kindex @code{/*@@}
@kindex @code{/*+@@}
@kindex @code{@@+*/}
@kindex @code{@@*/}
@kindex @code{*/}
@kindex @code{@@}
@display
@var{annotation-marker} ::= @code{//@@} [ @code{@@} ] @dots{} | @code{//+@@} [ @code{@@} ] @dots{}
        | @code{/*@@} [ @code{@@} ] @dots{} | @code{/*+@@} [ @code{@@} ] @dots{} | [ @code{@@} ] @dots{} @code{@@+*/} | [ @code{@@} ] @dots{} @code{*/}
@var{ignored-at-in-annotation} ::= @code{@@}
@end display

@node Documentation Comments, Tokens, Annotation Markers, Lexical Conventions
@comment  node-name,  next,  previous,  up
@section Documentation Comments

@cindex documentation comments
@kindex @code{*}
If what looks like a C-style comment starts with an asterisk (@code{*})
then it is a @dfn{documentation comment}.
The syntax is given below.
The syntax @var{doc-comment-ignored} is used for documentation comments
that are ignored by JML.

@c [[[DRC - javadoc allows comments to end with ******/
@c    When this JML enhancement is made, we need to change the grammar
@c    below. ]]]

@cindex @var{doc-comment}, defined
@cindex @var{doc-comment-ignored}, defined
@cindex @var{doc-comment-body}, used
@cindex @var{doc-comment}, used
@kindex @code{/**}
@kindex @code{*}
@kindex @code{*/}
@display
@var{doc-comment} ::= @code{/**} [ @code{*} ] @dots{} @var{doc-comment-body} @code{*/}
@var{doc-comment-ignored} ::= @var{doc-comment}
@end display

@cindex documentation comments, and annotations
@cindex annotations, and documentation comments
At the level of the rest of the JML grammar, a documentation comment
that does not contain an embedded JML method specification is essentially
described by the above, and the fact that a @var{doc-comment-body} cannot
contain the two-character sequence @code{*/}.

@cindex javadoc
However, JML and @code{javadoc} both pay attention
to the syntax inside of these documentation comments.  This syntax is
really best described by a context-free syntax that builds on
a lexical syntax.  However, because much of the documentation is free-form,
the context-free syntax has a lexical flavor to it, and is quite line-oriented.
Thus it should come as no surprise that the first non-whitespace, non-asterisk
(ie., not @code{*}) character on a line determines its interpretation.

@cindex @var{doc-comment-body}, defined
@cindex @var{description}, defined
@cindex @var{tagged-paragraph}, defined
@cindex @var{jml-specs}, defined
@cindex @var{description}, used
@cindex @var{tagged-paragraph}, used
@cindex @var{jml-specs}, used
@cindex @var{doc-non-empty-textline}, used
@cindex @var{paragraph-tag}, used
@cindex @var{doc-non-nl-ws}, used
@cindex @var{doc-atsign}, used
@cindex @var{jml-tag}, used
@cindex @var{method-specification}, used
@cindex @var{end-jml-tag}, used
@display
@var{doc-comment-body} ::= [ @var{description} ] @dots{}
                     [ @var{tagged-paragraph} ] @dots{} 
                     [ @var{jml-specs} ]
@var{description} ::= @var{doc-non-empty-textline}
@var{tagged-paragraph} ::= @var{paragraph-tag} [ @var{doc-non-nl-ws} ] @dots{}
             [ @var{doc-atsign} ] @dots{} [ @var{description} ] @dots{}
@var{jml-specs} ::= @var{jml-tag} [ @var{method-specification} ] @var{end-jml-tag}
             [ @var{jml-tag} [ @var{method-specification} ] @var{end-jml-tag} ] @dots{}
@end display

@cindex documentation comment, lexical grammar within
@cindex @var{method-specification}, in documentation comments
The microsyntax or lexical grammar used within documentation comments
is as follows.  Note that the token @var{doc-nl-ws} can only occur at
the end of a line, and is always ignored
within documentation comments.  Ignoring @var{doc-nl-ws}
means that any asterisks at the beginning of the next line, even in the part
that would be a JML @var{method-specification}, are also ignored.
Otherwise the lexical syntax within a @var{method-specification} is as in
the rest of JML.  This method specification is attached to
the following method or constructor declaration.
(Currently there is no useful way to use such specifications
in the documentation comments for other declarations.)
Note the exception to the grammar of @var{doc-non-empty-textline}.

@cindex @var{paragraph-tag}, defined
@cindex @var{doc-atsign}, defined
@cindex @var{doc-nl-ws}, defined
@cindex @var{doc-non-nl-ws}, defined
@cindex @var{doc-non-empty-textline}, defined
@cindex @var{jml-tag}, defined
@cindex @var{end-jml-tag}, defined
@cindex @var{letter}, used
@cindex @var{end-of-line}, used
@cindex @var{doc-non-nl-ws} , used
@cindex @var{non-nl-white-space}, used
@cindex @var{non-at-end-of-line}, used
@cindex @var{non-end-of-line}, used
@kindex @code{@@author}
@kindex @code{@@deprecated}
@kindex @code{@@exception}
@kindex @code{@@param}
@kindex @code{@@return}
@kindex @code{@@see}
@kindex @code{@@serial}
@kindex @code{@@serialdata}
@kindex @code{@@serialfield}
@kindex @code{@@since}
@kindex @code{@@throws}
@kindex @code{@@version}
@kindex @code{@@}
@kindex @code{*}
@kindex @code{<jml>}
@kindex @code{<JML>}
@kindex @code{<esc>}
@kindex @code{<ESC>}
@kindex @code{</jml>}
@kindex @code{</JML>}
@kindex @code{</esc>}
@kindex @code{</ESC>}
@display
@group
@var{paragraph-tag} ::= @code{@@author} | @code{@@deprecated} | @code{@@exception} 
        | @code{@@param} | @code{@@return} | @code{@@see}
        | @code{@@serial} | @code{@@serialdata} | @code{@@serialfield}
        | @code{@@since} | @code{@@throws} | @code{@@version}
        | @code{@@} @var{letter} [ @var{letter} ] @dots{}
@var{doc-atsign} ::= @code{@@}
@var{doc-nl-ws} ::= @var{end-of-line}
          [ @var{doc-non-nl-ws} ] @dots{} [ @code{*} [ @code{*} ] @dots{} [ @var{doc-non-nl-ws} ] @dots{} ]
@var{doc-non-nl-ws} ::= @var{non-nl-white-space}
@var{doc-non-empty-textline} ::= @var{non-at-end-of-line} [ @var{non-end-of-line} ] @dots{}
@var{jml-tag} ::= @code{<jml>} | @code{<JML>} | @code{<esc>} | @code{<ESC>}
@var{end-jml-tag} ::= @code{</jml>} | @code{</JML>} | @code{</esc>} | @code{</ESC>}
@end group
@end display

A @var{jml-tag} marks the (temporary) end of a documentation comment and the
beginning of text contributing to a method specification.  The corresponding
@var{end-jml-tag} marks the reverse transition.
The @var{end-jml-tag} must match the corresponding @var{jml-tag}.

@node Tokens,  , Documentation Comments, Lexical Conventions
@comment  node-name,  next,  previous,  up
@section Tokens

@cindex tokens
@cindex identifiers
@cindex reserved words
@cindex keywords
Character strings that are Java reserved words
are made into the token for that reserved word,
instead of being made into an @var{ident} token.
Within an @var{annotation} this also applies to @var{jml-keyword}s.
The details are given below.

@cindex @var{ident}, defined
@cindex @var{letter}, defined
@cindex @var{digit}, defined
@cindex @var{letter-or-digit}, defined
@cindex @var{letter}, used
@cindex @var{letter-or-digit}, used
@cindex @var{digit}, used
@kindex @code{_}
@kindex @code{$}
@kindex @code{a}-@code{z}
@kindex @code{A}-@code{Z}
@kindex @code{0}
@kindex @code{1}
@kindex @code{2}
@kindex @code{3}
@kindex @code{4}
@kindex @code{5}
@kindex @code{6}
@kindex @code{7}
@kindex @code{8}
@kindex @code{9}
@display
@var{ident} ::= @var{letter} [ @var{letter-or-digit} ] @dots{}
@var{letter} ::= @code{_}, @code{$}, @code{a} through @code{z}, or @code{A} through @code{Z}
@var{digit} ::= @code{0} | @code{1} | @code{2} | @code{3} | @code{4} | @code{5} | @code{6} | @code{7} | @code{8} | @code{9}
@var{letter-or-digit} ::= @var{letter} | @var{digit}
@end display

@cindex Java reserved words
Several strings of characters are recognized as keywords or reserved
words in JML. These fall into three separate categories: Java keywords,
JML predicate keywords (which start with a backslash), and JML keywords.
Java keywords are truly reserved words, and are recognized in all
contexts.  The nonterminal @var{java-reserved-word} represents the reserved
words in Java (as in the JDK version 1.4). 

@cindex JML keywords, where recognized
The @var{jml-keyword}s are only
recognized as keywords when they occur within an annotation,
but outside of a @var{spec-expression}
@var{store-ref-list} or @var{constrained-list}.
JML predicate keywords are also only recognized within annotations, but
they are recognized only inside @var{spec-expression}s,
@var{store-ref-list}s, and @var{constrained-list}s.

@cindex syntax options
@cindex MultiJava
@cindex Clifton
There are options to the JML tools that extend the language in various
ways.  When an option to parse the syntax for MultiJava
[Clifton-etal00] is in turned on, the word @code{resend},
which is the only word in the nonterminal @var{multijava-reserved}, is
recognized as a reserved word.  It is thus recognized in all contexts.
When this option is on, the @var{multijava-separators} (see below) are also
recognized. 

@cindex Universe type system syntax
@cindex Universe keywords, where recognized
@cindex Dietl
@cindex Mueller
Similarly, when an option to parse the syntax for the Universe type system 
[Dietl-Mueller05] is used, 
the words listed in the nonterminal @code{java-universe-reserved}
also act like reserved words in Java (and are thus recognized in all contexts).
When an option to recognize the Universe system syntax in annotations
is used, these words instead act as @var{jml-keyword}s and are only
recognized in annotations.
However, even when no Universe options are used,
@code{pure} is recognized as a keyword in annotations,
since it is also a @var{jml-keyword}.
(The Universe type system support in JML is experimental.  Most likely
the list of @code{java-universe-reserved} will be added to the list of
@var{jml-keyword}s eventually.)

However, even without the Universe option being on,
the @code{jml-universe-pkeyword} syntax is recognized within JML
annotations in the same way as JML predicate keywords are recognized.

The details are given below.

@c To check the list of jml-predicate-keywords, look in the file
@c ../../org/jmlspecs/checker/JMLExprID.t.
@c To check the list of jml-keywords, look in the file
@c ../../org/jmlspecs/checker/JMLID.t.
@c To check the Java syntax, see ../../../MJ/org/multijava/mjc/MjcID.t.

@cindex @var{keyword}, defined
@cindex @var{java-reserved-word}, defined
@cindex @var{java-universe-reserved}, defined
@cindex @var{jml-predicate-keyword}, defined
@cindex @var{jml-universe-pkeyword}, defined
@cindex @var{jml-keyword}, defined
@cindex @var{jml-universe-keyword}, defined
@cindex @var{java-reserved-word}, used
@cindex @var{jml-predicate-keyword}, used
@cindex @var{jml-universe-pkeyword}, used
@cindex @var{jml-keyword}, used
@cindex @var{jml-universe-keyword}, used
@kindex @code{abstract}
@kindex @code{assert}
@kindex @code{boolean}
@kindex @code{break}
@kindex @code{byte}
@kindex @code{case}
@kindex @code{catch}
@kindex @code{char}
@kindex @code{class}
@kindex @code{const}
@kindex @code{continue}
@kindex @code{default}
@kindex @code{do}
@kindex @code{double}
@kindex @code{else}
@kindex @code{extends}
@kindex @code{false}
@kindex @code{final}
@kindex @code{finally}
@kindex @code{float}
@kindex @code{for}
@kindex @code{goto}
@kindex @code{if}
@kindex @code{implements}
@kindex @code{import}
@kindex @code{instanceof}
@kindex @code{int}
@kindex @code{interface}
@kindex @code{long}
@kindex @code{native}
@kindex @code{new}
@kindex @code{null}
@kindex @code{package}
@kindex @code{private}
@kindex @code{protected}
@kindex @code{public}
@kindex @code{return}
@kindex @code{short}
@kindex @code{static}
@kindex @code{strictfp}
@kindex @code{super}
@kindex @code{switch}
@kindex @code{synchronized}
@kindex @code{this}
@kindex @code{throw}
@kindex @code{throws}
@kindex @code{transient}
@kindex @code{true}
@kindex @code{try}
@kindex @code{void}
@kindex @code{volatile}
@kindex @code{while}
@kindex @code{resend}
@kindex @code{peer}
@kindex @code{pure}
@kindex @code{readonly}
@kindex @code{rep}
@kindex @code{\TYPE}
@kindex @code{\bigint}
@kindex @code{\bigint_math}
@kindex @code{\duration}
@kindex @code{\elemtype}
@kindex @code{\everything}
@kindex @code{\exists}
@kindex @code{\forall}
@kindex @code{\fresh}
@kindex @code{\into}
@kindex @code{\invariant_for}
@kindex @code{\is_initialized}
@kindex @code{\java_math}
@kindex @code{\lblneg}
@kindex @code{\lblpos}
@kindex @code{\lockset}
@kindex @code{\max}
@kindex @code{\min}
@kindex @code{\nonnullelements}
@kindex @code{\not_assigned}
@kindex @code{\not_modified}
@kindex @code{\not_specified}
@kindex @code{\nothing}
@kindex @code{\nowarn}
@kindex @code{\nowarn_op}
@kindex @code{\num_of}
@kindex @code{\old}
@kindex @code{\pre}
@kindex @code{\only_accessed}
@kindex @code{\only_assigned}
@kindex @code{\only_called}
@kindex @code{\only_captured}
@kindex @code{\product}
@kindex @code{\reach}
@kindex @code{\real}
@kindex @code{\result}
@kindex @code{\safe_math}
@kindex @code{\same}
@kindex @code{\space}
@kindex @code{\such_that}
@kindex @code{\sum}
@kindex @code{\typeof}
@kindex @code{\type}
@kindex @code{\warn_op}
@kindex @code{\warn}
@kindex @code{\working_space} 
@kindex @code{\peer}
@kindex @code{\readonly}
@kindex @code{\rep}
@kindex @code{abrupt_behavior}
@kindex @code{abrupt_behaviour}
@kindex @code{accessible}
@kindex @code{accessible_redundantly}
@kindex @code{also}
@kindex @code{assert_redundantly}
@kindex @code{assignable}
@kindex @code{assignable_redundantly}
@kindex @code{assume}
@kindex @code{assume_redundantly}
@kindex @code{axiom}
@kindex @code{behavior}
@kindex @code{behaviour}
@kindex @code{breaks}
@kindex @code{breaks_redundantly}
@kindex @code{callable}
@kindex @code{callable_redundantly}
@kindex @code{captures}
@kindex @code{captures_redundantly}
@kindex @code{choose}
@kindex @code{choose_if}
@kindex @code{code}
@kindex @code{code_bigint_math}
@kindex @code{code_java_math}
@kindex @code{code_safe_math}
@kindex @code{constraint}
@kindex @code{constraint_redundantly}
@kindex @code{constructor}
@kindex @code{continues}
@kindex @code{continues_redundantly}
@kindex @code{decreases}
@kindex @code{decreases_redundantly} 
@kindex @code{decreasing}
@kindex @code{decreasing_redundantly} 
@kindex @code{diverges}
@kindex @code{diverges_redundantly}
@kindex @code{duration}
@kindex @code{duration_redundantly}
@kindex @code{ensures}
@kindex @code{ensures_redundantly}
@kindex @code{example}
@kindex @code{exceptional_behavior}
@kindex @code{exceptional_behaviour}
@kindex @code{exceptional_example}
@kindex @code{exsures}
@kindex @code{exsures_redundantly}
@kindex @code{extract}
@kindex @code{field}
@kindex @code{forall}
@kindex @code{for_example}
@kindex @code{ghost}
@kindex @code{helper}
@kindex @code{hence_by}
@kindex @code{hence_by_redundantly}
@kindex @code{implies_that}
@kindex @code{in}
@kindex @code{in_redundantly}
@kindex @code{initializer}
@kindex @code{initially}
@kindex @code{instance}
@kindex @code{invariant}
@kindex @code{invariant_redundantly}
@kindex @code{loop_invariant}
@kindex @code{loop_invariant_redundantly}
@kindex @code{maintaining}
@kindex @code{maintaining_redundantly}
@kindex @code{maps}
@kindex @code{maps_redundantly}
@kindex @code{measured_by}
@kindex @code{measured_by_redundantly}
@kindex @code{method}
@kindex @code{model}
@kindex @code{model_program}
@kindex @code{modifiable}
@kindex @code{modifiable_redundantly}
@kindex @code{modifies}
@kindex @code{modifies_redundantly}
@kindex @code{monitored}
@kindex @code{monitors_for}
@kindex @code{non_null}
@kindex @code{normal_behavior}
@kindex @code{normal_behaviour}
@kindex @code{normal_example}
@kindex @code{nowarn}
@kindex @code{nullable}
@kindex @code{nullable_by_default}
@kindex @code{old}
@kindex @code{or}
@kindex @code{post}
@kindex @code{post_redundantly}
@kindex @code{pre}
@kindex @code{pre_redundantly}
@kindex @code{pure}
@kindex @code{readable}
@kindex @code{refine}
@kindex @code{refines}
@kindex @code{refining}
@kindex @code{represents}
@kindex @code{represents_redundantly}
@kindex @code{requires}
@kindex @code{requires_redundantly}
@kindex @code{returns}
@kindex @code{returns_redundantly}
@kindex @code{set}
@kindex @code{signals}
@kindex @code{signals_only}
@kindex @code{signals_only_redundantly}
@kindex @code{signals_redundantly}
@kindex @code{spec_bigint_math}
@kindex @code{spec_java_math}
@kindex @code{spec_protected}
@kindex @code{spec_public}
@kindex @code{spec_safe_math}
@kindex @code{static_initializer}
@kindex @code{uninitialized}
@kindex @code{unreachable}
@kindex @code{weakly}
@kindex @code{when}
@kindex @code{when_redundantly}
@kindex @code{working_space}
@kindex @code{working_space_redundantly}
@kindex @code{writable}
@display
@var{keyword} ::= @var{java-reserved-word}
        | @var{jml-predicate-keyword} | @var{jml-keyword}
@var{java-reserved-word} ::= @code{abstract} | @code{assert}
        | @code{boolean} | @code{break} | @code{byte}
        | @code{case} | @code{catch} | @code{char}
        | @code{class} | @code{const} | @code{continue}
        | @code{default} | @code{do} | @code{double}
        | @code{else} | @code{extends} | @code{false}
        | @code{final} | @code{finally} | @code{float}
        | @code{for} | @code{goto} | @code{if}
        | @code{implements} | @code{import} | @code{instanceof}
        | @code{int} | @code{interface} | @code{long}
        | @code{native} | @code{new} | @code{null}
        | @code{package} | @code{private} | @code{protected}
        | @code{public} | @code{return} | @code{short}
        | @code{static} | @code{strictfp} | @code{super}
        | @code{switch} | @code{synchronized} | @code{this}
        | @code{throw} | @code{throws} | @code{transient}
        | @code{true} | @code{try} | @code{void}
        | @code{volatile} | @code{while}
        | @var{multijava-reserved}      @i{// When the MultiJava option is on}
        | @var{java-universe-reserved}  @i{// When the Universe option is on}
@var{multijava-reserved} ::= @code{resend}
@var{java-universe-reserved} ::= @code{peer} | @code{pure}
        | @code{readonly} | @code{rep}
@var{jml-predicate-keyword} ::= @code{\TYPE}
        | @code{\bigint} | @code{\bigint_math} | @code{\duration}
        | @code{\elemtype} | @code{\everything} | @code{\exists}
        | @code{\forall} | @code{\fresh}
        | @code{\into} | @code{\invariant_for} | @code{\is_initialized}
        | @code{\java_math} | @code{\lblneg} | @code{\lblpos}
        | @code{\lockset} | @code{\max} | @code{\min}
        | @code{\nonnullelements} | @code{\not_assigned}
        | @code{\not_modified} | @code{\not_specified}
        | @code{\nothing} | @code{\nowarn} | @code{\nowarn_op}
        | @code{\num_of} | @code{\old} | @code{\only_accessed} 
        | @code{\only_assigned} | @code{\only_called}
        | @code{\only_captured} | @code{\pre}
        | @code{\product} | @code{\reach} | @code{\real}
        | @code{\result} | @code{\same} | @code{\safe_math}
        | @code{\space} | @code{\such_that} | @code{\sum}
        | @code{\typeof} | @code{\type} | @code{\warn_op}
        | @code{\warn} | @code{\working_space} 
        | @var{jml-universe-pkeyword}
@var{jml-universe-pkeyword} ::= @code{\peer} | @code{\readonly} | @code{\rep}
@var{jml-keyword} ::= @code{abrupt_behavior} | @code{abrupt_behaviour}
        | @code{accessible} | @code{accessible_redundantly}
        | @code{also} | @code{assert_redundantly}
        | @code{assignable} | @code{assignable_redundantly}
        | @code{assume} | @code{assume_redundantly} | @code{axiom}
        | @code{behavior} | @code{behaviour}
        | @code{breaks} | @code{breaks_redundantly}
        | @code{callable} | @code{callable_redundantly}
        | @code{captures} | @code{captures_redundantly}
        | @code{choose} | @code{choose_if} 
        | @code{code} | @code{code_bigint_math} | 
        | @code{code_java_math} | @code{code_safe_math}
        | @code{constraint} | @code{constraint_redundantly}
        | @code{constructor} | @code{continues} | @code{continues_redundantly}
        | @code{decreases} | @code{decreases_redundantly} 
        | @code{decreasing} | @code{decreasing_redundantly} 
        | @code{diverges} | @code{diverges_redundantly}
        | @code{duration} | @code{duration_redundantly}
        | @code{ensures} | @code{ensures_redundantly} | @code{example}
        | @code{exceptional_behavior} | @code{exceptional_behaviour}
        | @code{exceptional_example}
        | @code{exsures} | @code{exsures_redundantly} | @code{extract}
        | @code{field} | @code{forall}
        | @code{for_example} | @code{ghost}
        | @code{helper} | @code{hence_by} | @code{hence_by_redundantly}
        | @code{implies_that} | @code{in} | @code{in_redundantly}
        | @code{initializer} | @code{initially} | @code{instance}
        | @code{invariant} | @code{invariant_redundantly}
        | @code{loop_invariant} | @code{loop_invariant_redundantly}
        | @code{maintaining} | @code{maintaining_redundantly}
        | @code{maps} | @code{maps_redundantly}
        | @code{measured_by} | @code{measured_by_redundantly}
        | @code{method} | @code{model} | @code{model_program}
        | @code{modifiable} | @code{modifiable_redundantly}
        | @code{modifies} | @code{modifies_redundantly}
        | @code{monitored} | @code{monitors_for} | @code{non_null}
        | @code{normal_behavior} | @code{normal_behaviour}
        | @code{normal_example} | @code{nowarn}
        | @code{nullable} | @code{nullable_by_default}
        | @code{old} | @code{or}
        | @code{post} | @code{post_redundantly}
        | @code{pre} | @code{pre_redundantly}
        | @code{pure} | @code{readable} 
        | @code{refine} | @code{refines} | @code{refining}
        | @code{represents} | @code{represents_redundantly}
        | @code{requires} | @code{requires_redundantly}
        | @code{returns} | @code{returns_redundantly}
        | @code{set} | @code{signals} | @code{signals_only}
        | @code{signals_only_redundantly} | @code{signals_redundantly}
        | @code{spec_bigint_math} | @code{spec_java_math}
        | @code{spec_protected} | @code{spec_public} | @code{spec_safe_math}
        | @code{static_initializer} | @code{uninitialized}
        | @code{unreachable} | @code{weakly}
        | @code{when} | @code{when_redundantly}
        | @code{working_space} | @code{working_space_redundantly}
        | @code{writable}
        | @var{jml-universe-keyword}
@var{jml-universe-keyword} ::= @code{peer} | @code{readonly} | @code{rep}
@end display

@cindex special symbols
@cindex Gosling
@cindex Joy
@cindex Steele
The following describes the special symbols used in JML.  The
nonterminal @var{java-special-symbol} is the special symbols of Java,
taken without change from Java [Gosling-Joy-Steele96].

@c The syntax of jml-special-symbols can be verified from 
@c ../../org/jmlspecs/checker/JMLID.t.

@cindex @var{special-symbol}, defined
@cindex @var{java-special-symbol}, defined
@cindex @var{java-separator}, defined
@cindex @var{multijava-separator}, defined
@cindex @var{java-operator}, defined
@cindex @var{jml-special-symbol}, defined
@cindex @var{java-special-symbol}, used
@cindex @var{jml-special-symbol}, used
@cindex @var{java-separator}, used
@cindex @var{multijava-separator}, used
@cindex @var{java-operator}, used
@kindex @code{(}
@kindex @code{)}
@kindex @code{@{}
@kindex @code{@}}
@kindex @code{[}
@kindex @code{]}
@kindex @code{;}
@kindex @code{,}
@kindex @code{.}
@kindex @code{=}
@kindex @code{<}
@kindex @code{>}
@kindex @code{!}
@kindex @code{~}
@kindex @code{?}
@kindex @code{:}
@kindex @code{==}
@kindex @code{<=}
@kindex @code{>=}
@kindex @code{!=}
@kindex @code{&&}
@kindex @code{||}
@kindex @code{++}
@kindex @code{--}
@kindex @code{+}
@kindex @code{-}
@kindex @code{*}
@kindex @code{/}
@kindex @code{&}
@kindex @code{|}
@kindex @code{^}
@kindex @code{%}
@kindex @code{<<}
@kindex @code{>>}
@kindex @code{>>>}
@kindex @code{+=}
@kindex @code{-=}
@kindex @code{*=}
@kindex @code{/=}
@kindex @code{&=}
@kindex @code{|=}
@kindex @code{^=}
@kindex @code{%=}
@kindex @code{<<=}
@kindex @code{>>=}
@kindex @code{>>>=}
@kindex @code{==>}
@kindex @code{<==}
@kindex @code{<==>}
@kindex @code{<=!=>}
@kindex @code{->}
@kindex @code{<-}
@kindex @code{<:}
@kindex @code{..}
@kindex @code{@{|}
@kindex @code{|@}}
@kindex @code{@@}
@kindex @code{@@@@}
@display
@var{special-symbol} ::= @var{java-special-symbol} | @var{jml-special-symbol}
@var{java-special-symbol} ::= @var{java-separator} | @var{java-operator}
@var{java-separator} ::= @code{(} | @code{)} | @code{@{} | @code{@}} | `@code{[}' | `@code{]}' | @code{;} | @code{,} | @code{.}
        | @var{multijava-separator}   @i{// When the MultiJava option is on}
@var{multijava-separator} ::= @code{@@} | @code{@@@@}
@var{java-operator} ::= @code{=} | @code{<} | @code{>} | @code{!} | @code{~} | @code{?} | @code{:}
        | @code{==} | @code{<=} | @code{>=} | @code{!=} | @code{&&} | `@code{||}' | @code{++} | @code{--}
        | @code{+} | @code{-} | @code{*} | @code{/} | @code{&} | `@code{|}' | @code{^} | @code{%} | @code{<<} | @code{>>} | @code{>>>}
        | @code{+=} | @code{-=} | @code{*=} | @code{/=} | @code{&=} | `@code{|=}' | @code{^=} | @code{%=}
        | @code{<<=} | @code{>>=} | @code{>>>=}
@var{jml-special-symbol} ::= @code{==>} | @code{<==} | @code{<==>} | @code{<=!=>}
        | @code{->} | @code{<-} | @code{<:} | @code{..} | `@code{@{|}' | `@code{|@}}'
@end display

@cindex literals
@cindex Gosling
@cindex Joy
@cindex Steele
The nonterminal @var{java-literal} represents Java literals
which are taken without change from Java [Gosling-Joy-Steele96].

@cindex @var{java-literal}, defined
@cindex @var{integer-literal}, defined
@cindex @var{decimal-integer-literal}, defined
@cindex @var{decimal-numeral}, defined
@cindex @var{digits}, defined
@cindex @var{digit}, defined
@cindex @var{non-zero-digit}, defined
@cindex @var{integer-type-suffix}, defined
@cindex @var{hex-integer-literal}, defined
@cindex @var{hex-numeral}, defined
@cindex @var{hex-digit}, defined
@cindex @var{octal-integer-literal}, defined
@cindex @var{octal-numeral}, defined
@cindex @var{octal-digit}, defined
@cindex @var{floating-point-literal}, defined
@cindex @var{exponent-part}, defined
@cindex @var{exponent-indicator}, defined
@cindex @var{signed-integer}, defined
@cindex @var{sign}, defined
@cindex @var{float-type-suffix}, defined
@cindex @var{boolean-literal}, defined
@cindex @var{character-literal}, defined
@cindex @var{single-character}, defined
@cindex @var{escape-sequence}, defined
@cindex @var{octal-escape}, defined
@cindex @var{zero-to-three}, defined
@cindex @var{unicode-escape}, defined
@cindex @var{string-literal}, defined
@cindex @var{null-literal}, defined
@c
@cindex @var{integer-literal}, used
@cindex @var{decimal-integer-literal}, used
@cindex @var{decimal-numeral}, used
@cindex @var{digits}, used
@cindex @var{digit}, used
@cindex @var{non-zero-digit}, used
@cindex @var{integer-type-suffix}, used
@cindex @var{hex-integer-literal}, used
@cindex @var{hex-numeral}, used
@cindex @var{hex-digit}, used
@cindex @var{octal-integer-literal}, used
@cindex @var{octal-numeral}, used
@cindex @var{octal-digit}, used
@cindex @var{floating-point-literal}, used
@cindex @var{exponent-part}, used
@cindex @var{exponent-indicator}, used
@cindex @var{signed-integer}, used
@cindex @var{sign}, used
@cindex @var{float-type-suffix}, used
@cindex @var{boolean-literal}, used
@cindex @var{character-literal}, used
@cindex @var{single-character}, used
@cindex @var{escape-sequence}, used
@cindex @var{octal-escape}, used
@cindex @var{zero-to-three}, used
@cindex @var{unicode-escape}, used
@cindex @var{string-literal}, used
@cindex @var{null-literal}, used
@c
@kindex @code{0}
@kindex @code{1}
@kindex @code{2}
@kindex @code{3}
@kindex @code{4}
@kindex @code{5}
@kindex @code{6}
@kindex @code{7}
@kindex @code{8}
@kindex @code{9}
@kindex @code{l}
@kindex @code{L}
@kindex @code{0x}
@kindex @code{0X}
@kindex @var{digit}
@kindex @code{a}
@kindex @code{b}
@kindex @code{c}
@kindex @code{d}
@kindex @code{e}
@kindex @code{f}
@kindex @code{A}
@kindex @code{B}
@kindex @code{C}
@kindex @code{D}
@kindex @code{E}
@kindex @code{F}
@kindex @code{.}
@kindex @code{+}
@kindex @code{-}
@kindex @code{true}
@kindex @code{false}
@kindex @code{'}
@kindex @code{\}
@cindex carriage return
@cindex newline
@cindex backspace
@cindex tab
@cindex backslash
@cindex single quote
@cindex double quote
@kindex @code{\b}
@kindex @code{\t}
@kindex @code{\n}
@kindex @code{\r}
@kindex @code{\'}
@kindex @code{\"}
@kindex @code{\\}
@kindex @code{\}
@kindex @code{\u}
@kindex @code{"}
@kindex @code{null}
@display
@var{java-literal} ::= @var{integer-literal}
        | @var{floating-point-literal} | @var{boolean-literal}
        | @var{character-literal} | @var{string-literal} | @var{null-literal}

@var{integer-literal} ::= @var{decimal-integer-literal}
        | @var{hex-integer-literal} | @var{octal-integer-literal}
@var{decimal-integer-literal} ::= @var{decimal-numeral} [ @var{integer-type-suffix} ]
@var{decimal-numeral} ::= @code{0} | @var{non-zero-digit} [ @var{digits} ]
@var{digits} ::= @var{digit} [ @var{digit} ] @dots{}
@var{digit} ::= @code{0} | @var{non-zero-digit}
@var{non-zero-digit} ::= @code{1} | @code{2} | @code{3} | @code{4} | @code{5} | @code{6} | @code{7} | @code{8} | @code{9}
@var{integer-type-suffix} ::= @code{l} | @code{L}
@var{hex-integer-literal} ::= @var{hex-numeral}  [ @var{integer-type-suffix} ]
@var{hex-numeral} ::= @code{0x} @var{hex-digit} [ @var{hex-digit} ] @dots{}
        | @code{0X} @var{hex-digit}  [ @var{hex-digit} ] @dots{}
@var{hex-digit} ::= @var{digit} | @code{a} | @code{b} | @code{c} | @code{d} | @code{e} | @code{f}
        | @code{A} | @code{B} | @code{C} | @code{D} | @code{E} | @code{F}
@var{octal-integer-literal} ::= @var{octal-numeral}  [ @var{integer-type-suffix} ]
@var{octal-numeral} ::= @code{0} @var{octal-digit} [ @var{octal-digit} ] @dots{} 
@var{octal-digit} ::= @code{0} | @code{1} | @code{2} | @code{3} | @code{4} | @code{5} | @code{6} | @code{7}

@var{floating-point-literal} ::= @var{digits} @code{.} [ @var{digits} ]
          [ @var{exponent-part} ] [ @var{float-type-suffix} ]
        | @code{.} @var{digits} [ @var{exponent-part} ] [ @var{float-type-suffix} ]
        | @var{digits} @var{exponent-part} [ @var{float-type-suffix} ]
        | @var{digits} [ @var{exponent-part} ] @var{float-type-suffix}
@var{exponent-part} ::= @var{exponent-indicator} @var{signed-integer}
@var{exponent-indicator} ::= @code{e} | @code{E}
@var{signed-integer} ::= [ @var{sign} ] @var{digits}
@var{sign} ::= @code{+} | @code{-}
@var{float-type-suffix} ::= @code{f} | @code{F} | @code{d} | @code{D}

@var{boolean-literal} ::= @code{true} | @code{false}

@var{character-literal} ::= @code{'} @var{single-character} @code{'} | @code{'} @var{escape-sequence} @code{'}
@var{single-character} ::= any character except @code{'}, @code{\}, carriage return, or newline
@var{escape-sequence} ::= @code{\b}    @i{// backspace}
         | @code{\t}                   @i{// tab}
         | @code{\n}                   @i{// newline}
         | @code{\r}                   @i{// carriage return}
         | @code{\'}                   @i{// single quote}
         | @code{\"}                   @i{// double quote}
         | @code{\\}                   @i{// backslash}
         | @var{octal-escape}
         | @var{unicode-escape}
@var{octal-escape} ::= @code{\} @var{octal-digit} [ @var{octal-digit} ]
         | @code{\} @var{zero-to-three} @var{octal-digit} @var{octal-digit}
@var{zero-to-three} ::= @code{0} | @code{1} | @code{2} | @code{3}
@var{unicode-escape} ::= @code{\u} @var{hex-digit} @var{hex-digit} @var{hex-digit} @var{hex-digit}

@var{string-literal} ::= @code{"} [ @var{string-character} ] @dots{} @code{"}
@var{string-character} ::= @var{escape-sequence}
         | any character except @code{"}, @code{\}, carriage return, or newline

@var{null-literal} ::= @code{null}
@end display

@cindex informal descriptions
An @var{informal-description} looks like @code{(* some text *)}.
It is used in predicates (@pxref{Predicates})
and store-ref expressions (@pxref{Store Refs}) as an escape from formality.

The exact syntax is given below.

@cindex @var{informal-description}, defined
@cindex @var{non-stars-close}, defined
@cindex @var{non-star-close}, defined
@cindex @var{stars-non-close}, defined
@cindex @var{non-stars-close}, used
@cindex @var{non-star-close}, used
@cindex @var{non-star}, used
@cindex @var{stars-non-close}, used
@kindex @code{(*}
@kindex @code{*)}
@kindex @code{*}
@kindex @code{)}
@display
@var{informal-description} ::= @code{(*} @var{non-stars-close} [ @var{non-stars-close} ] @dots{} @code{*)}
@var{non-stars-close} ::= @var{non-star}
        | @var{stars-non-close}
@var{stars-non-close} ::= @code{*} [ @code{*} ] @dots{} @var{non-star-close}
@var{non-star-close} ::= any character except @code{)} or @code{*}
@end display

@c -------- chapter Compilation Units ---------------
@node Compilation Units, Type Definitions, Lexical Conventions, Top
@c  node-name,  next,  previous,  up
@chapter Compilation Units

@c [[[In general, one can check the context-free syntax by referring to
@c Jml.g and Mjc.g.  But it's more convenient to use the grammar in
@c ../../org/jmlspecs/checker/expandedJml.g, as this takes inheritance into
@c account.]]] 

@cindex compilation unit
A compilation unit in JML is similar to that in Java, with some
additions.  It has the following syntax.

@cindex @var{compilation-unit}, defined
@cindex @var{top-level-definition}, defined
@cindex @var{package-definition}, used
@cindex @var{refine-prefix}, used
@cindex @var{import-definition}, used
@cindex @var{top-level-definition}, used
@cindex @var{type-definition}, used
@cindex @var{multijava-top-level-declaration}, used
@display
@var{compilation-unit} ::= [ @var{package-definition} ]
              [ @var{refine-prefix} ] 
              [ @var{import-definition} ] @dots{}
              [ @var{top-level-definition} ] @dots{}
@var{top-level-definition} ::= @var{type-definition}
        | @var{multijava-top-level-declaration}  @i{// When parsing MultiJava}
@end display

@cindex grammar, start rule
@cindex start rule, in JML grammar
@cindex @var{white-space}
The @var{compilation-unit} rule is the start rule for the JML grammar.
(In this syntactic rule and in all other rules in the rest of the body
of this manual, @var{white-space} may appear between any two
tokens. @xref{Lexical Conventions}, for details.)

@xref{Type Definitions}, for the syntax and semantics of
@var{type-definition}s.
@xref{Augmenting Method Declarations}, for the syntax and semantics of 
@var{multijava-top-level-declaration}.
@xref{Refinement}, for a discussion of the @var{refine-prefix} and its uses.

@cindex MultiJava
@cindex Universe
@cindex Clifton
@cindex Dietl
@cindex Mueller
Some JML tools may support various optional extensions to JML.  This
manual partially describes two such extensions:
MultiJava [Clifton-etal00] 
and
the Universe type [Dietl-Mueller05].
Comments in the grammar indicate optional productions; these are only
used by tools that select an option to parse the syntax in question.
Tools for JML do not have to support these extensions to JML, and may
themselves support other JML extensions.  In general, JML tools will
support a (hopefully well-documented) variant of the language described
in this manual.

@cindex compilation unit, and public types
@cindex public type, in a compilation unit
@cindex Gosling
The Java code in a compilation unit must be legal Java code (or legal
code in the Java extension, such as MultiJava, selected by any options);
in particular it must obey all of Java's static restrictions.
For example, at most one of the type definitions in a compilation unit
may be declared @code{public}.
See the @cite{Java Language Specification} [Gosling-etal00] 
for details.

@cindex compilation unit, file name for
@cindex file name for a compilation unit
As in Java, JML can be implemented
using files to store compilation units.  When this is done there must also
be a correspondence between the name of any public type defined in a
compilation unit and the file name.  This is done exactly as in Java,
although JML allows additional file name suffixes.
@xref{File Name Suffixes}, for details on the file name suffixes
allowed in JML.

@cindex compilation unit, mutual recursion in
The specification of the compilation unit consists of the
specifications of the @var{top-level-definition}s it contains, placed in
the declared package (if any).  The interface part of this specification is
determined as in Java [Gosling-etal00] (or as in the Java extension used).
The specifications of each @var{type-definition} are computed by starting
from an environment that contains the declared package (if any),
each top-level definition in the compilation unit (to allow for
mutual recursion), and the imports [Gosling-etal00].
In JML, not only is the package @code{java.lang} implicitly imported, but also
there is an implicit model import of @code{org.jmlspecs.lang}.
(@xref{Import Definitions}, for the meaning of a model import.)

@cindex compilation unit, satisfaction of
Ignoring refinement,
a Java compilation unit satisfies such a JML specification if it
satisfies the specified @var{package-definition} (if any), and if
for each specified @var{type-definition}, there
is a corresponding Java @var{type-definition} that satisfies that
type's JML specification. 
Furthermore, if the JML specification does not contain a
public type, then the Java compilation unit may not contain a public
type.

The syntax and semantics of @var{package-definition}s and
@var{import-definition}s are discussed in the subsections below.

@menu
* Package Definitions::         
* Import Definitions::          
@end menu

@node Package Definitions, Import Definitions, Compilation Units, Compilation Units
@c  node-name,  next,  previous,  up
@section Package Definitions

@cindex package definitions
The syntax of a @var{package-definition} is as in Java [Gosling-etal00].

@cindex @var{package-definition}, defined
@cindex @var{name}, defined
@cindex @var{name}, used
@cindex @var{ident}, used
@kindex @code{package}
@kindex @code{;}
@kindex @code{.}
@display
@var{package-definition} ::= @code{package} @var{name} @code{;}
@var{name} ::= @var{ident}  [ @code{.} @var{ident} ] @dots{}
@end display

@cindex package definition, satisfaction of
@cindex satisfaction of a package definition
A Java package definition satisfies the JML specification only if it
is the same as that specified.  That is, the Java code has
to be the same (modulo @var{white-space}) as the JML specification.

@node Import Definitions,  , Package Definitions, Compilation Units
@c  node-name,  next,  previous,  up
@section Import Definitions

@cindex import definition
The syntax of a @var{import-definition} is as follows.
The only difference from the Java syntax [Gosling-etal00]
is the optional @code{model} modifier.

@cindex @var{import-definition}, defined
@cindex @var{name-star}, defined
@cindex @var{name}, used
@cindex @var{name-star}, used
@cindex @var{ident}, used
@kindex @code{model}
@kindex @code{import}
@kindex @code{;}
@kindex @code{.}
@kindex @code{*}
@display
@var{import-definition} ::= [ @code{model} ] @code{import} @var{name-star} @code{;}
@var{name-star} ::= @var{ident} [ @code{.} @var{ident} ] @dots{} [ @code{.} @code{*} ]
@end display

@cindex model import, vs. import
An @var{import-definition} may use the @code{model} modifier
if and only if the whole @var{import-definition} is entirely contained
within a single annotation. For example, the following is illegal.

@display
@code{/*@@ model @@*/ import com.foo.*; // illegal!} 
@end display

@noindent
To write an import that affects both the JML annotations and Java
code, just use a normal java import, without using the @code{model}
modifier.

The effect on the interface computed for a compilation unit of an
@var{import-definition} without the @code{model} 
keyword is the same as in Java [Gosling-etal00].  Such import
directives affect the computation of the interface of the Java code as
well as the JML specification (that is, they apply to both equally).

@cindex model import definition
@cindex import, model
@kindex @code{model}
When the @code{model} keyword is used, 
the import only has an effect on the JML annotations (and not on the
Java code).  The abbreviation permitted by the use of such an import,
however, is the same as would be effected by a normal Java import.
Such model imports can affect the computation of the interface
of the JML specification by being used in the declarations of model
and ghost features.

Both normal Java and model imports do not themselves contribute to the
interface of a JML specification.  As such, they do not have to be
present in a correct implementation of the specification.  An
implementation could, for example, use different forms of import, or
it could use fully qualified names instead of imports, and achieve the
same effect as using the imports in the specification.

@c -------- chapter Type Definitions ---------------
@node Type Definitions, Class and Interface Member Declarations, Compilation Units, Top
@comment  node-name,  next,  previous,  up
@chapter Type Definitions

@cindex type definitions
@cindex class definitions
@cindex interface definitions
The following is the syntax of type definitions.

@cindex @var{type-definition}, defined
@cindex @var{class-definition}, used
@cindex @var{interface-definition}, used
@kindex @code{;}
@display
@var{type-definition} ::= @var{class-definition}
        | @var{interface-definition}
        | @code{;}
@end display

The specification of a @var{type-definition} is determined as follows.
If the @var{type-definition} consists only of a semicolon (@code{;}),
then the specification is empty.  Otherwise the specification is that
of the class or interface definition.  Such a specification must be
satisfied by the corresponding class or interface definition.

The rest of this chapter discusses class and interface definitions,
as well as the syntax of modifiers.

@menu
* Class and Interface Definitions::  
* Modifiers::                   
@end menu

@node Class and Interface Definitions, Modifiers, Type Definitions, Type Definitions
@comment  node-name,  next,  previous,  up
@section Class and Interface Definitions

@cindex class definition
@cindex interface definition
@cindex Gosling
Class and interface definitions are quite similar, as interfaces may be
seen as a special kind of class definition that only allows the
declaration of abstract instance methods and final static fields (in
the Java code [Gosling-etal00]).
Their syntax is also similar.

@cindex @var{class-definition}, defined
@cindex @var{interface-definition}, defined
@cindex @var{class-block}, defined
@cindex @var{doc-comment}, used
@cindex @var{modifiers}, used
@cindex @var{class-extends-clause}, used
@cindex @var{implements-clause}, used
@cindex @var{class-block}, used
@cindex @var{ident}, used
@cindex @var{name}, used
@cindex @var{field}, used
@cindex @var{interface-extends}, used
@kindex @code{class}
@kindex @code{@{}
@kindex @code{@}}
@kindex @code{interface}
@display
@var{class-definition} ::= [ @var{doc-comment} ] @var{modifiers} @code{class} @var{ident}
            [ @var{class-extends-clause} ] [ @var{implements-clause} ]
            @var{class-block}
@var{class-block} ::= @code{@{} [ @var{field} ] @dots{} @code{@}}

@var{interface-definition} ::= [ @var{doc-comment} ] @var{modifiers} @code{interface} @var{ident}
           [ @var{interface-extends} ]
           @var{class-block}
@end display

Documentation comments for classes and interfaces may not
contain JML specification information.
@xref{Documentation Comments}, for the syntax of documentation
comments. 

@xref{Class and Interface Member Declarations}, for the syntax and semantics of @var{field}s,
which form the essence of classes and interfaces.

The rest of this section discusses subtyping for classes and
interfaces and also the particular modifiers used in classes and
interfaces.

@menu
* Subtyping for Type Definitions::  
* Modifiers for Type Definitions::  
@end menu

@node Subtyping for Type Definitions, Modifiers for Type Definitions, Class and Interface Definitions, Class and Interface Definitions
@comment  node-name,  next,  previous,  up
@subsection Subtyping for Type Definitions

@cindex class, inheritance
@cindex inheritance
@cindex subtyping
@cindex implementation of interfaces
@cindex extension of interfaces
Classes in Java can use single inheritance and may also implement any
number of interfaces.  Interfaces may extend any number of other
interfaces.

@cindex @var{class-extends-clause}, defined
@cindex @var{implements-clause}, defined
@cindex @var{name-weakly-list}, defined
@cindex @var{interface-definition}, defined
@cindex @var{interface-extends}, defined
@cindex @var{implements-clause}, used
@cindex @var{name-weakly-list}, used
@cindex @var{name}, used
@kindex @code{extends}
@kindex @code{weakly}
@kindex @code{implements}
@kindex @code{,}
@display
@var{class-extends-clause} ::= [ @code{extends} @var{name} [ @code{weakly} ] ]
@var{implements-clause} ::= @code{implements} @var{name-weakly-list}
@var{name-weakly-list} ::= @var{name} [ @code{weakly} ] [ @code{,} @var{name} [ @code{weakly} ] ] @dots{}
@var{interface-extends} ::= @code{extends} @var{name-weakly-list}
@end display

@cindex inheritance
@cindex inherits
@cindex subclass
@cindex superclass
@cindex subtype
@cindex extends, for classes
The meaning of inheritance in JML is similar to that in Java.
In Java, a when class @i{S} names a class @i{T} in @i{S}'s
@var{class-extends-clause}, then 
@i{S} is a @dfn{subclass} of @i{T} and @i{T} is a 
@dfn{superclass} of @i{S}; we also say that @i{S} @dfn{inherits} from
@i{T}.
This relationship also makes @i{S} a @dfn{subtype} of @i{T}, meaning
that variables 
of type @i{T} can refer to objects of type @i{S}.
In Java, when @i{S} is a subclass of @i{T}, then @i{S}
inherits all the instance fields and methods from @i{T}.

@cindex implements, for classes
@cindex subtype, of an interface
A class may also implement several interfaces, declared in its
@var{implements-clause}; the class thus becomes a subtype of each of
the interfaces that it implements.

@cindex extends, for interfaces
@cindex subtype, for an interface
Similarly, an interface may extend several other interfaces.
In Java, such an interface inherits all of the abstract methods and static
final fields from the interfaces it extends.
When interface @i{U} extends another interface @i{V},
then @i{U} is a subtype of @i{V}.

@cindex inheritance, of JML features
@cindex inheritance, of specifications
@cindex specifications inheritance
In JML, model and ghost features, as well as specifications are
inherited.  A subtype inherits from its supertypes:
@itemize @bullet
@item
all instance fields, including model and ghost fields,

@item
instance methods are also inherited and their specifications,

@item
instance invariants and instance history constraints.
@end itemize

@cindex inheritance, multiple
@cindex multiple inheritance
It is an error for a type to inherit a field @i{x} from two different
supertypes if that field is declared with different types.

@cindex MultiJava
@cindex Clifton
@cindex Gosling
It is an error for a type to inherit a method with the same formal
parameter types but with either different return types or with
conflicting throws clauses [Gosling-etal00].
(There are other restrictions on method inheritance that apply when
MultiJava is used [Clifton-etal00].)

@cindex inheritance, of model methods from interfaces
In Java one cannot inherit method implementations from interfaces, but
this is possible in JML, where one can implement a model method in an
interface.  It is illegal for a class or interface to inherit two
different implementations of a model method.


@cindex inheritance, of JML features
@cindex inheritance, of specifications
@cindex specifications inheritance
@cindex Dhara
@cindex Leavens
@kindex @code{weakly}
@cindex weak behavioral subtype
@cindex history constraint
In JML, instance methods have to obey the specifications of all
methods they override.  This, together with the inheritance of
invariants and history constraints, forces subtypes to be behavioral subtypes
[Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b].
However, history constraints are not inherited from supertypes whose
names are marked with @code{weakly} in the relevant clause.
Such subtypes are @dfn{weak behavioral subtypes}, and should only be
used in ways that do not permit cross-type aliasing [Dhara-Leavens94b]
[Dhara97]. 

@cindex Raghavan
@cindex Leavens
See the report, ``Desugaring JML Method Specifications''
[Raghavan-Leavens05] for more
about the details of specification inheritance in JML.

@c [[[This needs more work..., examples, etc.]]]

@node Modifiers for Type Definitions,  , Subtyping for Type Definitions, Class and Interface Definitions
@comment  node-name,  next,  previous,  up
@subsection Modifiers for Type Definitions

@cindex modifiers, for type definitions
@cindex modifiers, for classes
@cindex modifiers, for interfaces
@cindex type, modifiers for declarations of
@cindex class, modifiers for declarations of
@cindex interface, modifiers for declarations of
@kindex @code{pure}
@kindex @code{model}
@kindex @code{spec_java_math}
@kindex @code{spec_safe_math}
@kindex @code{spec_bigint_math}
@kindex @code{code_java_math}
@kindex @code{code_safe_math}
@kindex @code{code_bigint_math}
In addition to the Java modifiers that can be legally attached to a
class or interface definition [Gosling-etal00],
in JML one can use the following modifiers.
@example
  pure model
  spec_java_math spec_safe_math spec_bigint_math
  code_java_math code_safe_math code_bigint_math
  nullable_by_default
@end example
@xref{Modifiers}, for the syntax and semantics of modifiers in general.

@cindex pure, type definition modifier
@kindex @code{pure}
@cindex immutable
A type definition may be modified with the JML modifier keyword @code{pure}.
The effect of declaring a type @code{pure} is that all constructor and 
instance method declarations within the type are automatically
declared to be pure
(@pxref{Pure Methods and Constructors}, for more about pure methods).
Hence, once an object of a class is created, it
will be immutable, and furthermore, none of its instance methods will
have any side effects.  However, its static methods may still have
side effects, as the @code{pure} does not apply to the static methods
declared in a type.  Furthermore, although an override of a pure
method must be pure, instance methods declared in
subtypes that do not override this supertype's methods
need not be pure.  Hence, such a subtype does not necessarily have
immutable objects.  So, in essence, declaring a class pure
is merely a shorthand for declaring all of the constructors and
instance methods pure.

[[[ Pure does not make a class immutable either, since a method might
return a reference to an internal representation which is then modified
by some non-pure method in its class.  Is it sufficient if all fields are
also fields of pure types (recursively)?  Then there are arrays. 
And also all fields would need to be private to have immutability. - DRC ]]]

@cindex model, type definition modifier
@kindex @code{model}
@cindex specification-only type
A type declaration that is declared with the modifier @code{model}
is a specification-only type.
Hence, such a type may not be used in Java code, and may only be used
in annotations.  It follows that the
entire type definition must be contained within an annotation comment,
and consequently annotations within the type definition do not need to
be separately enclosed in annotation comments, 
as is demonstrated in the example below.
The scope rules for a model type definition are the same as for Java type
definitions, except that a model type definition is not in scope for any
Java code, only for annotations.

[[[Model types are seldom used in JML.  Since the runtime assertion
checker doesn't work with them, I wonder if it would be best to get
rid of them completely.  You could always just define a Java type,
which would be useful for runtime assertion checking.]]]

[[[ May a model type definition appear in more than one specification file
of a refinement sequence, with any member declarations being combined 
together?  I'd prefer that it only be allowed to appear once and be required
to be completely defined in one spec file - easier for tools.  -- DRCok ]]]

[[[Need to explain the math modifiers.]]]

@node Modifiers,  , Class and Interface Definitions, Type Definitions
@comment  node-name,  next,  previous,  up
@section Modifiers

@cindex modifier, general description of
The following is the syntax of modifiers.

@cindex @var{modifiers}, defined
@cindex @var{modifier}, defined
@cindex @var{jml-modifier}, defined
@cindex @var{modifier}, used
@cindex @var{jml-modifier}, used
@kindex @code{public}
@kindex @code{private}
@kindex @code{protected}
@kindex @code{abstract}
@kindex @code{static}
@kindex @code{final}
@kindex @code{synchronized}
@kindex @code{transient}
@kindex @code{volatile}
@kindex @code{native}
@kindex @code{strictfp}
@kindex @code{const}
@kindex @code{spec_public} 
@kindex @code{spec_protected}
@kindex @code{model} 
@kindex @code{ghost} 
@kindex @code{pure}
@kindex @code{instance} 
@kindex @code{helper}
@kindex @code{monitored} 
@kindex @code{uninitialized}
@kindex @code{non_null}
@kindex @code{nullable}
@kindex @code{nullable_by_default}
@kindex @code{extract}
@kindex @code{spec_java_math} 
@kindex @code{spec_safe_math} 
@kindex @code{spec_bigint_math}
@kindex @code{code_java_math} 
@kindex @code{code_safe_math} 
@kindex @code{code_bigint_math}
@display
@var{modifiers} ::= [ @var{modifier} ] @dots{}
@var{modifier} ::= @code{public} | @code{protected} | @code{private}
        | @code{abstract} | @code{static} |
        | @code{final} | @code{synchronized}
        | @code{transient} | @code{volatile}
        | @code{native} | @code{strictfp}
        | @code{const}             @i{// reserved but not used in Java}
        | @var{jml-modifier}
@var{jml-modifier} ::= @code{spec_public} | @code{spec_protected}
        | @code{model} | @code{ghost} | @code{pure}
        | @code{instance} | @code{helper}
        | @code{uninitialized}
        | @code{spec_java_math} | @code{spec_safe_math} | @code{spec_bigint_math}
        | @code{code_java_math} | @code{code_safe_math} | @code{code_bigint_math}
        | @code{non_null} | @code{nullable} | @code{nullable_by_default}
        | @code{extract}
@end display

The @var{jml-modifiers} are only recognized as keywords in
annotation comments.  @xref{Lexical Conventions}, for more details.

@cindex Java modifiers
@cindex modifiers, Java
@cindex Gosling
The Java modifiers have the same meaning as in Java [Gosling-etal00].

Note that although
the @var{modifiers} grammar non-terminal is used in many places throughout
the grammar, not all modifiers can be used
with every grammar construct.  See the discussion regarding each grammar
construct, which is summarized in @ref{Modifier Summary}.

In the following we first discuss the suggested ordering of modifiers
The rest of this section discusses the JML-specific modifiers in
general terms.  Their use and meaning for each kind of grammatical
construct should be consulted directly for more details.

@menu
* Suggested Modifier Ordering::  
* Spec Public::                 
* Spec Protected::              
* Pure::                        
* Model::                       
* Ghost::                       
* Instance::                    
* Helper::                      
* Monitored::                   
* Uninitialized::               
* Math Modifiers::              
* Nullity Modifiers::           
@end menu

@node Suggested Modifier Ordering, Spec Public, Modifiers, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Suggested Modifier Ordering

@cindex modifier ordering, suggested
There are various guidelines for ordering modifiers in Java [[[citations?]]].
As JML has several extra modifiers, we also suggest an ordering;
although this ordering is not enforced, various tools may give
warnings if the suggestions are not followed, as following a standard
ordering tends to make reading declarations easier.
For use in JML, we suggest the following ordering groups, where the
ones at the top should appear first (leftmost), and the ones at the
bottom should appear last (rightmost).  In each line, the modifiers
are either mutually exclusive, or their order does not matter (or both).

@c Check the file ../../org/jmlspecs/checker/Constants.java for the ordering.
@c [[[Is the table below too strict?]]]

@example
  public private protected spec_public spec_protected
  abstract static
  model ghost pure
  final synchronized
  instance helper
  transient volatile
  native strictfp
  monitored uninitialized
  spec_java_math spec_safe_math spec_bigint_math
  code_java_math code_safe_math code_bigint_math
  non_null nullable nullable_by_default
  code extract
  peer rep readonly
@end example

@node Spec Public, Spec Protected, Suggested Modifier Ordering, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Spec Public

@kindex @code{spec_public}
The @code{spec_public} modifier allows one to declare a feature as public
for specification purposes.  It can only be used when the feature has
a more restrictive visibility in Java.  A @code{spec_public} field is
also implicitly a data group.

@node Spec Protected, Pure, Spec Public, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Spec Protected

@kindex @code{spec_protected}
The @code{spec_protected} modifier allows one to declare a feature as protected
for specification purposes.  It can only be used when the feature has
a more restrictive visibility in Java.  That is, it can only be used
to change the visibility of a field or method that is, for Java,
either declared @code{private} or default access (package visible).
  A @code{spec_protected} field is
also implicitly a data group.

@node Pure, Model, Spec Protected, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Pure

@kindex @code{pure}
@cindex modifier, pure
In general terms, a @dfn{pure} feature is one that has no side effects when
executed.  In essence @code{pure} only applies to methods and
constructors.  The use of @code{pure} for a type definition is
shorthand for applying that modifier to all constructors and instance
methods in the type (@pxref{Modifiers for Type Definitions}).

@xref{Pure Methods and Constructors}, for the exact semantics of pure
methods and constructors.

@node Model, Ghost, Pure, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Model

@kindex @code{model}
The @code{model} modifier introduces a specification-only feature.  For
fields it also has a special meaning, which is that the field can be
represented by concrete fields.  @xref{Model and Ghost}.

@cindex @code{model} vs. @code{ghost}
The modifiers @code{model} and @code{ghost} are mutually exclusive.

@cindex @code{model} and @code{final}
@cindex @code{final} and @code{model}
A @code{model} field may not be declared to be @code{final}.  This is
because model fields are abstractions of concrete fields,
and thus it would complicate JML to allow final model fields.
If you feel that you want a final model field, what you should use
instead is a final ghost field. @xref{Ghost}. 

@cindex model fields, in interfaces
@cindex interfaces, and model fields
@cindex model and static, in interfaces
@cindex interfaces, and default modifier for fields
Note that in an interface, a model field is implicitly declared
to be @code{static}.  Thus if you want an instance field, you should use the
modifier @code{instance}, so that the field will act as if it were a
member of all objects whose type is a subtype of that interface.
Conversely, in a class, a model field is implicitly declared to be
@code{instance}.  Thus, if you want a static field, you should use the
modifier @code{static}, so that the value of the model field is
shared by all instances of the class and its subclasses.

@node Ghost, Instance, Model, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Ghost

@kindex @code{ghost}
The @code{ghost} modifier introduces a specification-only field that
is maintained by special set statements.  @xref{Model and Ghost}.

@cindex @code{ghost} vs. @code{model}
The modifiers @code{ghost} and @code{model} are mutually exclusive.

A ghost field declared in an interface is not @code{final} by
default.  If you want a final @code{ghost} field in an interface, you
must declare it to be @code{final} explicitly.  Ghost fields in
classes are also not final by default.

@cindex ghost fields, in interfaces
@cindex interfaces, and ghost fields
@cindex ghost and static, in interfaces
@cindex interfaces, and default modifier for fields
In an interface, a ghost field is implicitly declared
to be @code{static}.  Thus if you want an instance field, you should use the
modifier @code{instance}, so that the field will act as if it were a
member of all objects whose type is a subtype of that interface.
Conversely, in a class, a ghost field is implicitly declared to be
@code{instance}.  Thus, if you want a static field, you should use the
modifier @code{static}, so that the value of the ghost field is
shared by all instances of the class and its subclasses.

@node Instance, Helper, Ghost, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Instance

@kindex @code{instance}
The @code{instance} modifier says that a field is not static.
@xref{Instance vs. Static}.

@node Helper, Monitored, Instance, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Helper

@kindex @code{helper}
The @code{helper} modifier may be used on a private method or
constructor to say that its
specification is not augmented by invariants and history constraints
that would otherwise be relevant.  Normally, an invariant applies to
all methods in a class or interface.  However, an exception is made
for methods and constructors declared with the @code{helper} modifier.
@xref{Invariants}.   [[[ Just on private? or just on non-overridable
methods? or just on non-overridden methods? - DRC]]]

@node Monitored, Uninitialized, Helper, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Monitored

@kindex @code{monitored}
@cindex Leino
@cindex Nelson
@cindex Saxe
The @code{monitored} modifier may be used on a non-model field
declaration to say that a thread must hold the lock on the object that
contains the field (i.e., the @code{this} object containing the field)
before it may read or write the field [Leino-Nelson-Saxe00].

@node Uninitialized, Math Modifiers, Monitored, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Uninitialized

@kindex @code{uninitialized}
@cindex Leino
@cindex Nelson
@cindex Saxe
The @code{uninitialized} modifier may be used on a field 
declaration to say that despite the initializer, the location declared
is to be considered uninitialized.  Thus, the field should
be assigned in each path before it is read.
[Leino-Nelson-Saxe00].

@node Math Modifiers, Nullity Modifiers, Uninitialized, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Math Modifiers

[[[Need explanation of these.]]]

@node Nullity Modifiers,  , Math Modifiers, Modifiers
@comment  node-name,  next,  previous,  up
@subsection Nullity Modifiers

@kindex @code{non_null}
@kindex @code{nullable}
@kindex @code{nullable_by_default}
Any declaration (other than that of a local variable)
whose type is a reference type
is implicitly declared @code{non_null} unless (explicitly or implicitly)
declared @code{nullable}. Hence reference type declarations are
assumed to be non-null by default (@pxref{Null is Not the Default}).

@cindex explicitly nullable
@cindex nullable, explicitly
A declaration can be @dfn{explicitly} declared @code{nullable} by annotating
it with the @code{nullable} modifier.
@cindex implicitly nullable
@cindex nullable, implicitly
A declaration is @dfn{implicitly} declared @code{nullable} when the (outer
most) class or interface containing the declaration is adorned by the 
class-level modifier @code{nullable_by_default}.

Attempting to use both the @code{non_null} and @code{nullable}
modifiers is a compile time error.

@c -------- chapter Field Declarations ---------------
@node Class and Interface Member Declarations, Type Specifications, Type Definitions, Top
@comment  node-name,  next,  previous,  up
@chapter Class and Interface Member Declarations

The nonterminal @var{field} describes all the members of classes and
interfaces (@pxref{Class and Interface Definitions}).

@c I've tried to make this more understandable for the human reader,
@c the cost is that it's not easy to make a correspondence with the
@c parser generator input. -- Gary

@cindex @var{field}, defined
@cindex @var{member-decl}, used
@cindex @var{jml-declaration}, used
@cindex @var{class-initializer-decl}, used
@kindex @code{;}
@display
@var{field} ::= @var{member-decl}
        | @var{jml-declaration}
        | @var{class-initializer-decl}
        | @code{;}
@end display

Also @pxref{Non-null by Default}.
In the rest of this chapter we describe mostly the syntax and Java
details of member declarations and class initializers.
@xref{Type Specifications}, for the syntax and semantics of
@var{jml-declaration}, and, more generally, how to use JML to specify
the behavior of types.

@menu
* Java Member Declarations::    
* Class Initializer Declarations::  
@end menu

@node Java Member Declarations, Class Initializer Declarations, Class and Interface Member Declarations, Class and Interface Member Declarations
@comment  node-name,  next,  previous,  up
@section Java Member Declarations

The following gives the syntax of Java member declarations.

@cindex @var{member-decl}, defined
@cindex @var{method-decl}, used
@cindex @var{variable-definition}, used
@cindex @var{class-definition}, used
@cindex @var{interface-definition}, used
@display
@var{member-decl} ::= @var{method-decl}
        | @var{variable-definition}
        | @var{class-definition}
        | @var{interface-definition}
@end display

@xref{Class and Interface Definitions}, for details of @var{class-definition}
and @var{interface-definition}.  We discuss method and variable
declarations below.

@menu
* Method and Constructor Declarations::  
* Field and Variable Declarations::  
@end menu

@node Method and Constructor Declarations, Field and Variable Declarations, Java Member Declarations, Java Member Declarations
@comment  node-name,  next,  previous,  up
@subsection Method and Constructor Declarations

The following is the syntax of a method declaration.

@cindex @var{method-decl}, defined
@cindex @var{method-or-constructor-keyword}, defined
@cindex @var{method-head}, defined
@cindex @var{method-body}, defined
@cindex @var{throws-clause}, defined
@cindex @var{doc-comment}, used
@cindex @var{method-specification}, used
@cindex @var{modifiers}, used
@cindex @var{method-or-constructor-keyword}, used
@cindex @var{type-spec}, used
@cindex @var{method-head}, used
@cindex @var{method-body}, used
@cindex @var{ident}, used
@cindex @var{formals}, used
@cindex @var{dims}, used
@cindex @var{throws-clause}, used
@cindex @var{compound-statement}, used
@cindex @var{name}, used
@kindex @code{method}
@kindex @code{constructor}
@kindex @code{;}
@kindex @code{throws}
@kindex @code{,}
@display
@var{method-decl} ::= [ @var{doc-comment} ] @dots{}
                @var{method-specification}
                @var{modifiers} [ @var{method-or-constructor-keyword} ]
                [ @var{type-spec} ] @var{method-head}
                @var{method-body}
        | [ @var{doc-comment} ] @dots{}
          @var{modifiers} @var{method-or-constructor-keyword}
          [ @var{type-spec} ] @var{method-head}
          [ @var{method-specification} ]
          @var{method-body}
@var{method-or-constructor-keyword} ::= @code{method} | @code{constructor}
@var{method-head} ::= @var{ident} @var{formals} [ @var{dims} ] [ @var{throws-clause} ]
@var{method-body} ::= @var{compound-statement} | @code{;}
@var{throws-clause} ::= @code{throws} @var{name} [ @code{,} @var{name} ] @dots{}
@end display

Notice that the specification of a method
(@pxref{Method Specifications}) may appear either before or after the
@var{method-head}. 

@kindex @code{non_null}, in method declaration
@cindex postcondition, via @code{non_null}
The use of @code{non_null} as a @var{modifier} in a @var{method-decl}
really is shorthand for a postcondition describing the normal result
of a method, indicating that it must not be null.   It can also be seen as a
modifier on the method's result type, saying that the type
returned does not contain null.

@kindex @code{extract}, in method declaration
@cindex model program, via @code{extract}
The use of @code{extract} as a @var{modifier} in a @var{method-decl}
is shorthand for writing a model program specification.
@xref{Extracting Model Program Specifications}, for an explanation of
this modifier.

@menu
* Formal Parameters::           
* Model Methods and Constructors::  
* Pure Methods and Constructors::  
* Helper Methods and Constructors::  
@end menu

@node Formal Parameters, Model Methods and Constructors, Method and Constructor Declarations, Method and Constructor Declarations
@comment  node-name,  next,  previous,  up
@subsubsection Formal Parameters

@cindex @var{formals}, defined
@cindex @var{param-declaration-list}, defined
@cindex @var{param-declaration}, defined
@cindex @var{param-modifier}, defined
@cindex @var{param-declaration-list}, used
@cindex @var{param-declaration}, used
@cindex @var{param-modifier}, used
@cindex @var{type-spec}, used
@cindex @var{ident}, used
@cindex @var{dims}, used
@cindex @var{multijava-param-declaration}, used
@kindex @code{(}
@kindex @code{)}
@kindex @code{,} 
@kindex @code{final}
@kindex @code{non_null}
@display
@var{formals} ::= @code{(} [ @var{param-declaration-list} ] @code{)}
@var{param-declaration-list} ::= @var{param-declaration}
                           [ @code{,} @var{param-declaration} ] @dots{}
@var{param-declaration} ::= [ @var{param-modifier} ] @dots{} @var{type-spec} @var{ident} [ @var{dims} ]
        | @var{multijava-param-declaration}   @i{// When MultiJava parsing is on}
@var{param-modifier} ::= @code{final} | @code{non_null} | @code{nullable}
@end display

@xref{Type-Specs}, for more about the nonterminals @var{type-spec} and
@var{dims}. 
@xref{MultiMethods}, for details of @var{multijava-param-declaration}.

@cindex @code{non_null}, parameter modifier
The modifier @code{non_null} when attached to a formal parameter is
shorthand for a precondition that says that the corresponding actual
parameter may not be null.  The type of a parameter that has the
@code{non_null} modifier must be a reference type
[Raghavan-Leavens05].

The @code{non_null} modifier on a parameter is inherited in the same
way as the equivalent precondition would be, so it need not be
declared on every declaration of the same method in a subtype or refinement.
The @code{non_null} modifier may be added to a method in a refinement
file (@pxref{Refinement}), and thus does not have to appear in any
particular file in a refinement sequence.  It can be added to a method
override in a subtype, but that will generally make the method
non-implementable, as the method must also satisfy an inherited
specification without the corresponding precondition.

@c [[[Need a more exact semantics, which should appear in the
@c desugaring TR...]]]

@node Model Methods and Constructors, Pure Methods and Constructors, Formal Parameters, Method and Constructor Declarations
@comment  node-name,  next,  previous,  up
@subsubsection Model Methods and Constructors

@cindex model method
@cindex model constructor
@cindex method, model
@cindex constructor, model
@kindex @code{model}
A method or constructor that uses the modifier @code{model} is called
a @dfn{model method or constructor}. 
Since a model method is not visible to Java code, the entire method,
including its body, should be written in an annotation.

As usual in JML (@pxref{Model and Ghost}), a model method or
constructor is a specification-only feature.
A model method or constructor may have either a body or a
specification, or both.  The specification may be used in various
verification tools, while the body allows it to be executed
during runtime assertion checking.  Model methods may also be
abstract, and both model methods and constructors may be final.

[[[ Can constructors be final?  Why? - DRC ]]]

@cindex model and pure, methods
@cindex pure and model, methods
@cindex model and pure, constructors
@cindex pure and model, constructors
It is usual in JML to declare model methods and constructors as
@code{pure}.  However, it is possible to have a model method or
constructor that is not pure; such methods are useful in model
programs (@pxref{Model Programs}).
On the other hand, aside from their use in model programs, most model
methods only exist to be called in assertions, and since only
pure methods can be called in assertions, they should usually be
declared as @code{pure}.


@node Pure Methods and Constructors, Helper Methods and Constructors, Model Methods and Constructors, Method and Constructor Declarations
@comment  node-name,  next,  previous,  up
@subsubsection Pure Methods and Constructors

@cindex pure method
@cindex method, pure
@cindex Leavens
@cindex Baker
@cindex Ruby
@kindex @code{pure}
This subsubsection, which describes the effect of the @code{pure} modifier
on methods and constructor declarations, is quoted from the preliminary design
document [Leavens-Baker-Ruby06].

We say a method
is @dfn{pure} if it is either specified with
the modifier @code{pure} or is a method that
appears in the specification of a @code{pure} interface or class.
Similarly, a constructor is pure if it is either specified with
the modifier @code{pure} or appears in the specification of a @code{pure}
class.

A @dfn{pure method} that is not a constructor
implicitly has a specification that does not allow any side-effects.
That is, its specification
has the clauses
@example
@group
           diverges false;
           assignable \nothing;
@end group
@end example
@noindent
added to each specification case; if the method has no specification
given explicitly, then these clauses are added as a lightweight specification.
For this reason, if one is writing a pure method, it is not necessary
to otherwise specify an assignable clause
(@pxref{Assignable Clauses}), although doing so may improve the
specification's clarity.

@cindex pure constructor
@cindex constructor, pure
A @dfn{pure constructor} has the clauses
@example
@group
           diverges false;
           assignable this.*;
@end group
@end example
@noindent
added to each specification case; if the constructor has no specification
given explicitly, then these clauses are added as a lightweight specification.
This specification allows the constructor to assign to the non-static
fields of the class in which it appears (including those inherited
from its superclasses and ghost model instance fields from the interfaces
that it implements).

@cindex Salcianu
@cindex Rinard
Implementations of pure methods and constructors
will be checked to see that they meet these conditions on what
locations they can assign to.
To make such checking modular, some JML tools prohibit a pure method
or constructor implementation from calling methods or constructors
that are not pure.  However, more sophisticated tools could more
directly check the intended semantics [Salcianu-Rinard05].

@cindex termination, of pure methods
A pure method or constructor must also be provably terminating.
Although JML does not force users to make such proofs of termination,
users writing pure methods and constructors are supposed to make pure
methods total in the sense that whenever, a pure method is called it either
returns normally or throws some exception.
This is supposed to lessen the possibility that assertion evaluation
could loop forever, aids the runtime assertion checker, which turns
exceptions into arbitrary values of the appropriate result type, and
helps make pure methods more like mathematical functions for
verification purposes.  [[[ I think this has changed - exceptions in a pure
method make the result undefined, not arbitrary - DRC]]]

@cindex pure, implicit verification condition for termination
Furthermore, a pure method is supposed to always either terminate
normally or throw an exception, even for calls that do not satisfy its
precondition.  Static verification
tools for JML should enforce this condition, by requiring a proof
that a pure method implementation satisfies the following
specification
@example
@group
   private behavior
     requires true;
     diverges false;
     assignable \nothing;
@end group
@end example
(and similarly for constructors, except that the assignable clause
becomes @code{assignable this.*;} for constructors).

However, this implicit verification condition is a
specification, and thus cannot be used in reasoning about
calls to the method, even calls from within the class itself and recursive
calls from within the implementation.
For this reason we recommend writing the method or constructor
specification in such a way that the effective precondition of the
method is ``true,'' making the proof of the above implicit verification
condition trivial, and allowing the
termination behavior of the implementation to be relied upon by all clients.

@cindex recursion, and pure methods
Recursion is permitted, both in the implementation of pure methods
and the data structures they manipulate, and in the specifications of
pure methods.
When recursion is used in a specification,
the proof of well-formedness for the specification
involves the use of JML's @code{measured_by} clause.

Since a pure method may not go into an infinite loop,
if it has a non-trivial precondition, it should throw an exception
when its normal precondition is not met.
This exceptional behavior does not have to be specified or programmed
explicitly, but technically there is an obligation to meet the specification
that the method never loops forever.

@cindex purity, and determinism
@cindex deterministic, pure method
Furthermore, a pure method must be deterministic, in
the sense that when called in a given state, it must always return the
same value.  Similarly a pure constructor should be deterministic in
the sense that when called in a given state, it always initializes the
object in the same way.

A pure method can be declared in any class or interface,
and a pure constructor can be declared in any class.
JML will specify the pure methods and constructors
in the standard Java libraries as pure.

@cindex pure interface
As a convenience, instead of writing @code{pure} on each
method declared in a class and interface,
one can use the modifier @code{pure} on classes and
interfaces and classes.
This simply means that each non-static method and each constructor
declared in such a class or interface is @code{pure}.
Note that this does not mean that all methods inherited (but not
declared in and hence not overridden in) the class or interface are
pure.
For example, every class inherits ultimately from
@code{java.lang.Object},
which has some methods, such as @code{notify} and @code{notifyAll}
that are manifestly not pure.
Thus each class will have some methods that are not pure.
Despite this, it is convenient to refer to classes and interfaces declared
with the @code{pure} modifier as @dfn{pure}.

@cindex model methods, vs. pure methods
@cindex pure methods, vs. model methods
In JML the modifiers @code{model} and @code{pure}
are orthogonal.  (Recall something declared with
the modifier @code{model} does not have to be
implemented, and is used purely for specification purposes.)
Therefore, one can have a model method
that is not pure (these might be useful in JML's model programs)
and a pure method that is not a model method.
Nevertheless, usually a model method (or constructor) should be pure,
since there is no way to use non-pure methods in an assertion,
and model methods cannot be used in normal Java code.

@cindex model classes, vs. pure classes
@cindex pure classes, vs. model classes
By the same reasoning, model classes should, in
general, also be pure.
Model classes cannot be used in normal Java code, and hence their
methods are only useful in assertions (and JML's model programs).
Hence it is typical, although not required, that a model class also be
a pure class.

@cindex pure and void methods
@cindex void and pure methods
As can be seen from the semantics,
if a pure method has a return type of @code{void}, then it can
essentially only do nothing.  So, while pure methods
with @code{void} as their return type are not illegal, they are
useless.

@node Helper Methods and Constructors,  , Pure Methods and Constructors, Method and Constructor Declarations
@comment  node-name,  next,  previous,  up
@subsubsection Helper Methods and Constructors

@cindex constructor, helper
@cindex method, helper
@cindex invariant, and helper methods
@cindex invariant, and helper constructors
@kindex @code{helper}
The @code{helper} modifier may only be used on a private method or
constructor.  [[[ This restriction needs to be clarified - ESC/Java limits
helper to non-overridable methods. ]]] Such a helper method or constructor has a
specification that is not augmented by invariants and history constraints
that would otherwise apply to it.  It can thus be thought of as not
really a method or constructor, but merely an abbreviation device.
However, whatever specifications are given explicitly for such a
method or constructor still apply.
@xref{Invariants}, for more details.

@node Field and Variable Declarations,  , Method and Constructor Declarations, Java Member Declarations
@comment  node-name,  next,  previous,  up
@subsection Field and Variable Declarations

The following is the syntax of field and variable declarations.

@cindex @var{variable-definition}, defined
@cindex @var{variable-decls}, defined
@cindex @var{variable-declarators}, defined
@cindex @var{variable-declarator}, defined
@cindex @var{initializer}, defined
@cindex @var{array-initializer}, defined
@cindex @var{initializer-list}, defined
@cindex @var{doc-comment}, used
@cindex @var{modifiers}, used
@cindex @var{variable-decls}, used
@cindex @var{type-spec}, used
@cindex @var{variable-declarators}, used
@cindex @var{jml-data-group-clause}, used
@cindex @var{variable-declarator}, used
@cindex @var{ident}, used
@cindex @var{dims}, used
@cindex @var{initializer}, used
@cindex @var{expression}, used
@cindex @var{array-initializer}, used
@cindex @var{initializer-list}, used
@kindex @code{field}
@kindex @code{;}
@kindex @code{,}
@kindex @code{=}
@kindex @code{@{}
@kindex @code{@}}
@cindex @var{jml-data-group-clause}, used
@display
@var{variable-definition} ::= [ @var{doc-comment} ] @dots{} @var{modifiers} @var{variable-decls}
@var{variable-decls} ::= [ @code{field} ] @var{type-spec} @var{variable-declarators} @code{;}
                   [ @var{jml-data-group-clause} ] @dots{}
@var{variable-declarators} ::= @var{variable-declarator}
                         [ @code{,} @var{variable-declarator} ] @dots{}
@var{variable-declarator} ::= @var{ident} [ @var{dims} ] [ @code{=} @var{initializer} ]
@var{initializer} ::= @var{expression} | @var{array-initializer}
@var{array-initializer} ::= @code{@{} [ @var{initializer-list} ] @code{@}} 
@var{initializer-list} ::= @var{initializer} [ @code{,} @var{initializer} ] @dots{} [ @code{,} ]
@end display

@kindex @code{field}
The @code{field} keyword is not normally needed, but can be used to
change JML's parsing mode.  Within an annotation, such as within a
declaration of a model method, it is sometimes necessary to switch
from JML annotation mode to JML spec-expression mode, in order to
parse words that are JML keywords but should be recognized as Java
identifiers.  This can be accomplished in a field declaration by using
the keyword @code{field}, which changes parsing to spec-expression
mode.  [[[ When does the mode revert back?  e.g. in a method declaration - DRC]]]

[[[Needs example, move elsewhere?]]]

In a non-Java file, such as a file with suffix @file{.refines-java}
(@pxref{Refinement}), one
may omit the initializer of a @var{variable-declarator}, even one
declared to be @code{final}.  In such a file, one may also omit the body
of a @var{method-decl}.  Of course, in a @file{.java} file, one must
obey all the rules of Java for declarations that are not in annotations.

@xref{Data Groups}, for more about @var{jml-data-group-clause}s.
@xref{Specification Expressions}, for the syntax of @var{expression}.
In the following we discuss the modifiers for field and variable
declarations and @var{type-spec}s.

@menu
* JML Modifiers for Fields  ::  
* Type-Specs::                  
@end menu

@node JML Modifiers for Fields  , Type-Specs, Field and Variable Declarations, Field and Variable Declarations
@comment  node-name,  next,  previous,  up
@subsubsection JML Modifiers for Fields

@kindex @code{ghost}
@kindex @code{model}
The @code{ghost} and @code{model} modifiers for fields both say that
the field is a specification-only field; it thus cannot be accessed by
the Java code.  The difference is that a ghost field is explicitly
manipulated by initializations and set statements
(@pxref{Statements and Annotation Statements}),
whereas a model field cannot be explicitly manipulated.  Instead a
model field is indirectly given a value by a represents clause
(@pxref{Represents Clauses}).
@xref{Model and Ghost}, for a general discussion of this distinction in
JML.

While fields can be declared as either model or ghost fields, a field
cannot be both.  Furthermore, local variables cannot be declared with
the @code{model} modifier.

@kindex @code{non_null}
The @code{non_null} modifier in a variable declaration is shorthand
for an invariant saying that each variable declared in the
@var{variable-decls} may not be null.  This invariant has the same
visibility as the visibility declaration of the
@var{variable-definition} itself. @xref{Invariants}, for more about
invariants.

@kindex @code{monitored}
@cindex Leino
@cindex Nelson
@cindex Saxe
The @code{monitored} modifier says that each variable declared in the
@var{variable-decls} can only be accessed by a thread that holds the lock
on the object that contains the field
[Leino-Nelson-Saxe00].
It may not be used with model fields.

@cindex instance vs. static
@cindex instance vs. final, in interfaces
@kindex @code{instance}
The @code{instance} modifier says that the field is to be found in
instances instead of in class objects; it is the opposite of
@code{static}.  It is typically only needed for model or ghost fields
declared in interfaces.  When used in an interface, it makes the field
both non-static and non-final (unless the @code{final} modifier is
used explicitly). 
@xref{Instance vs. Static}.
[[[ So how does one declare a static non-final field in an interface? - DRC ]]]

@node Type-Specs,  , JML Modifiers for Fields  , Field and Variable Declarations
@comment  node-name,  next,  previous,  up
@subsubsection Type-Specs

@cindex type specs, for declarations
@cindex type, specifying in a declaration
The syntax of a @var{type-spec} is as in Java [Gosling-etal00],
except for the addition of the type @code{\TYPE} and the possibility
of using @var{ownership-modifiers}.
The @var{ownership-modifiers} are only available when the Universe
type system is turned on.  @xref{Universe Type System}, for how to do
that, and for the syntax and semantics of @var{ownership-modifiers}.

@cindex @var{type-spec}, defined
@cindex @var{type}, defined
@cindex @var{reference-type}, defined
@cindex @var{dims}, defined
@cindex @var{ownership-modifiers}, used
@cindex @var{type}, used
@cindex @var{reference-type}, used
@cindex @var{dims}, used
@cindex @var{reference-type}, used
@cindex @var{built-in-type}, used
@cindex @var{name}, used
@kindex @code{\TYPE}
@kindex @code{[}
@kindex @code{]}
@display
@var{type-spec} ::= [ @var{ownership-modifiers} ] @var{type} [ @var{dims} ]
         | @code{\TYPE} [ @var{dims} ]
@var{type} ::= @var{reference-type} | @var{built-in-type}
@var{reference-type} ::= @var{name}
@var{dims} ::= `@code{[}' `@code{]}' [ `@code{[}' `@code{]}' ] @dots{}
@end display

@kindex @code{\TYPE}
@cindex @code{java.lang.Class}, and @code{\TYPE}
The type @code{\TYPE} represents the kind of all Java types.  It can
only be used in annotations.  It is equivalent to
@code{java.lang.Class}.

@node Class Initializer Declarations,  , Java Member Declarations, Class and Interface Member Declarations
@comment  node-name,  next,  previous,  up
@section Class Initializer Declarations

The following is the syntax of class initializers.

@cindex @var{class-initializer-decl}, defined
@cindex @var{method-specification}, used
@cindex @var{compound-statement}, used
@cindex @code{static_initializer}, used
@cindex @code{initializer}, used
@kindex @code{static}
@display
@var{class-initializer-decl} ::= [ @var{method-specification} ]
                           [ @code{static} ] @var{compound-statement}
        | @var{method-specification} @code{static_initializer} 
        | @var{method-specification} @code{initializer} 
@end display

The first form above is the form of Java class instance and static
initializers.  The initializer is static, and thus run when the class
is loaded, if it is labeled @code{static}. The effect of the
initializer can be specified by a JML method specification
(@pxref{Method Specifications}), which
treats the initializer as a private helper method with return type
@code{void}, whose body is given by the @var{compound-statement}
(@pxref{Statements and Annotation Statements}).

The last two forms are used in JML to specify static and
instance initializers without giving the body of the initializer.
They would be used in annotations in non-Java files
(@pxref{Refinement}).  At most one of each of these may appear in a type
specification file.  Such a specification is satisfied if there is at
least one corresponding initializer in the implementation, and if
the sequential composition of the bodies of the corresponding
initializer(s), when considered as the body of a private helper method
with return type @code{void}, satisfy the specification given
(@pxref{Method Specifications}).

Note that, due to this semantics, the @var{method-specification}s for
an initializer can only have private specification cases.

[[[ But initializers can be interspersed between field initializations,
which will affect their meaning.  Thus I think the composition has to 
include the field initializations.  The effect is that the post-condition
of the JML initializer refers to the state before a constructor begins
executing; a static_initializer refers to the state after class loading,
I think. -- DRCok ]]] [[[ Is the restriction to private true for static
initialization as well - don't think it should be. - DRCOk ]]]

@c ------- chapter Type Specifications ----------
@node Type Specifications, Method Specifications, Class and Interface Member Declarations, Top
@comment  node-name,  next,  previous,  up
@chapter Type Specifications

This chapter describes the way JML can be used to specify abstract
data types (ADTs).

Overall the mechanisms used in JML to specify ADTs can be described as
follows.  First, the interface of a type is described using the Java
syntax for such a type's declaration
(@pxref{Class and Interface Member Declarations}); this includes any
required fields and methods, along with their types and visibilities,
etc.  Second, the behavior of a type is described by declaring model
and ghost fields to be the client (or subtype) visible abstractions of
the concrete state of the objects of that type, by writing method
specifications using those fields, and by writing various
@var{jml-declaration}s to further refine the logical model defined by
these fields.  These @var{jml-declaration}s can also be used to record
various design and implementation decisions.

The syntax of these @var{jml-declaration}s is as follows.

@cindex @var{jml-declaration}, defined
@cindex @var{modifiers}, used
@cindex @var{invariant}, used
@cindex @var{history-constraint}, used
@cindex @var{represents-clause}, used
@cindex @var{initially-clause}, used
@cindex @var{monitors-for-clause}, used
@cindex @var{readable-if-clause}, used
@cindex @var{writable-if-clause}, used
@cindex @var{axiom-clause}, used
@display
@var{jml-declaration} ::= @var{modifiers} @var{invariant}
        | @var{modifiers} @var{history-constraint}
        | @var{modifiers} @var{represents-clause}
        | @var{modifiers} @var{initially-clause} 
        | @var{modifiers} @var{monitors-for-clause}
        | @var{modifiers} @var{readable-if-clause}
        | @var{modifiers} @var{writable-if-clause}
        | @var{axiom-clause}
@end display

The semantics of each of kind of @var{jml-declaration} is discussed in
the sections below. 
However, before getting to the details,
we start with some introductory examples.

@menu
* Introductory ADT Specification Examples::  
* Invariants::                  
* Constraints::                 
* Represents Clauses::          
* Initially Clauses::           
* Axioms::                      
* Readable If Clauses::         
* Writable If Clauses::         
* Monitors For Clause::         
@end menu

@node Introductory ADT Specification Examples, Invariants, Type Specifications, Type Specifications
@comment  node-name,  next,  previous,  up
@section Introductory ADT Specification Examples

[[[Need examples here, which should be first written into the
org.jmlspecs.samples.jmlrefman package and then included and discussed
here.]]]

@node Invariants, Constraints, Introductory ADT Specification Examples, Type Specifications
@comment  node-name,  next,  previous,  up
@section Invariants 

@c [[[ Most of the following discussion ought to be moved to a subsection 
@c of Fundamental Concepts, and then this section can be shortened to reflect
@c the `reference manual' content regarding invariants - namely the rules 
@c regarding their syntax and semantics.  Besides a lot of the discussion
@c applies to other forms of specs as well.  -- DRCok ]]]

The syntax of an invariant declaration is as follows.

@cindex @var{invariant}, defined
@cindex @var{invariant-keyword}, defined
@cindex @var{invariant-keyword}, used
@cindex @var{predicate}, used
@kindex @code{invariant} 
@kindex @code{invariant_redundantly}
@kindex @code{;}
@display
@var{invariant} ::= @var{invariant-keyword} @var{predicate} @code{;}
@var{invariant-keyword} ::= @code{invariant} | @code{invariant_redundantly}
@end display

An example of an invariant is given below.
The invariant in the example has default (package) visibility,
and says that in every state that is a visible state for an object of
type @code{Invariant}, the object's field @code{b}
is not null and the array it refers to has exactly 6 elements.
In this example, no postcondition is necessary for the constructor
since the invariant is an implicit postcondition for it.

@pindex @code{Invariant}
@example
@include local/Invariant.java.texinfo
@end example

@cindex visible state
@cindex state, visible
@cindex invariant
@cindex constructor, and invariants
@cindex destructor, and invariants
@cindex method calls, and invariants
@kindex @code{helper}
Invariants are properties that have to hold in all visible states.
The notion of visible state is of crucial importance in the explanation of
the semantics of both invariants and constraints.  A state is a
@dfn{visible state} for an object @i{o} if it is the state that occurs
at one of these moments in a program's execution:

@itemize @bullet
@item
at end of a non-helper constructor invocation that is initializing
@i{o},

@item
at the beginning of a non-helper finalizer invocation that is
finalizing @i{o},

@item
at the beginning or end of a non-helper non-static non-finalizer
method invocation with @i{o} as the receiver,

@item
at the beginning or end of a non-helper static method invocation for a
method in @i{o}'s class or some superclass of @i{o}'s class, or

@item
when no constructor, destructor, non-static method invocation with
@i{o} as receiver, or static method invocation for a method in @i{o}'s
class or some superclass of @i{o}'s class is in progress.
@end itemize

@noindent
@kindex @code{helper}
@cindex helper method, and invariants
@cindex helper constructor, and invariants
Note that visible states for an object @i{o} do not include states at
the beginning and end of invocations of @dfn{helpers}: constructors or
methods declared with the @code{helper} modifier
(@pxref{Helper methods and constructors}).
Thus the post-state of a helper constructor and the pre- and
post-states of helper methods are not visible states.

@cindex visible state, for a type
A state is a @dfn{visible state} for a type @i{T} if it occurs after
static initialization for @i{T} is complete and it is a visible state
for some object that has type @i{T}.

@c [[[This only seems right for singly-threaded programs...]]]

@cindex invariant, static
@cindex invariant, instance
@cindex static invariant
@cindex instance invariant
JML distinguishes @dfn{static} and @dfn{instance} invariants.  These are
mutually exclusive and any invariant is either a static or instance
invariant.  An invariant may be explicitly declared to be static or
instance by using one of the modifiers @code{static} or @code{instance}
in the declaration of the invariant.  An invariant declared in a class
declaration is, by default, an instance invariant.  An invariant
declared in an interface declaration is, by default, a static invariant.

For example, the invariant declared in the class @code{Invariant} above
is an instance invariant, because it occurs inside a class declaration.
If @code{Invariant} had been an interface instead of a class, then this
invariant would have been a static invariant.

A static invariant may only refer to static fields of an object.  An
instance invariant, on the other hand, may refer to both static and
non-static fields.

The distinction between static and instance invariants also affects
when the invariants are supposed to hold.  A static invariant declared
in a type @i{T} must hold in every state that is a visible state for
type @i{T}.  An instance invariant declared in a type @i{T} must
hold for every object @i{o} of type @i{T}, for every state that is a
visible state for @i{o}.

@cindex assuming, an invariant
@cindex establishing, an invariant
@cindex preserving, an invariant
@cindex invariant, assuming
@cindex invariant, establishing
@cindex invariant, preserving
For reasoning about invariants we make a distinction between assuming,
establishing, and preserving an invariant.  A method or constructor
@dfn{assumes} an invariant if the invariant must hold in its
pre-state.  A method or constructor @dfn{establishes} an invariant if
the invariant must hold in its post-state.  A method or constructor
@dfn{preserves} an invariant if the invariant is both assumed and
established.

@cindex invariant, enforcement
@cindex invariant, reasoning about
JML's verification logic enforces invariants by making sure that
each non-helper method, constructor, or finalizer:
@itemize @bullet
@item
assumes the static invariants of all types, @i{T}, for which
its pre-state is a visible state for @i{T},

@item
establishes the static invariants of all types, @i{T}, for which
its post-state is a visible state for @i{T},

@item
assumes the instance invariants of all objects, @i{o},
for which its pre-state is a visible state for @i{o}, and

@item
establishes the instance invariants of all objects, @i{o},
for which its post-state is a visible state for @i{o}.
@end itemize

This means that each non-helper constructor found in a class @i{C}
preserves the static invariants of all types, including @i{C}, that
have finished their static initialization, establishes the instance
invariant of the object under construction, and, modulo creation and
deletion of objects, preserves the instance invariants of all other
objects.  (Objects that are created by a constructor must have their
instance invariant established; and objects that are deleted by the
action of the constructor can be assumed to satisfy their instance
invariant in the constructor's pre-state.)  Note in particular that,
at the beginning of a constructor invocation, the instance invariant
of the object being initialized does not have to hold yet.

Furthermore, each non-helper non-static method found in a type @i{T}
preserves the static invariants of all types that have finished their
static initialization, including @i{T}, and, modulo creation and
deletion of objects, preserves the instance invariants of all objects,
in particular the receiver object.
However, finalizers do only assume the instance invariant of the
receiver object, and do not have to establish it on exit.

@cindex Poetzsch-Heffter
@cindex invariants, and modularity
The semantics given above is highly non-modular, but is in general
necessary for the enforcement of invariance when no mechanisms are
available to prevent aliasing problems, or when constructs like
(concrete) public fields are used [Poetzsch-Heffter97].  Of course, one
would like to enforce invariants in a more modular way.  By a modular
enforcement of invariants, we mean that one could verify each type
independently of the types that it does not use, and that a well-formed
program put together from such verified types would still satisfy the
semantics for invariants given above.  That is, each type would be
responsible for the enforcement of the invariants it declares and would
be able to assume, without checking, the invariants of other types it
uses.

@cindex ownership
@cindex alias control
@cindex Noble
@cindex Vitek
@cindex Potter
@cindex M@"ueller
@cindex Poetzsch-Heffter
@cindex Leavens
To accomplish this ideal, it seems that some mechanism for object
ownership and alias control [Noble-Vitek-Potter98]
[Mueller-Poetzsch-Heffter00] [Mueller-Poetzsch-Heffter00a]
[Mueller-Poetzsch-Heffter01a] [Mueller02]
[Mueller-Poetzsch-Heffter-Leavens03] is necessary.  However,
this mechanism is still not a part of JML, although some design work
in this direction has taken place
[Mueller-Poetzsch-Heffter-Leavens06].

On the other hand, people generally assume that there are no object
ownership alias problems; this is perhaps a reasonable strategy for some
tools, like run-time assertion checkers, to take.  The alternative,
tracking which types and objects are in visible states, and checking
every applicable invariant for every type and object in a visible state,
is obviously impractical.

Therefore, assuming or ignoring the problems with object ownership and
alias control, one obtains a simple and more modular way to check
invariants.  This is as follows.
@itemize @bullet
@item
Each non-helper constructor declared in a class @i{C}, must preserve
the static invariant of @i{C}, if @i{C} is finished with its static
initialization, and must establish the instance invariant of the
object being constructed.

@item
Each non-helper non-static non-finalizer method declared in a type @i{T}, must
preserve the static invariant of @i{T}, if @i{T} is finished with its
static initialization, and must preserve the instance invariant of the
receiver object.

@item
Each non-helper static method declared in a type @i{T}, must preserve
the static invariant of @i{T}, if @i{T} is finished with its static
initialization.
@end itemize
@noindent
When doing such proofs, one may assume the static invariant of any
type (that is finished with its static initialization), and one may
also assume the instance invariant of any other object.

In this, more modular, style of checking invariants, one can think of
all the static invariants in a class as being implicitly conjoined to
the pre- and postconditions of all non-helper constructors and
methods, and the instance invariants in a class as being implicitly
conjoined to the postcondition of all non-helper constructors, and to
the pre- and postconditions of all non-helper methods.

@cindex @code{helper}
As noted above, @code{helper} methods and constructors are exempt from
the normal rules for checking invariants.  That is because the
beginning and end of invocations of these @code{helper} methods and
constructors are not visible states, and therefore they do not have to
preserve or establish invariants.  Note that only @code{private}
methods and constructors can be declared as @code{helper}.
@xref{Helper Methods and Constructors}.

The following subsections discuss other points about the semantics of
invariants:
@itemize @bullet
@item
Invariants can be declared @code{static}; 
see @ref{Static vs. instance invariants}.

@item
Invariants can be declared with the access modifiers @code{public},
@code{protected}, and @code{private}, or be left with default access;
see @ref{Access Modifiers for Invariants}.

@item
Invariants should also hold in case a constructor or method terminates
abruptly, by throwing an exception; 
see @ref{Invariants and Exceptions}.

@item 
A class inherits all visible invariants specified in its superclasses
and superinterfaces; see @ref{Invariants and Inheritance}.

@item
Although some aspects of invariants are discussed in isolation here,
the full explanation of their semantics can only be given considered
together with that of method specifications.  After all, a method only
has to preserve invariants when one of the preconditions (i.e.,
@code{requires} clauses) specified for that method holds.  So
invariants are an integral part of the explanation of method
specifications in @ref{Method Specifications}.

@item
When considering an individual method body, remember that invariants
should not just hold in the beginning and the end of it, but also at
any program point halfway where another (non-@code{helper}) method or
constructor is invoked.  After all, these program points are also
visible states, and, as stated above, invariants should hold at all
visible states.

@item
@cindex Poetzsch-Heffter
A method invocation on an object should not just preserve the instance
invariants of that object and the static invariants of the class, but
it should preserve the invariants of all other (reachable) objects as
well [Poetzsch-Heffter97].
@end itemize

It should be noted that the last two points above are not specific to
Java or JML, but these are tricky issues that have to be considered
for any notion of invariant in an object-oriented languages. Indeed,
these two issues make the familiar notion of invariant a lot more
complicated than one might guess at first sight!

@menu
* Static vs. instance invariants::  
* Invariants and Exceptions::   
* Access Modifiers for Invariants::  
* Invariants and Inheritance::  
@end menu

@node Static vs. instance invariants, Invariants and Exceptions, Invariants, Invariants
@comment  node-name,  next,  previous,  up
@subsection Static vs. instance invariants

@cindex static invariant
@cindex instance invariant
@cindex invariant, static vs. instance
@cindex invariant, instance vs. static
@kindex @code{static}
@kindex @code{instance}
@kindex @code{this}
As discussed above (@pxref{Invariants}),
invariants can be declared @code{static} or @code{instance}.
Just like a static method, a static invariant cannot refer to the 
current object @code{this} and thus cannot refer to instance fields of
@code{this} or non-static methods of the type.

Instance invariants must be established by the constructors of an object,
and must be preserved by all non-helper instance methods.
If an object has fields that can be changed without calling methods
(usually a bad idea), then any such changes must also preserve the
invariants.  For example, if an object has a public field, each
assignment to that field must establish all invariants that
might be affected.

Static methods do not have a receiver object for which they need to
assume or establish an instance invariant, since they have no receiver
object.  However, a static method may assume instance invariants of
other objects, such as argument objects passed to the
method.@footnote{Thanks to Peter M@"uller for clarifying this paragraph.}

Static invariants must be established by the static initialization
of a class, and must be preserved by all non-helper constructors and methods, 
i.e., by both static and instance methods.

The table below summarizes this:
@display
@t{          | static          non-helper     non-helper    non-helper}
@t{          | initialization  static method  constructor   instance method}
@t{--------------------------------------------------------------------}
@t{static    | establish       preserve       preserve      preserve   }
@t{invariant |                                                         }
@t{          |                                                         }
@t{instance  | (irrelevant)    (irrelevant)   establish     preserve,   }
@t{invariant |                                              if not a   }
@t{                                                         finalizer}
@end display

@cindex terminology, for invariants
@cindex class invariant, see instance invariant
@cindex object invariant, alternative terms for
@cindex static invariant
@cindex instance invariant
A word of warning about terminology.  As stated above, we call an
invariant about static properties ``static invariants'' and we call an
invariant about the dynamic properties of objects an ``instance
invariant'' or, equivalently, an ``object invariant.''  This terminology
is contrary to the literature but it is more accurate with respect to
the nomenclature of Java.

@node Invariants and Exceptions, Access Modifiers for Invariants, Static vs. instance invariants, Invariants
@comment  node-name,  next,  previous,  up
@subsection Invariants and Exceptions

Methods and constructors should preserve and establish invariants both
in the case of normal termination and in the case of abrupt
termination (i.e., when an exception is thrown).  In other words,
invariants are implicitly included in both normal postconditions,
i.e., @code{ensures} clauses, and in exceptional postconditions, i.e.,
@code{signals} clauses, of methods and constructors.

The requirement that invariants hold after abrupt termination of a
method or constructor may seen excessively strong.  However, it is the
only sound option in the long run.  After all, once an object's
invariant is broken, no guarantees whatsoever can be made about
subsequent method invocations on that object.  When faced with a method
or constructor that may violate an invariant in case it throws an
exception, one will typically try to strengthen the precondition of the
method to rule out this exceptional behavior or try to weaken the
invariant.  Note that a method that does not have any side effects when
it throws an exception automatically preserves all invariants.

@node Access Modifiers for Invariants, Invariants and Inheritance, Invariants and Exceptions, Invariants
@comment  node-name,  next,  previous,  up
@subsection Access Modifiers for Invariants

Invariants can be declared with any one of the Java access modifiers
 @code{private}, @code{protected}, and @code{public}.  Like class
members, invariants declared in a class have @code{package} visibility
if they do not have one of these keywords as modifier.  Similarly,
invariants declared in an interface implicitly have @code{public}
visibility if they do not have one of these keywords as modifier.

The access modifier of an invariant affects which members, i.e. which
fields and which (pure) methods, may be used in it, according to JML's
usual visibility rules.  @xref{Privacy Modifiers and Visibility}, for
the details and an example using invariants.

The access modifiers of invariants do @emph{not} affect the obligations
of methods and constructors to maintain and establish them.  That is,
@emph{all} non-@code{helper} methods are expected to preserve
invariants irrespective of the access modifiers of the invariants and
the methods.  For example, a public method must preserve private
invariants as well as public ones.

[[[
JML's visibility restrictions still allow some highly dubious
invariants.  E.g., a private invariant can refer to a public field,
which, if this public field is not final, means the invariant is not
really enforceable.  Tools should warn about (or forbid??)  invariants
which refer to non-final non-model fields that have a looser access
control than the invariant itself has.
]]]

@node Invariants and Inheritance,  , Access Modifiers for Invariants, Invariants
@comment  node-name,  next,  previous,  up
@subsection Invariants and Inheritance 

Each type inherits all the instance invariants specified
in its superclasses and superinterfaces.
[[[Erik wrote: ``Static invariants are not inherited'', but there seems to
be some kind of static field inheritance in Java...]]]
[[[ DRCok- but all the static invariants of a superclass have to be 
maintained by the subclass methods - isn't this equivalent to inheritance?]]]

The fact that (instance) invariants are inherited is one of the
reasons why the use of the keyword @code{super} is not allowed
in invariants.  [[[ Is this true? - I don't understand this. DRCok ]]]

@node Constraints, Represents Clauses, Invariants, Type Specifications
@comment  node-name,  next,  previous,  up
@section Constraints 

@c [[[ Maybe we should merge the discussion of invariants and
@c constraints? -- Erik
@c I think they have to be separate, but we can try to eliminate
@c duplications. -- Gary
@c There is a lot of discussion in the invariants section that applies
@c to all class-level clauses. -- David ]]]


@cindex constraint
History constraints [Liskov-Wing93b] [Liskov-Wing94], which we call
@dfn{constraints} for short, are related to invariants.  But whereas
invariants are predicates that should hold in all visible states,
history constraints are relationships that should hold for the combination of
each visible state
and any visible state that occurs later in the program's execution.
Constraints can therefore be used to constrain the way that values
change over time.

The syntax of history constraints in JML is as follows.

@cindex @var{history-constraint}, defined
@cindex @var{constraint-keyword}, defined
@cindex @var{constrained-list}, defined
@cindex @var{method-name-list}, defined
@cindex @var{method-name}, defined
@cindex @var{method-ref}, defined
@cindex @var{method-ref-start}, defined
@cindex @var{method-ref-rest}, defined
@cindex @var{param-disambig-list}, defined
@cindex @var{param-disambig}, defined
@cindex @var{constraint-keyword}, used
@cindex @var{predicate}, used
@cindex @var{constrained-list}, used
@cindex @var{method-name-list}, used
@cindex @var{method-name}, used
@cindex @var{method-ref}, used
@cindex @var{param-disambig-list}, used
@cindex @var{method-ref-start}, used
@cindex @var{method-ref-rest}, used
@cindex @var{reference-type}, used
@cindex @var{param-disambig}, used
@cindex @var{type-spec}, used
@cindex @var{ident}, used
@cindex @var{dims}, used
@kindex @code{for}
@kindex @code{;}
@kindex @code{constraint}
@kindex @code{constraint_redundantly}
@kindex @code{\everything}
@kindex @code{,}
@kindex @code{(}
@kindex @code{)}
@kindex @code{.}
@kindex @code{new}
@kindex @code{super}
@kindex @code{this}
@kindex @code{this}
@display
@var{history-constraint} ::= @var{constraint-keyword} @var{predicate}
              [ @code{for} @var{constrained-list} ] @code{;}
@var{constraint-keyword} ::= @code{constraint} | @code{constraint_redundantly}
@var{constrained-list} ::= @var{method-name-list} | @code{\everything}
@var{method-name-list} ::= @var{method-name} [ @code{,} @var{method-name} ] @dots{}
@var{method-name} ::= @var{method-ref} [ @code{(} [ @var{param-disambig-list} ] @code{)} ] | @var{method-ref-start} @code{.} @code{*} 
@var{method-ref} ::= @var{method-ref-start} [ @code{.} @var{method-ref-rest} ] @dots{}
        | @code{new} @var{reference-type}
@var{method-ref-start} ::=  @code{super} | @code{this} | @var{ident}
@var{method-ref-rest} ::=  @code{this} | @var{ident}
@var{param-disambig-list} ::= @var{param-disambig} [ @code{,} @var{param-disambig} ] @dots{}
@var{param-disambig} ::= @var{type-spec} [ @var{ident} [ @var{dims} ] ]
@end display

Because methods will not necessarily change the values referred to in
a constraint, a constraint will generally describe reflexive and transitive
relations.

For example, the constraints in the example below say that the
value of field @code{a} and the length of the array @code{b} will 
never change, and that the length of the array @code{c} will only ever 
increase.
@pindex @code{Constraint}
@example
@include local/Constraint.java.texinfo
@end example
Note that, unlike invariants, constraints can -- and typically do -- 
use the JML keyword @code{\old}.

A constraint declaration may optionally explicitly list one or more methods.  It is
the listed methods that must @dfn{respect} the constraint.  If no methods are listed, then 
all non-helper methods of the class (and any subclasses) must respect the constraint.
A method respects a history constraint iff the
pre-state and the post-state of a non-static method invocation are in
the relation specified by the history constraint.
So one can think of history constraints as being
implicitly included in the postcondition of relevant methods.  However,
history constraints do not apply to constructors and destructors,
since constructors do not have a pre-state and destructors do not have
a post-state.

Private methods declared as @code{helper} methods do not have to 
respect history constraints, just like these do not have to preserve 
invariants.

A few points to note about history constraints:
@itemize @bullet
@item
Constraints can be declared @code{static};
see @ref{Static vs. instance constraints}.

@item
Constraints can be declared with the access modifiers @code{public}, 
@code{protected}, and @code{private};
see @ref{Access Modifiers for Constraints}.

@item
Constraints should also hold if a method terminates abruptly by
throwing an exception.

@item
A class inherits all constraints specified in its superclasses 
and superinterfaces;
see @ref{Constraints and Inheritance}. 

@item
Although some aspects of constraints are discussed in isolation here,
the full explanation of their semantics can only be given considered
together with that of method specifications.  After all, a method only
has to respect constraints when one of the preconditions
(ie. @code{requires} clauses) specified for that method holds.  So
constraints are an integral part of the explanation of method
specifications in @ref{Method Specifications}.

@item
When considering an individual method body, remember that constraints
not only have to hold between the pre-state and the post-state, but
between all visible state that arise during execution of the method.
So, given that any program points in the method where
(non-@code{helper}) methods or constructors are invoked are also
visible states, constraints should also hold between the pre-state and
any such program points, between these program points themselves, and
between any such program points and the post-state.

@item
A method invocation on an object @code{o} should not just respect the
constraints of @code{o}, but should respect the constraints of all
other (reachable) objects as well.
@end itemize

These aspects of constraints are discussed in more detail below.

@menu
* Static vs. instance constraints::  
* Access Modifiers for Constraints::  
* Constraints and Inheritance::  
@end menu

@node Static vs. instance constraints, Access Modifiers for Constraints, Constraints, Constraints
@subsection Static vs. instance constraints 

@cindex static constraint
@cindex instance constraint
@cindex constraint, static vs. instance
@cindex constraint, instance vs. static
@kindex @code{static}
@kindex @code{instance}
@kindex @code{this}
History constraints can be declared @code{static}.
Non-@code{static} constraints are also called @emph{instance} constraints.
Like a static invariant, a static history constraint cannot refer to the 
current object @code{this} or to its fields.

Static constraints should be respected by all constructors and all methods, 
i.e., both static and instance methods.

Instance constraints must be respected by all instance methods.

The table below summarizes this:
@display
@t{          | static          non-helper     non-helper    non-helper}
@t{          | initialization  static method  constructor   instance method}
@t{--------------------------------------------------------------------}
@t{static    | (irrelevant)    respect        respect       respect   }
@t{constraint|                                                         }
@t{          |                                                         }
@t{instance  | (irrelevant)    (irrelevant)   (irrelevant)  respect    }
@t{constraint|                                                         }
@end display

Instance constraints are irrelevant for constructors,
in that here there is no pre-state for a constructor that can be related 
(or not) to the post-state.
However, if a visible state arises during the execution of a constructor,
then any instance constraints have to be respected.

In the same way, and for the same reason, static constraints are irrelevant 
for static initialization.

@node Access Modifiers for Constraints, Constraints and Inheritance, Static vs. instance constraints, Constraints
@subsection Access Modifiers for Constraints

The access modifiers @code{public}, @code{private}, and @code{protected}
pose exactly the same restrictions on constraints as they do on invariants,
see @ref{Access Modifiers for Invariants}.

@node Constraints and Inheritance,  , Access Modifiers for Constraints, Constraints
@comment  node-name,  next,  previous,  up
@subsection Constraints and Inheritance 

Any class inherits all the instance constraints specified
in its superclasses and superinterfaces.
[[[Static constraints are not inherited.]]] [[[ But they still apply to subclasses, no ? and it says they are above - David]]]

The fact that (instance) constraints are inherited is one of the
reasons why the use of the keyword @code{super} is not allowed
in constraints.  [[[ Needs explanation - David ]]]

@node Represents Clauses, Initially Clauses, Constraints, Type Specifications
@comment  node-name,  next,  previous,  up
@section Represents Clauses

@cindex @code{represents}
The following is the syntax for @code{represents} clauses.

@cindex @var{represents-clause}, defined
@cindex @var{represents-keyword}, defined
@cindex @var{l-arrow-or-eq}, defined
@cindex @var{represents-keyword}, used
@cindex @var{l-arrow-or-eq}, used
@cindex @var{store-ref-expression}, used
@cindex @var{spec-expression}, used
@cindex @var{predicate}, used
@kindex @code{;}
@kindex @code{\such_that}
@kindex @code{represents}
@kindex @code{represents_redundantly}
@kindex @code{<-}
@kindex @code{=}
@display
@var{represents-clause} ::= @var{represents-keyword} @var{store-ref-expression}
                    @var{l-arrow-or-eq} @var{spec-expression} @code{;}
        | @var{represents-keyword} @var{store-ref-expression} @code{\such_that}
          @var{predicate} @code{;}
@var{represents-keyword} ::= @code{represents} | @code{represents_redundantly}
@var{l-arrow-or-eq} ::= @code{<-} | @code{=}
@end display

@kindex @code{<-}
@kindex @code{=}
@cindex functional abstraction
The first form of @code{represents} clauses (with @code{<-} or
@code{=}) is called a @dfn{functional abstraction}.  This form
defines the value of the @var{store-ref-expression} in a visible state
as the value of the @var{spec-expression} that follows the 
@var{l-arrow-or-eq}.

@kindex @code{\such_that}
@cindex relational abstraction
The second form (with @code{\such_that}) is called a
@dfn{relational abstraction}.
This form constrains the value of the @var{store-ref-expression} in a
visible state to satisfy the given @var{predicate}.

@itemize @bullet
@item
The left-hand side of a @code{represents} clause must be a reference
to a model field (@xref{Class and Interface Member Declarations}, for details of model fields).  Although it is a @var{store-ref-expression},
wild cards and array ranges are not permitted.

@item
In the functional abstraction form, the type of right-hand side of a
@code{represents clause} must be assignment-compatible to the type of
left-hand side.

@item
In the relational abstraction form, the type of right-hand side of a
@code{represents clause} must be @code{boolean}.
@end itemize

A @code{represents} clause can be declared as @code{static}
(@xref{Type Definitions}, for @code{static} declarations).  In a
@code{static represents} clause, only static elements can be
referenced both in the left-hand side and the right-hand side.  In
addition, the following restriction is enforced:

@itemize @bullet
@item
A @code{static} @code{represents} clause must be declared in the type
where the model field on the left-hand side is declared.
@end itemize

Unless explicitly declared as @code{static}, a @code{represents}
clause is non-@code{static}
(for exceptions see @pxref{Type Definitions}).  
A non-@code{static represents} clause can refer to
both @code{static} and non-@code{static} elements on the right-hand
side.

@itemize @bullet
@item
A non-@code{static represents} clause must not have a static model
field in its left-hand side.

@item
A non-@code{static represents} clause must be declared in a type
descended from (or nested within) the type where the model field on
the left-hand side is declared.
@end itemize

Note that represents clauses can be recursive.  That is, a represents
clause may name a field on its right hand side that is the same as the
field being represented (named on the left hand side).  It is the
specifier's responsibility to make sure such definitions are
well-defined.  But such recursive represents clauses can be useful when
dealing with recursive datatypes [Mueller-Poetzsch-Heffter-Leavens03].


@node Initially Clauses, Axioms, Represents Clauses, Type Specifications
@comment  node-name,  next,  previous,  up
@section Initially Clauses

The @var{initially-clause} has the following syntax.

@cindex @var{initially-clause}, defined
@cindex @var{predicate}, used
@kindex @code{initially}
@kindex @code{;}
@display
@var{initially-clause} ::= @code{initially} @var{predicate} @code{;}
@end display

The meaning is that each non-helper (@pxref{Helper}) constructor for
each concrete subtype of the 
enclosing type (including that type itself, if it is concrete) must
establish the @var{predicate}.  Thus, the predicate can be thought of
as implicitly conjoined to the postconditions of all non-helper constructors.

@node Axioms, Readable If Clauses, Initially Clauses, Type Specifications
@comment  node-name,  next,  previous,  up
@section Axioms

An @var{axiom-clause} has the following syntax.

@cindex @var{axiom-clause}, defined
@cindex @var{predicate}, used
@kindex @code{axiom}
@kindex @code{;}
@display
@var{axiom-clause} ::= @code{axiom} @var{predicate} @code{;}
@end display

Such a clause specifies that a theorem prover should assume that the given
predicate is true (whenever such an assumption is needed).

[[[ example needed ]]]

@node Readable If Clauses, Writable If Clauses, Axioms, Type Specifications
@comment  node-name,  next,  previous,  up
@section Readable If Clauses

The syntax of the @var{readable-if-clause} is as follows.

@cindex @var{readable-if-clause}, defined
@cindex @var{ident}, used
@cindex @var{predicate}, used
@kindex @code{readable}
@kindex @code{if}
@kindex @code{;}
@display
@var{readable-if-clause} ::= @code{readable} @var{ident} @code{if} @var{predicate} @code{;}
@end display

Such a clause gives a condition that must be true before the field
named by @var{ident} can be read.  This field must be one
declared in the type in which the declaration appears,
or in a supertype of the class.

@node Writable If Clauses, Monitors For Clause, Readable If Clauses, Type Specifications
@comment  node-name,  next,  previous,  up
@section Writable If Clauses

The syntax of the @var{writeable-if-clause} is as follows.

@cindex @var{writable-if-clause}, defined
@cindex @var{ident}, used
@cindex @var{predicate}, used
@kindex @code{writable}
@kindex @code{if}
@kindex @code{;}
@display
@var{writable-if-clause} ::= @code{writable} @var{ident} @code{if} @var{predicate} @code{;}
@end display

Such a clause gives a condition that must be true before the field
named by @var{ident} can be written.  This field must be one
declared in the type in which the declaration appears,
or in a supertype of the class.

@node Monitors For Clause,  , Writable If Clauses, Type Specifications
@comment  node-name,  next,  previous,  up
@section Monitors For Clause

The @var{monitors-for-clause} is adapted from ESC/Java
[Leino-Nelson-Saxe00] [Rodriguez-etal05].  It has the
following syntax.

@cindex @var{monitors-for-clause}, defined
@cindex @var{ident}, used
@cindex @var{spec-expression-list}, used
@kindex @var{l-arrow-or-eq}, used
@kindex @code{monitors_for}
@kindex @code{;}
@display
@var{monitors-for-clause} ::= @code{monitors_for} @var{ident}
                        @var{l-arrow-or-eq} @var{spec-expression-list} @code{;}
@end display

A @var{monitors-for-clause} such as @code{monitors_for f <- e1, e2;}
specifies a relationship between the field, @code{f}
and a set of objects, denoted by a specification expression list
@code{e1, e2}.  The meaning of this declaration is
that all of the (non-null) objects in the list, in this
example, the objects denoted by @code{e1} and @code{e2}, must be
locked to read the field (@code{f} in the example) in this object.

Note that the righthand-side of the @var{monitors-for-clause} is not just a
@var{store-ref-list}, but is in fact a @var{spec-expression-list},
where each @var{spec-expression} evaluates to a reference to an
object.

@c ------- chapter Method Specifications ----------------
@node Method Specifications, Data Groups, Type Specifications, Top
@comment  node-name,  next,  previous,  up
@chapter Method Specifications

@cindex method specification
@cindex constructor specification
Although the use of pre- and postconditions for specification of the
behavior of methods is standard, JML offers some features that are
not so standard.  A good example of such a feature is the distinction
between normal and exceptional postconditions (in @code{ensures} and
@code{signals} clauses, respectively), and the specification of frame
conditions using @code{assignable} clauses.  Another example of such a
feature is that JML uses privacy modifiers to allow one to write
different specification that are intended for different readers; for
example, one can write a public specification for clients, a protected
specification for subclasses, and a private specification to record
implementation design decisions.
Yet another such feature is the use of redundancy to allow one to
point out important consequences of a specification for readers
[Tan95] [Leavens-Baker99].

JML provides two constructs for specifying methods and constructors:
@itemize @bullet
@item
pre- and postconditions, and

@item
model programs.

@end itemize

This chapter only discusses the first of these,
which is by far the most common.
Model programs are discussed in @ref{Model Programs}.

@menu
* Basic Concepts in Method Specification::  
* Organization of Method Specifications::  
* Access Control in Specification Cases::  
* Lightweight Specification Cases::  
* Heavyweight Specification Cases::  
* Behavior Specification Cases::  
* Normal Behavior Specification Cases::  
* Exceptional Behavior Specification Cases::  
* Method Specification Clauses::  
@end menu

@node Basic Concepts in Method Specification, Organization of Method Specifications, Method Specifications, Method Specifications
@comment  node-name,  next,  previous,  up
@section Basic Concepts in Method Specification

[[[Discuss the ``client viewpoint'' here and give some basic examples here.]]]

[[[Perhaps discuss other common things to avoid repeating ourselves below...]]]

@node Organization of Method Specifications, Access Control in Specification Cases, Basic Concepts in Method Specification, Method Specifications
@comment  node-name,  next,  previous,  up
@section Organization of Method Specifications

The following gives the syntax of behavioral specifications for methods.
We start with the top-level syntax that organizes these specifications.

@cindex @var{method-specification}, defined
@cindex @var{extending-specification}, defined
@cindex @var{specification}, defined
@cindex @var{spec-case-seq}, defined
@cindex @var{specification}, used
@cindex @var{extending-specification}, used
@cindex @var{spec-case-seq}, used
@cindex @var{redundant-spec}, used
@cindex @var{spec-case}, used
@kindex @code{also}
@display
@var{method-specification} ::= @var{specification} | @var{extending-specification}
@var{extending-specification} ::= @code{also} @var{specification}
@var{specification} ::= @var{spec-case-seq} [ @var{redundant-spec} ]
              | @var{redundant-spec}
@var{spec-case-seq} ::= @var{spec-case} [ @code{also} @var{spec-case} ] @dots{}
@end display

Redundant specifications (@var{redundant-spec}) are discussed
in @ref{Redundancy}.

A
@var{method-specification} of a method in a class or interface @emph{must} start with
the keyword @code{also} if (and only if) 
this method is already declared in the parent
type that the current type extends, in one of the interfaces the class
implements, or in a previous file of the refinement sequence for this type.
Starting a @var{method-specification} with the keyword @code{also} is
intended to tell the reader that this specification is in addition to
some specifications of the method that are given in the superclass of
the class, one of the interfaces it implements, or in another file in the
refinement sequence.  

A @var{method-specification} can include any number of
@var{spec-case}s, joined by the keyword @code{also}, 
as well as a @var{redundant-spec}.  
Aside from the @var{redundant-spec}, each of the @var{spec-case}s
specifies a behavior that must be satisfied by 
a correct implementation of the method or constructor.
That is, whenever a call to the specified method or constructor satisfies
the precondition of one of its @var{spec-case}s,
the rest of the clauses in that @var{spec-case} 
must also be satisfied by the implementation
[Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b]
[Raghavan-Leavens05] [Wills92b] [Wing83].
Model program specification cases, which have no explicit
preconditions, must be satisified by all implementations.

The @var{spec-case}s in a @var{method-specification} can have 
several forms:

@cindex @var{spec-case}, defined
@cindex @var{lightweight-spec-case}, used
@cindex @var{heavyweight-spec-case}, used
@cindex @var{model-program}, used
@display
@var{spec-case} ::= @var{lightweight-spec-case} | @var{heavyweight-spec-case}
        | @var{model-program}
@end display

Model programs are discussed in @ref{Model Programs}. 
The remainder of
this chapter concentrates on lightweight and heavyweight 
behavior specification cases.
JML distinguishes between
@itemize @bullet
@item 
@emph{heavyweight specification cases}, which start with one of the
keywords @code{behavior}, @code{normal_behavior} or
@code{exceptional_behavior}, or one of their British variant spellings
keywords @code{behaviour}, @code{normal_behaviour} or
@code{exceptional_behaviour}
(these are also called behavior, normal
behavior, and exceptional behavior specification cases, respectively),
and

@item 
@emph{lightweight specification cases}, which do not contain one of
these behavior keywords.
@end itemize

A lightweight specification case is similar to a behavior specification
case, but with different defaults [Leavens-Baker-Ruby06].  It also is
possible to desugar all such specification cases into behavior
specification cases [Raghavan-Leavens05].

@node Access Control in Specification Cases, Lightweight Specification Cases, Organization of Method Specifications, Method Specifications
@comment  node-name,  next,  previous,  up
@section Access Control in Specification Cases

@cindex access control, for specification cases
Heavyweight specification cases may be declared with an explicit
access modifier, according to the following syntax.

@cindex @var{privacy}, defined
@kindex @code{public}
@kindex @code{protected}
@kindex @code{private}
@display
@var{privacy} ::= @code{public} | @code{protected} | @code{private}
@end display

The access modifier of a heavyweight specification case 
cannot allow more access than the method being specified.
So a @code{public} method may have a @code{private} behavior specification,
but a @code{private} method may not have a @code{public} public specification.
A heavyweight specification case without an explicit access modifier
is considered to have default (package) access.

Lightweight specification cases have no way to explicitly specify an
access modifier, so their access modifier is implicitly the same
as the method being specified.  For example, a lightweight specification
of a @code{public} method has @code{public} access, implicitly,
but a lightweight specification
of a @code{private} method has @code{private} access, implicitly.
Note that this is a different default than that for heavyweight
specifications, where an omitted access modifier always means package access.

The access modifier of a specification case affects only which annotations
are visible in the specification and does @emph{not} affect
the semantics of a specification case in any other way.

@cindex visibility, in method specifications
JML's usual visibility rules apply to specification cases.
So, for example, a public specification case
may only refer to public members,
a protected specification case may refer to both public and protected members,
as long as the protected members are otherwise accessible according to
Java's rules, etc.
@xref{Privacy Modifiers and Visibility}, for more details and examples.
@c The discussion about visibility has been centralized, see above.

@node Lightweight Specification Cases, Heavyweight Specification Cases, Access Control in Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section Lightweight Specification Cases

@cindex lightweight specification case

@subheading Syntax 

The following is the syntax of lightweight specification cases.
These are the most concise specification cases.

@cindex @var{lightweight-spec-case}, defined
@cindex @var{generic-spec-case}, defined
@cindex @var{generic-spec-body}, defined
@cindex @var{generic-spec-case-seq}, defined
@cindex @var{spec-header}, defined
@cindex @var{simple-spec-body}, defined
@cindex @var{simple-spec-body-clause}, defined
@cindex @var{generic-spec-case}, used
@cindex @var{generic-spec-body}, used
@cindex @var{generic-spec-case-seq}, used
@cindex @var{spec-header}, used
@cindex @var{simple-spec-body}, used
@cindex @var{simple-spec-body-clause}, used
@cindex @var{spec-var-decls}, used
@cindex @var{requires-clause}, used
@cindex @var{diverges-clause}, used
@cindex @var{assignbable-clause}, used
@cindex @var{when-clause}, used
@cindex @var{working-space-clause}, used
@cindex @var{duration-clause}, used
@cindex @var{ensures-clause}, used
@cindex @var{signals-clause}, used
@kindex @code{@{|}
@kindex @code{|@}}
@kindex @code{also}
@display
@var{lightweight-spec-case} ::= @var{generic-spec-case}
@var{generic-spec-case} ::= [ @var{spec-var-decls} ]
                      @var{spec-header}
                      [ @var{generic-spec-body} ]
        | [ @var{spec-var-decls} ]
          @var{generic-spec-body}
@var{generic-spec-body} ::= @var{simple-spec-body}
        | @code{@{|} @var{generic-spec-case-seq} @code{|@}}
@var{generic-spec-case-seq} ::= @var{generic-spec-case}
                          [ @code{also} @var{generic-spec-case} ] @dots{}
@var{spec-header} ::= @var{requires-clause} [ @var{requires-clause} ] @dots{}
@var{simple-spec-body} ::= @var{simple-spec-body-clause}
                     [ @var{simple-spec-body-clause} ] @dots{} 
@var{simple-spec-body-clause} ::= @var{diverges-clause}
        | @var{assignable-clause} | @var{captures-clause} 
        | @var{when-clause} | @var{working-space-clause}
        | @var{duration-clause} | @var{ensures-clause}
        | @var{signals-only-clause} | @var{signals-clause}
@end display
[[[ Is this list missing measured_by, accessible, callable? -- DRC ]]]

As far as the syntax is concerned, the only difference between a
lightweight specification case and a @var{behavior-specification-case}
(@pxref{Behavior Specification Cases}) is that the latter has the
keyword @code{behavior} and possibly an access control modifier.

A lightweight specification case always has the same access modifier as
the method being specified, 
see @ref{Access Control in Specification Cases}.  
To specify a different access control modifier, one must use a
heavyweight specification.

@subheading Semantics 

A lightweight specification case can be understood as syntactic sugar for
a behavior specification case,
except that the defaults for omitted
specification clauses are different for lightweight specification cases
than for behavior specification cases.
So, for example, apart from the class names,
method @code{m} in class @code{Lightweight} below
@pindex @code{Lightweight}
@example
@include local/Lightweight.java.texinfo
@end example
@noindent
has a specification that is equivalent to that
of method @code{m} in class @code{Heavyweight} below.
@pindex @code{Heavyweight}
@example
@include local/Heavyweight.java.texinfo
@end example

@kindex @code{\not_specified}
@cindex defaults, for lightweight specification cases
As this example illustrates, the default for an omitted clause in a
lightweight specification is @code{\not_specified} for all clauses,
except @code{diverges}, which has a default of @code{false}, and
@code{signals} [Leavens-Baker-Ruby06].  The default for an omitted
@code{signals} clause is to only permit the exceptions declared in the
method's header to be thrown.  Thus, if the method declares that
exceptions @code{DE1} and @code{DE2} may be thrown, then the default
for an omitted @code{signals} clause is
@display
  signals (Exception e) e instanceof DE1 || e instanceof DE2;
@end display
@kindex @code{\not_specified}, meaning of
It is intended that the meaning of
@code{\not_specified} may vary between different uses of a JML
specification.  For example, a static checker might treat a
@code{requires} clause that is @code{\not_specified} as if it were
@code{true}, while a verification logic may decide to treat it as if it
were @code{false}.

@cindex omitted specification, meaning of
@cindex method specification, omitted
@cindex constructor, default, specification of
@cindex default constructor, specification of
@cindex overriding method, meaning of omitted specification for
A completely omitted specification is taken to be a lightweight
specification.
If the default (zero-argument) constructor of a class is omitted
because its code is omitted,  then its specification defaults to
an assignable clause that allows all the locations that the
default (zero-argument) constructor of its superclass assigns --- in
essence a copy of the superclass's default constructor's assignable clause.
If some other frame is desired, then one has to write the specification,
or at least the code, explicitly.

@cindex completely omitted specification
@cindex specification, completely omitted
@kindex @code{non_null}
@kindex @code{pure}
A method or constructor with code present has a
@dfn{completely omitted} specification if it has no
@var{specification-case}s and does not use 
annotations like @code{non_null} or @code{pure} that add implicit
specifications.

If a method or constructor has code, has a completely omitted
specification, and does not override another method, then 
its meaning is taken as the lightweight specification
@code{diverges \not_specified;}. 
Thus, its meaning can be read
from the lightweight column of table above, except that the diverges
clause is not given its usual default.
This is done so that the default
specification when no specification is given truly says nothing about
the method's behavior.
However, if a method with code and a completely omitted
specification overrides some other method, then its meaning is taken
to be the lightweight specification @code{also requires false;}.  This somewhat
counter-intuitive specification is the unit under specification
conjunction with @code{also}; it is used so as not to
change the meaning of the inherited specification.

If the code is annotated with keywords like @code{non_null} or
@code{pure} that add implicit specifications, then these implicit
specifications are used instead of the default.  Code with such
annotations is considered to have an implicit specification.


@node Heavyweight Specification Cases, Behavior Specification Cases, Lightweight Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section  Heavyweight Specification Cases

@cindex heavyweight specification case

There are three kinds of heavyweight specification cases, called
behavior, normal behavior, and exceptional behavior specification
cases, beginning (after an optional privacy modifier) with the one of
the keywords @code{behavior}, @code{normal_behavior}, or
@code{exceptional_behavior}, respectively.

@cindex @var{heavyweight-spec-case}, defined
@cindex @var{behavior-spec-case}, used
@cindex @var{exceptional-behavior-spec-case}, used
@cindex @var{normal-behavior-spec-case}, used
@display
@var{heavyweight-spec-case} ::= @var{behavior-spec-case}
        | @var{exceptional-behavior-spec-case}
        | @var{normal-behavior-spec-case}
@end display

Like lightweight specification cases, normal behavior and exceptional
behavior specification cases can be understood as syntactic sugar for
special kinds of @code{behavior} specification cases
[Raghavan-Leavens05].

@node Behavior Specification Cases, Normal Behavior Specification Cases, Heavyweight Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section Behavior Specification Cases

@kindex @code{behavior}
@cindex behavior specification cases, syntax and semantics of
The behavior specification case is the most general form of
specification case.  All other forms of specification cases simply
provide some syntactic sugar for special kinds of @code{behavior}
specification cases.

@subheading Syntax

@cindex British, spelling of behavior
@cindex behavior, British spelling of
As far as the syntax is concerned, the only difference between a
@code{behavior} specification case and a lightweight one is 
the optional access control modifier, @var{privacy},
and the keyword @code{behavior} (or the British variant, @code{behaviour}).
One can use either the British or the American spelling of this
keyword, although for historical reasons most examples will use the
American spelling.

@cindex @var{behavior-spec-case}, defined
@cindex @var{behavior-keyword},  defined
@cindex @var{behavior-keyword}, used
@cindex @var{privacy}, used
@kindex @var{privacy}
@cindex @var{generic-spec-case}, used
@kindex @code{code}
@kindex @code{behavior}
@kindex @code{behaviour}
@display
@var{behavior-spec-case} ::= [ @var{privacy} ] [ @code{code} ] @var{behavior-keyword}
                       @var{generic-spec-case}
@var{behavior-keyword} ::= @code{behavior} | @code{behaviour}
@end display

@xref{Code Contracts}, for details of the semantics of
@var{behavior-spec-case}s that use the @code{code} keyword.

@subheading Semantics 

To explain the semantics of a behavior specification case we make a
distinction between flat and nested specification cases:
@itemize @bullet
@item
@dfn{Flat} specification cases are of the form
@display
 @code{behavior} [ @var{spec-var-decls} ] [ @var{spec-header} ] @var{simple-spec-body} 
@end display
A flat specification case is just made up of a sequence of method
specification clauses, ie. @code{require}, @code{ensures}, etc. clauses,
and its semantics is explained directly in 
@ref{Semantics of flat behavior specification cases}.

@item
@dfn{Nested} specification cases are all other specification cases.
They use the special brackets @code{@{|} and @code{|@}} to nest
specification clauses and possibly also @code{also} inside these
brackets to join several specification cases.

A nested specification case can be syntactically desugared into a list
of one or more simple specification cases, joined by the @code{also}
keyword [Raghavan-Leavens05].  
This is explained in @ref{Semantics of nested behavior specification cases}.
@end itemize

@subheading Invariants and constraints 

The semantics of a behavior specification case for a method or
constructor in a class depends on the invariants and constraints that
have been specified.  This is discussed in @ref{Invariants} and
@ref{Constraints}.  In a nutshell, methods must preserve invariants
and respect constraints, and constructors must establish invariants.

@menu
* Semantics of flat behavior specification cases::  
* Non-helper methods::          
* Non-helper constructors::     
* Helper methods and constructors::  
* Semantics of nested behavior specification cases::  
@end menu

@node Semantics of flat behavior specification cases, Non-helper methods, Behavior Specification Cases, Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Semantics of flat behavior specification cases

Below we explain the semantics of a simple @var{behavior-spec-case}
case with precisely 
one @code{requires} clause,
one @code{diverges} clause,
one @code{measured_by} clause,
one @code{assignable} clause,
one @code{accessible} clause,
one @code{callable} clause,
one @code{when} clause,
one @code{ensures} clause,
one @code{duration} clause,
one @code{working_space} clause,
one @code{signals_only} clause,
and
one @code{signals} clause.

A @code{behavior} specification case can contain any number of these
clauses, and there are defaults that allow any of them to be omitted.
However, as explained in @ref{Method Specification Clauses}, any
@code{behavior} specification case is equivalent with a @code{behavior}
specification case of this form.

@node Non-helper methods, Non-helper constructors, Semantics of flat behavior specification cases, Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Non-helper methods

@kindex @code{behavior}
@kindex @code{forall}
@kindex @code{old}
@kindex @code{requires}
@kindex @code{diverges}
@kindex @code{when}
@kindex @code{accessible}
@kindex @code{assignable}
@kindex @code{callable}
@kindex @code{captures}
@kindex @code{ensures}
@kindex @code{signals_only}
@kindex @code{signals}
@kindex @code{working_space}
@kindex @code{duration}
@kindex @code{measured_by}
@cindex semantics of non-helper method specifications
@cindex non-helper methods, semantics of specifications for
@cindex specifications for non-helper methods, semantics of
Consider a non-@code{helper} instance method @code{m}, and a
specification case of the following form.
@example
  behavior
    forall @i{T1} @i{x1}; @dots{} forall @i{Tn} @i{xn};
    old @i{U1} @i{y1} = @i{F1}; @dots{} old @i{Uk} @i{yk} = @i{Fk};
    requires @i{P};
    measured_by @i{Mbe} @code{if} @i{Mbp};
    diverges @i{D};
    when @i{W};
    accessible @i{R};
    assignable @i{A};
    callable @i{p1}(@dots{}), @dots{}, @i{pl}(@dots{});
    captures @i{Z};
    ensures @i{Q};
    signals_only @i{E1}, @dots{}, @i{Eo};
    signals (@i{E} @i{e}) @i{S};
    working_space @i{Wse} @code{if} @i{Wsp};
    duration @i{De} @code{if} @i{Dp};
@end example

The meaning of this specification case is as follows.

Consider a particular call of the method @i{m}.

@cindex pre-state
@cindex state, pre-state of a call
@cindex call, pre-state of
The state of the program after passing parameters to @i{m}, but before
running any of the code of @i{m} is called the @dfn{pre-state} of the
method call.

Suppose all applicable invariants hold in the pre-state of this call.

@kindex @code{forall}
For every possible value of the variables declared in the
@code{forall} clauses, @i{x1}, @dots{}, @i{xn}, the following must be
true.  (If there are no @code{forall} clauses, then the following just
has to hold all by itself.)

@kindex @code{old}
Suppose that the variable @i{y1} is bound to the pre-state value of
@i{F1} in the pre-state (i.e., the beginning of the method, after
parameter passing), and in turn each of the @code{old} variable
declarations are bound to the values of the corresponding expressions,
also evaluated in the pre-state, and finally @i{yk} is bound to the value
of @i{Fk} in the pre-state.  These bindings can depend on previously
defined @code{old} variable declarations in the specification case.
(If there are no @code{old} clauses, then no such variables are
bound.)
@cindex augmented pre-state
We call the state with such bindings in place the @dfn{augmented pre-state}.

@kindex @code{requires}
Suppose also that with these binding
(i.e., in the augmented pre-state), that the precondition, @i{P}, from
the @code{requires} clause, holds.

If the method has a @code{measured_by} clause,
and if the predicate in the @code{measured_by} clause,
@i{Mbp}, is true in the augmented pre-state, 
and if this call is in the control flow of another instance of this
method, @i{Caller},
then the value of the expression @i{Mbe} in this call's augmented pre-state
must be non-negative and strictly less than the value of
@i{Mbe} in the pre-state of @i{Caller}.
(If the @code{measured_by} clause is omitted, there is no such requirement.)
For example, consider a method @code{fib} that calls itself directly
and has an integer parameter @code{n} and for which the
@code{measured_by} clause has @code{n} as its expression (@i{Mbe}),
and the default predicate (@i{Mbp}) is true;
then recursive calls of @code{fib} that appear in the body of
@code{fib} must have actual argument exprssions whose value is
(non-negative and)
strictly less than @code{n}, such as @code{n-1} and @code{n-2}.@footnote{
Thanks to Jesus Ravelo for correcting the semantics of measured-by clauses.
}

Then one of the following must also hold:
@itemize @bullet
@item
@kindex @code{diverges}
the @code{diverges} predicate, @i{D}, holds in the augmented pre-state
and the execution of the method does not terminate (i.e., it loops
forever or the Java virtual machine exits in such a way that the method call
does not return or throw an exception).  (If the @code{diverges} clause
is omitted, then the default for @i{D} is @code{false}, and hence
these outcomes are effectively prohibited.)
or

@item
@cindex Errors and method semantics
@cindex Java virtual machine error, and method semantics
the Java virtual machine throws an error (i.e., an instance of
@code{java.lang.Throwable} whose type does not inherit from
@code{java.lang.Exception}, usually an instance of @code{java.lang.Error}), or

@item
@cindex post-state
@cindex state, post-state of a call
@cindex call, post-state of
the method terminates by returning or throwing an exception,
reaching a state called its @dfn{post-state},
in which all of the following hold.
@itemize
@item
@cindex commit point
@kindex @code{commit}
@kindex @code{when}
@cindex Rodriguez
The method's execution only reaches its commit point (a label in the
method body with the name ``@code{commit}'' [Rogriguez-etal05]) in a state such
that the @code{when} clause's condition, @i{W}, holds.
(If the condition does not hold,
then the method's execution waits for a concurrent thread to make it
true, and then proceeds.  There is no guarantee that the method will
proceed the first time this condition holds, so the condition may have
to hold many times before the thread may proceed to its commit point.)
(If the @code{when} clause is omitted, there is no need to have a
commit point in the method, and the method need not wait for the
execution of concurrent threads.)

@item
@kindex @code{accessible}
During execution of the method (which includes all directly and
indirectly called methods and constructors),
only locations that either did not exist in the pre-state,
that are local to the method (including the method's formal parameters),
or that are either named in the lists @i{R} and @i{A} found in the 
@code{accessible} and @code{assignable} clauses
or that are dependees (@pxref{Data Groups}) of such locations,
are read from.
The set of locations named by the accessible and assignable clauses
(and hence the elements of their data groups) are computed in the pre-state.
(If the @code{accessible} clause is omitted, it defaults to
@code{accessible \everything;}, which allows all locations to be accessed.)

@item 
@kindex @code{assignable}
During execution of the method,
only locations that either did not exist in the pre-state,
that are local to the method,
or that are either named by the @code{assignable} clause's list, @i{A},
or are dependees (@pxref{Data Groups}) of such locations,
are assigned to.
The set of locations named by the assignable clause (and hence the
elements of their data groups) are computed in the pre-state.
(If the @code{assignable} clause is omitted, it defaults to
@code{assignable \everything;}, which allows all locations to be assigned.)

@item 
@kindex @code{callable}
During execution of the method,
the only methods and constructors called are those listed in the
@code{callable} clause's list @i{p1}, @dots{}, @i{pl}.
(If the @code{callable} clause is omitted, it defaults to
@code{callable \everything;}, which allows all methods and
constructors to be called.)

The form @i{p}@code{.*} refers to all methods of the object denoted by @i{p}.

@item
@kindex @code{captures}
@cindex Boyland
During execution of the method, of the formal parameters whose type is
a reference type, only those listed in the
@code{captures} clause's list, @i{Z}, may be assigned to fields of
some object or to array elements.
(References in formals may freely be assigned to local variables,
however, as these are ``borrowed'' but not captured [Boyland00].
If the @code{captures} clause is omitted, then all such formals may
be assigned freely.)

@item 
@kindex @code{ensures}
If the execution of the method terminates by returning normally,
then the normal postcondition, @i{Q}, given in the @code{ensures}
clause, holds in the post-state.

@item 
@cindex exceptions, and method specification semantics
@cindex method specification semantics, and exceptions
If the execution of the method terminates by throwing an exception of
some type @i{Ea} that is a subtype of @code{java.lang.Exception}, then:
@itemize
@item
@kindex @code{signals_only}
the type @i{Ea} must be a subtype of some type in the list @i{E1},
@dots{}, @i{Eo}, listed in the @code{signals_only} clause (this list
of types has as its default the list in the method's @code{throws}
clause), and 

@item
@kindex @code{signals}
if @i{Ea} is a subtype of the type @i{E} given in the @code{signals}
clause, then the exceptional postcondition @i{R} must hold in the
post-state, augmented by a binding from the variable @i{e} to 
the exception object thrown.
@end itemize

@item
All applicable invariants and history constraints hold in the
post-state.

@item
@kindex @code{working_space}
If the predicate in the @code{working_space} clause,
@i{Wsp}, was true in the augmented pre-state, then
the method execution had available to it the amount of heap space, in bytes,
@i{Wse} [Krone-Ogden-Sitaraman03].
(Note that the expression @i{Wse} may depend on post-state values
so this expression is conceptually evaluated in the post-state,
although it may use @code{\old()} to refer to pre-state values.
If the @code{working_space} clause is omitted, there is no restriction
placed on the maximum space that the method call may during its execution.)

@item
@kindex @code{duration}
If the predicate in the @code{duration} clause,
@i{Dp}, was true in the augmented pre-state, then
the method execution used no more than the number of virtual machine
cycles given by the expression @i{De} [Krone-Ogden-Sitaraman03].
(Note that the expression @i{De} may depend on post-state values
so this expression is conceptually evaluated in the post-state,
although it may use @code{\old()} to refer to pre-state values.
If the @code{duration} clause is omitted, there is no restriction
placed on the maximum number of virtual machine cycles that the call
may use during its execution.)
@end itemize
@end itemize

In all of these clauses, the value of a formal parameter is always
considered to be the value they had in the pre-state.
That is the actual post-state value they take in an execution is not
considered, as explained in @xref{Parameters in Postconditions}.

@node Non-helper constructors, Helper methods and constructors, Non-helper methods, Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Non-helper constructors

The semantics of a flat specification case for a (non-@code{helper}) 
constructor is the same as that for a (non-@code{helper}) method given 
above, except that:
@itemize
@item
any instance invariants of the object being initialized by the
constructor are not assumed to hold in the precondition,

@item
any instance constraints do not have to be established as implicit
part of the postcondition of the constructor.
@end itemize
These two differences are also discussed in @ref{Invariants} 
and @ref{Constraints}.

@node Helper methods and constructors, Semantics of nested behavior specification cases, Non-helper constructors, Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Helper methods and constructors

The semantics of a flat specification case for a helper method 
(or constructor) is the same as that for a non-helper method 
(or constructor) given above,
except that:
@itemize @bullet
@item
the instance invariants for the current object
and the static invariants for the current class
are not assumed to hold in the pre-state, 
and do not have to be established in the post-state.

@item
the instance constraints for current object
and the static constraints for the current class
do not have to be established in the post-state
@end itemize
These differences are also discussed in @ref{Invariants} 
and @ref{Constraints}.

@node Semantics of nested behavior specification cases,  , Helper methods and constructors, Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Semantics of nested behavior specification cases

We now explain how all behavior specification cases can be desugared
into a list of one or more flat specification cases joined by the
@code{also} keyword [Raghavan-Leavens05].  The semantics of a behavior
specification case is then simply the semantics of this desugared
version. 

The desugaring is as follows.  Consider a specification of the form.

@example
@var{spec-var-decls}
@var{spec-header}
@{|
    @var{GenSpecCase1} 
  also 
    @dots{} 
  also 
    @var{GenSpecCasen} 
|@}
@end example

The above desugars to the following.

@example
    @var{spec-var-decls}
    @var{spec-header}
    @var{GenSpecCase1}
  also 
    @dots{} 
  also 
    @var{spec-var-decls}
    @var{spec-header}
    @var{GenSpecCasen}
@end example

In the above desugaring either the @var{spec-var-decls} or the
@var{spec-header} (or both) may be omitted.

The meaning of the desugared list of specification cases is
explained in @ref{Organization of Method Specifications}.
The meaning of a single simple specification case is explained in
@ref{Semantics of flat behavior specification cases}.

@c [[[An EXAMPLE is needed.]]]

@node Normal Behavior Specification Cases, Exceptional Behavior Specification Cases, Behavior Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section Normal Behavior Specification Cases

@cindex @code{normal_behavior}
A @code{normal_behavior} specification case is just syntactic sugar for
a @code{behavior} specification case with an implicit @code{signals}
clause
@example
    signals (java.lang.Exception) false;
@end example
ruling out abrupt termination, i.e., the throwing of any exception.
Note that this includes unchecked exceptions, since in Java,
@code{RuntimeException} is a subclass of @code{Exception}.

The following gives the syntax of the body of a normal behavior
specification case.

@cindex @var{normal-behavior-spec-case}, defined
@cindex @code{normal-behavior-keyword}, defined
@cindex @var{normal-spec-case}, defined
@cindex @code{normal-behavior-keyword}, used
@cindex @var{normal-spec-case}, used
@cindex @var{generic-spec-case}, used
@cindex @var{privacy}, used
@kindex @code{code}
@kindex @code{normal_behavior}
@kindex @code{normal_behaviour}
@display
@var{normal-behavior-spec-case} ::= [ @var{privacy} ] [ @code{code} ] @var{normal-behavior-keyword}
                              @var{normal-spec-case}
@var{normal-behavior-keyword} ::= @code{normal_behavior} | @code{normal_behaviour}
@var{normal-spec-case} ::= @var{generic-spec-case}
@end display

As far as syntax is concerned, the only difference 
between a @var{normal-spec-case} and a @var{generic-spec-case}
is that normal behavior specification cases
cannot include @var{signals-clause}s or @var{signals-only-clause}s.

The semantics of a normal behavior specification case is the same as the
corresponding
@code{behavior} specification case
(@pxref{Behavior Specification Cases})
with the addition of the following
@var{signals-clause}

@example
    signals (java.lang.Exception) false;
@end example

So a normal behavior specification case specifies a precondition which
guarantees normal termination; i.e., it prohibits the method from
throwing an exception.

@node Exceptional Behavior Specification Cases, Method Specification Clauses, Normal Behavior Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section Exceptional Behavior Specification Cases

@kindex @code{exceptional_behavior}
The following gives the syntax of the body of an exceptional behavior
specification case.

@cindex @var{exceptional-behavior-spec-case}, defined
@cindex @var{exceptional-behavior-keyword}, defined
@cindex @var{exceptional-spec-case}, defined
@cindex @var{exceptional-behavior-keyword}, used
@cindex @var{exceptional-spec-case}, used
@cindex @var{generic-spec-case}, used
@cindex @var{privacy}, used
@kindex @code{code}
@kindex @code{exceptional_behavior}
@kindex @code{exceptional_behaviour}
@display
@var{exceptional-behavior-spec-case} ::= [ @var{privacy} ] [ @code{code} ] @code{exceptional-behavior-keyword}
                                   @var{exceptional-spec-case}
@var{exceptional-behavior-keyword} ::= @code{exceptional_behavior} | @code{exceptional_behaviour}
@var{exceptional-spec-case} ::= @var{generic-spec-case}
@end display

As far as syntax is concerned, the only difference 
between an @var{exceptional-spec-case} and a @var{generic-spec-case}
is that exceptional behavior specification cases
cannot include @var{ensures-clause}s.

The semantics of an exceptional behavior specification case is the same
as the corresponding behavior specification case
(@pxref{Behavior Specification Cases})
with the addition of the following
@code{ensures} clause.

@example
    ensures false;
@end example

So an exceptional behavior specification case specifies a precondition
which guarantees that the method throws an exception, if it terminates, i.e., a
precondition which prohibits the method from terminating normally.

@menu
* Pragmatics of Exceptional Behavior Specification Cases::  
@end menu

@node Pragmatics of Exceptional Behavior Specification Cases,  , Exceptional Behavior Specification Cases, Exceptional Behavior Specification Cases
@comment  node-name,  next,  previous,  up
@subsection Pragmatics of Exceptional Behavior Specifications Cases

Note that an exceptional behavior specification case says that some
exception @emph{must} be thrown if its precondition is met (assuming
the diverges clause predicate is @code{false}, as is the default.)
Beware of the difference between specifying that an exception
@emph{must} be thrown and specifying that an exception @emph{may} be
thrown. To specify that an exception @emph{may} be thrown you should
@emph{not} use an exceptional behavior, but should instead use a
behavior specification case [Leavens-Baker-Ruby06].

For example, the following method specification
@pindex @code{InconsistentMethodSpec}
@example
@include local/InconsistentMethodSpec.java.texinfo
@end example
@noindent
is @emph{inconsistent} because the preconditions @code{z <= 99} and
@code{z < 0} overlap, for example when @code{z} is @code{-1}.  When
both preconditions hold then the exceptional behavior case specifies
that an exception @emph{must} be thrown and the normal behavior case
specifies that an exception @emph{must not} be thrown, but the
implementation cannot both throw and not throw an exception.

@kindex @code{signals_only}
Similarly, multiple exceptional specification cases with overlapping 
preconditions may give rise to an inconsistent specification.
For example, the following method specification
@pindex @code{InconsistentMethodSpec2}
@example
@include local/InconsistentMethodSpec2.java.texinfo
@end example
@noindent
is inconsistent because, again, the two preconditions overlap, and the
@code{signals_only} clauses do not permit the same exception to be
thrown in both cases.

@cindex @code{signals} vs. @code{signals_only}
There is an important distinction to be made between the
@code{signals} and the @code{signals_only} clauses in JML.
The @code{signals_only} clause says what exceptions may be thrown
(when the specification case's precondition is met); this clause does
not say anything about the state of the exception object or other
locations in the system.  On the other hand, the @code{signals} clause
only describes what must be true of the system state when an exception
is thrown, and does not say anything about what exceptions may be thrown.
For example, consider the following specification.
@pindex @code{SignalsClause}
@example
@include local/SignalsClause.java.texinfo
@end example
The above allows a method to throw either an @code{IllegalArgumentException} or
a @code{NullPointerException} when @code{x} is less than 0, but in
that condition the method might also throw a different exception
altogether, as long as that exception was permitted by the method's
declaration header.  The only thing ruled out by this specification is
throwing either a @code{IllegalArgumentException} or
a @code{NullPointerException} when @code{x} is not less than 0.
Thus from such a specification one may draw the conclusion that
@code{x < 0} only when one of these two exceptions is thrown.

Therefore, if one just wants to specify the exceptions that are permitted
to be thrown in a specific situation, 
one should use the @code{signals_only} clause.

@node Method Specification Clauses,  , Exceptional Behavior Specification Cases, Method Specifications
@comment  node-name,  next,  previous,  up
@section Method Specification Clauses

The different kinds of clauses that can be used in method
specifications are discussed in this section.  
@xref{Lightweight Specification Cases}, 
for the overall syntax that ties these clauses together.

@menu
* Specification Variable Declarations::  
* Requires Clauses::            
* Ensures Clauses::             
* Signals Clauses::             
* Signals-Only Clauses::        
* Parameters in Postconditions::  
* Diverges Clauses::            
* When Clauses::                
* Assignable Clauses::          
* Accessible Clauses::          
* Callable Clauses::            
* Measured By Clauses::         
* Captures Clauses::            
* Working Space Clauses::       
* Duration Clauses::            
@end menu 

@node Specification Variable Declarations, Requires Clauses, Method Specification Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Specification Variable Declarations

The syntax of @var{spec-var-decls} is as follows.

@cindex @var{spec-var-decls}, defined
@cindex @var{forall-var-decls}, used
@cindex @var{old-var-decls}, used
@display
@var{spec-var-decls} ::= @var{forall-var-decls} [ @var{old-var-decls} ]
        | @var{old-var-decls}
@end display
@noindent
The scope of the variables declared in the @var{spec-var-decls} is the
entire specification case in which they appear.  The two types of such
declarations are described below.

@menu
* Forall Variable Declarations::  
* Old Variable Declarations::   
@end menu

@node Forall Variable Declarations, Old Variable Declarations, Specification Variable Declarations, Specification Variable Declarations
@c  node-name,  next,  previous,  up
@subsubsection Forall Variable Declarations

The syntax of the @var{forall-var-decls} is as follows.

@cindex @var{forall-var-decls}, defined
@cindex @var{forall-var-declarator}, defined
@cindex @var{forall-var-declarator}, used
@cindex @var{quantified-var-declarator}, used
@cindex @var{bound-var-modifiers}, used
@kindex @code{forall}
@display
@var{forall-var-decls} ::= @var{forall-var-declarator} [ @var{forall-var-declarator} ] @dots{} 
@var{forall-var-declarator} ::= @code{forall} [ @var{bound-var-modifiers} ] @var{quantified-var-declarator} @code{;}
@end display

When a @var{forall-var-declarator} is used, it specifies that the
specification case that follows must hold for every possible value of
the declared variables.  In other words, it is a universal
quantification over the specification case.

@c [[[An Example is needed.]]]

Note that if such variables are used in preconditions, then
they can be thought to range over all values that satisfy the preconditions.  The bound variable may not rename earlier bound 
variables in the specification, nor the formal parameters of the
method declaration.

@node Old Variable Declarations,  , Forall Variable Declarations, Specification Variable Declarations
@c  node-name,  next,  previous,  up
@subsubsection Old Variable Declarations

The syntax of the @var{old-var-decls} is as follows.
@xref{Type-Specs}, for the syntax of @var{type-spec}.
[[[Give cross ref for @var{spec-variable-declarators} when ready.]]]

@cindex @var{old-var-decls}, defined
@cindex @var{old-var-declarator}, defined
@cindex @var{old-var-declarator}, used
@cindex @var{type-spec}, used
@cindex @var{spec-variable-declarators}, used
@cindex @var{bound-var-modifiers}, used
@kindex @code{old}
@kindex @code{;}
@display
@var{old-var-decls} ::= @var{old-var-declarator} [ @var{old-var-declarator} ] @dots{}
@var{old-var-declarator} ::= @code{old} [ @var{bound-var-modifiers} ] @var{type-spec} @var{spec-variable-declarators} @code{;}
@end display

An @var{old-var-declarator} allows abbreviation within a specification
case.  The names defined in the @var{spec-variable-declarators} can be
used throughout the specification case for the values of their
initializers.  As the name suggests, the expressions are evaluated in
the method's pre-state.  The bound variable may not rename earlier bound 
variables in the specification, nor the formal parameters of the
method declaration.

[[[Example]]]

@node Requires Clauses, Ensures Clauses, Specification Variable Declarations, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Requires Clauses

@c [[[Let's not always write @code{requires} clause, but usually
@c treat it as an English word ``requires clause'', and only use
@c @code{requires} when we want to emphasize the specific word.
@c Similarly for other clause names.]]]

@cindex precondition
@cindex requires
A requires clause specifies a precondition of
method or constructor.  Its syntax is as follows.

@cindex @var{requires-clause}, defined
@cindex @var{requires-keyword}, defined
@cindex @var{pred-or-not}, defined
@cindex @var{requires-keyword}, used
@cindex @var{pred-or-not}, used
@kindex @code{requires}
@kindex @code{pre}
@kindex @code{requires_redundantly}
@kindex @code{pre_redundantly}
@kindex @code{\not_specified}
@kindex @code{;}
@kindex @code{\same}
@display
@var{requires-clause} ::= @var{requires-keyword} @var{pred-or-not} @code{;}
        | @var{requires-keyword} @code{\same} @code{;}
@var{requires-keyword} ::= @code{requires} | @code{pre} 
        | @code{requires_redundantly} | @code{pre_redundantly}
@var{pred-or-not} ::= @var{predicate} | @code{\not_specified}
@end display

The @var{predicate} in a @code{requires} clause can
refer to any visible fields and to the parameters of the method.
@xref{Privacy Modifiers and Visibility}, for more details on visibility
in JML.

@c [[[I don't think we need this subheading. -- Gary]]]
@c @subheading Semantics

Any number of requires clauses can be included a single 
specification case.
Multiple requires clauses in a specification case
mean the same as a single requires clause whose precondition predicate
is the @emph{conjunction} of these precondition predicates in
the given requires clauses.
For example,
@example
  requires @i{P};
  requires @i{Q};
@end example
@noindent
means the same thing as:
@example
  requires @i{P} && @i{Q};
@end example

@cindex requires clause, omitted
@kindex @code{\not_specified}, for requires clauses
When a requires clause is omitted in a specification case,
a default requires clause is used.
For a lightweight specification case, the default precondition is
@code{\not_specified}.
The default precondition for a heavyweight specification case is
@code{true}.

@cindex @code{\same}, used in a requires clause
At most one precondition in a specification case can use @code{\same},
and @code{\same} cannot be used in the only specification case for a
method unless the method is an override.
Similarly, @code{\same} cannot be used in the only specification case for a
constructor or a static method.
Another restriction is that @code{\same} cannot be used in a requires
clause of a nested specification case
(@pxref{Semantics of nested behavior specification cases}). 

When the precondition is @code{\same} in a specification case,
it means that the specification
case being written has, effectively, the same precondition as that
specified in the other (non-@code{\same}) specification cases.
That is, @code{\same} stands for
the disjunction of the preconditions in all non-@code{\same}
specification cases of the method's specification from the current class
together with the inherited specification cases defined in its supertypes 
(i.e., in its superclasses and implemented interfaces). 

@c [[[Needs example]]]

@node Ensures Clauses, Signals Clauses, Requires Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Ensures Clauses

@cindex ensures
@cindex normal postcondition
@cindex postcondition, normal
An ensures clause specifies a normal postcondition, i.e., a property
that is guaranteed to hold at the end of the method (or constructor)
invocation in the case that this method (or constructor) invocation
returns without throwing an exception.  The syntax is as follows
@xref{Requires Clauses}, for the syntax of @var{pred-or-not}.

@cindex @var{ensures-clause}, defined
@cindex @var{ensures-keyword}, defined
@cindex @var{ensures-keyword}, used
@cindex @var{pred-or-not}, used
@kindex @code{ensures}
@kindex @code{post}
@kindex @code{ensures_redundantly}
@kindex @code{post_redundantly}
@kindex @code{;}
@display
@var{ensures-clause} ::= @var{ensures-keyword} @var{pred-or-not} @code{;}
@var{ensures-keyword} ::= @code{ensures} | @code{post}
        | @code{ensures_redundantly} | @code{post_redundantly}
@end display

A @var{predicate} in an @code{ensures} clause can
refer to any visible fields, the parameters of the method,
@code{\result} if the method is non-void,
and may contain expressions of the form @code{\old(@var{E})}.
@xref{Privacy Modifiers and Visibility}, for more details on visibility
in JML.

@c [[[I don't think we need this subheading. -- Gary]]]
@c @subheading Semantics

Informally,
@example
  ensures @i{Q};
@end example
@noindent
means 
@quotation
if the method invocation terminates normally (ie. without
throwing an exception), then predicate @i{Q} holds in the post-state.
@end quotation

In an ensures clause,
@code{\result} stands for the result that is returned by the method.
The postcondition @i{Q} may contain expressions of 
the form @code{\old(e)}.
Such expressions are evaluated in the pre-state, and not in the post-state,
and allow @i{Q} to express a relation between the pre- and the post-state.
If parameters of the method occur in the postcondition @i{Q},
these are always evaluated in the pre-state, not the post-state.
In other words, if a method parameter @i{x} occurs in  @i{Q},
it is treated as @code{\old(}@i{x}@code{)}.
For a detailed explanation of this see @ref{Parameters in Postconditions}.

Any number of ensures clauses can be given in a single specification
case.
Multiple ensures clauses in a specification case
mean the same as a single ensures clause whose postcondition predicate
is the @emph{conjunction} of the postcondition predicates in the given
ensures clauses.
So 
@example
  ensures @i{P};
  ensures @i{Q};
@end example
means the same as
@example
  ensures @i{P} && @i{Q};
@end example
Note that, in JML's semantics for expressions within assertions, the
order of evaluation of @i{P} and @i{Q} does not matter.
@xref{Expression Evaluation and Undefinedness}, for more details on
this topic.

@cindex ensures clause, omitted
When an ensures clause is omitted in a specification case, a default
ensures clause is used.  For a lightweight specification case, the
default precondition is @code{\not_specified}.  The default
precondition for a heavyweight specification case is @code{true}.

@node Signals Clauses, Signals-Only Clauses, Ensures Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Signals Clauses

@cindex signals
@cindex exceptional postcondition
@cindex postcondition, exceptional
In a specification case a @code{signals} clause specifies the
exceptional or abnormal postcondition, i.e., the property that is
guaranteed to hold at the end of a method (or constructor) invocation
when this method (or constructor) invocation terminates abruptly by
throwing a given exception.

The syntax is as follows.
@xref{Requires Clauses}, for the syntax of @var{pred-or-not}.

@cindex @var{signals-clause}, defined
@cindex @var{signals-keyword}, defined
@cindex @var{signals-keyword}, used
@cindex @var{reference-type}, used
@cindex @var{ident}, used
@cindex @var{pred-or-not}, used
@kindex @code{signals}
@kindex @code{exsures}
@kindex @code{signals_redundantly}
@kindex @code{exsures_redundantly}
@kindex @code{(}
@kindex @code{)}
@kindex @code{;}
@display
@var{signals-clause} ::= @var{signals-keyword} @code{(} @var{reference-type} [ @var{ident} ] @code{)}
                   [ @var{pred-or-not} ] @code{;}
@var{signals-keyword} ::= @code{signals} | @code{signals_redundantly}
        | @code{exsures} | @code{exsures_redundantly}
@end display

In a @var{signals-clause} of the form
@example
  signals (@i{E} @i{e}) @i{P};
@end example
@i{E} has to be a subclass of @code{java.lang.Exception}, and the
variable @i{e} is bound in @i{P}.  If @i{E} is a checked exception
(i.e., if it does not inherit from @code{java.lang.RuntimeException}
[Arnold-Gosling-Holmes00] [Gosling-etal00]), it must either be one of
the exceptions listed in the method or constructor's @code{throws}
clause, or a subclass or a superclass of such a declared exception.

Informally,
@example
  signals (@i{E} @i{e}) @i{P};
@end example
means 
@quotation
If the method (or constructor) invocation terminates abruptly by
throwing an exception of type @i{E}, then predicate @i{P} holds in the
final state for this exception object @i{E}.
@end quotation

A signals clause of the form
@example
  signals (@i{E} @i{e}) @i{R};
@end example
is equivalent to the signals clause 
@example
  signals (java.lang.Exception @i{e}) (@i{e} instanceof @i{E}) ==> @i{R};
@end example

Several signals clauses can be given in a single lightweight, behavior
or exceptional behavior specification case.  Multiple signals clauses
in a specification case mean the same as a single signals clause whose
exceptional postcondition predicate is the @emph{conjunction} of the
exceptional postcondition predicates in the given signals clauses.
This should be understood to take place after the desugaring given
above, which makes all the signals clauses refer to exceptions of type
@code{java.lang.Exception}.  Also, the names in the given signals
clauses have to be standardized [Raghavan-Leavens05].  So for example,
@example
  signals (@i{E1} e) @i{R1};
  signals (@i{E2} e) @i{R2};
@end example
means the same as
@example
  signals (Exception e)   ((e instanceof @i{E1}) ==> @i{R1})
                       && ((e instanceof @i{E2}) ==> @i{R2});
@end example
Note that this means that if an exception is thrown that is both of
type @i{E1} and of type @i{E2}, then both @i{R1} and @i{R2} must hold.

[[[EXAMPLE]]]

Beware that a @code{signals} clause specifies when a certain exception
@emph{may} be thrown, not when a certain exception @emph{must} be
thrown.  To say that an exception must be thrown in some situation,
one has to exclude that situation from other signals clauses and from
ensures clause (and any diverges clauses). It may also be useful to
use the @code{signals_only} clause in such specifications
(@pxref{Signals-Only Clauses}).

[[[EXAMPLE?]]]

@cindex signals clause, omitted
@cindex signals clause, default for
@cindex exsures clause, omitted
@cindex exsures clause, default for
When a behavior or exceptional specification case has no
@var{signals-clause}, a default signals clause is used.  For a
heavyweight specification case, 
the default signals clause is @code{signals (Exception) true;}.
Since normal behavior specification cases do not have signals clauses,
no default applies for such specification cases.
For a lightweight specification case, the default is
@code{signals \not_specified;}.


@node Signals-Only Clauses, Parameters in Postconditions, Signals Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Signals-Only Clauses

@kindex @code{signals_only}
@cindex exceptional postcondition
@cindex postcondition, exceptional
A @code{signals_only} clause is an abbreviation for a
@var{signals-clause} (@pxref{Signals Clauses}) that
specifies what exceptions may be thrown by a method, and thus, implicitly, what
exceptions may @emph{not} be thrown.

The syntax is as follows.

@cindex @var{signals-only-clause}, defined
@cindex @var{signals-only-keyword}, defined
@cindex @var{signals-only-keyword}, used
@cindex @var{reference-type}, used
@kindex @code{signals_only}
@kindex @code{signals_only_redundantly}
@kindex @code{,}
@kindex @code{;}
@kindex @code{\nothing}
@display
@var{signals-only-clause} ::= @var{signals-only-keyword} @var{reference-type} [ @code{,} @var{reference-type} ] @dots{} @code{;}
        | @var{signals-only-keyword} @code{\nothing} @code{;}
@var{signals-only-keyword} ::= @code{signals_only} | @code{signals_only_redundantly}

@end display

All of the @var{reference-type}s named in a @var{signals-only-clause}
must be subtypes of @code{java.lang.Exception}.  Each
@var{reference-type} that is a checked exception type
(i.e., that does not inherit from @code{java.lang.RuntimeException}
[Arnold-Gosling-Holmes00] [Gosling-etal00]), must either be one of
the exceptions listed in the method or constructor's @code{throws}
clause, or a subclass or a superclass of such a declared exception.

A @var{signals-only-clause} of the form
@example
  signals_only @i{E1}, @i{E2}, @dots{}, @i{En};
@end example
is considered to be an abbreviation (syntactic sugar) for
the following @var{signals} clause (@pxref{Signals Clauses}).
@example
  signals (java.lang.Exception e)
           e instanceof @i{E1}
        || e instanceof @i{E2}
        || @dots{}
        || e instanceof @i{En};
@end example
That is, such a clause specifies that if the method or constructor
throws an exception, it must be an instance of one of the types named.

@cindex @var{signals-only-clause}s, multiple
Several @var{signals-only-clause}s can be given in a single
lightweight, behavior or exceptional behavior specification case.
Multiple such clauses 
in a specification case mean the same as a single clause whose
list contains only the names @i{Ej} that are subtypes of some type
named in all of the given @var{signals-only-clause}s.
Thus, the meaning is a kind of intersection of the @code{signals_only}
clauses.  Since this may be confusing, only one
@code{signals_only} clause should ever be used in a given specification case.

@cindex exceptions, specifying when they must be thrown
The @code{signals_only} clause is useful for specifying
when a certain exception, or one of a small set of exceptions, @emph{must} be
thrown.  To say that an exception must be thrown in some situation,
one has to exclude the method from returning normally in that
situation (using an ensures clause or the precondition of some other
specification case) and from not terminating (by using the diverges clause).

[[[Example]]]

@cindex @code{signals_only}, default for
If the @code{signals_only} is omitted from a specification case,
a default @code{signals_only} clause is provided.
The same default is used for both lightweight and heavyweight
behavior and exceptional behavior specification cases.
(Since normal behavior specification cases cannot throw exceptions at all,
there is no default @code{signals_only} clause for such specification cases.)
This default prohibits any exception not declared by the method in
the method's header from being thrown.  Thus the exact default depends on the
method header. If the method header does not list any exceptions that
can be thrown, then the default is @code{signals_only \nothing;}
(which means that the method cannot throw any exceptions).
However, if the method header declares that the method may throw
exceptions @i{DE_1}, @dots{}, @i{DE_n}, @i{Err_1}, @dots{}, @i{Err_m},
where each @i{DE_i} is a subtype of @code{java.lang.Exception}, and
each @i{Err_j} is not a subtype of @code{java.lang.Exception},
then the default 
@code{signals_only} clause is as follows.
@example
   signals_only @i{DE_1}, @dots{}, @i{DE_n}
@end example
@noindent
For example, if the method has the header
@display
   public void foo() throws E1, E2
@end display
then the default @code{signals_only} clause
would be 
@display
   signals_only E1, E2;
@end display

@cindex @code{RuntimeException}, and default signals clause
@cindex default signals clause, and @code{RuntimeException}s
@cindex @code{signals}
@cindex @code{throws}
It is important to note that the set of exceptions included in the default
@code{signals} clause described above never includes
@code{java.lang.Throwable}, and does not include
@code{java.lang.Error} or any of its subtypes.  Furthermore, this
default would not normally include
@code{java.lang.RuntimeException} or any of its subtypes, because Java
explicitly allows RuntimeExceptions to be thrown even if they are not
declared in the method header's @code{throws} clause.
Since such unchecked, runtime exceptions are not usually listed in the
method header, they would not find their way into the default
@code{signals_only} clause.
In JML, however, if you wish to allow such runtime exceptions, you
can either explicitly list them in the method header or, more
usually, you would list them in an explicit @code{signals_only} clause.

@node Parameters in Postconditions, Diverges Clauses, Signals-Only Clauses, Method Specification Clauses
@subsection Parameters in Postconditions

Parameters of methods are passed by value in Java,
meaning that parameters are local variables 
in a method body, which are initialized when the method
is called with the values of the parameters for the invocation.

This leads us to the following two rules:

@itemize @bullet
@item
The parameters of a method or constructor can never be listed in
its assignable clause.

@item
If parameters of a method (or constructor) are used in
a normal or exceptional postcondition for that method (or constructor),
i.e., in an ensures or signals clause,
then these always have their value in the pre-state of the method 
(or constructor),
not the post-state.
In other words, there is an implicit @code{\old()} placed around
any occurrence of a formal parameter in a postcondition.
@end itemize

The justification for the first convention is that clients cannot observe
assignments to the parameters anyway, as these are
local variables that can only be used by the implementation
of the method.
Given that clients can never observe these assignments,
there is no point in making them 
part of the contract between a class and its clients.

The justification for the second convention is that clients only know 
the initial values of the parameter that they supply, 
and do not have any knowledge of the final values
that these variables may have in the post-state.

The reason for this is best illustrated by an example.
Consider the following class and its method specifications.
Without the convention described above 
the implementations given for methods
@code{notCorrect1} and @code{notCorrect2} would satisfy their specifications.
However, clearly neither of these satisfies the specification
when read from the caller's point of view.

@pindex @code{ImplicitOld}
@example
@include local/ImplicitOld.java.texinfo
@end example

The convention above rules out such
pathological implementations as @code{notCorrect1} 
above; because mention of a formal parameter name, such as @code{x} above,
in postconditions always means the pre-state value of that name,
e.g., @code{\old(x)} in the example above.

@node Diverges Clauses, When Clauses, Parameters in Postconditions, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Diverges Clauses

@cindex diverges clause
The diverges clause is a seldom-used feature of JML.  It says when a
method may loop forever or otherwise not return to its caller, by
either throwing an exception or returning normally.  The syntax is as
follows @xref{Requires Clauses}, for the syntax of @var{pred-or-not}.

@cindex @var{diverges-clause}, defined
@cindex @var{diverges-keyword}, defined
@cindex @var{diverges-keyword}, used
@cindex @var{pred-or-not}, used
@kindex @code{diverges_redundantly}
@kindex @code{diverges}
@kindex @code{;}
@display
@var{diverges-clause} ::= @var{diverges-keyword} @var{pred-or-not} @code{;}
@var{diverges-keyword} ::= @code{diverges} | @code{diverges_redundantly}
@end display

@cindex diverges clause, omitted
@cindex partial correctness
@cindex total correctness
When a diverges clause is omitted in a specification case, a default
diverges clause is used.  For both lightweight and heavyweight
specification cases, the 
default diverges condition is @code{false}.
Thus by default, specification cases
give total correctness specifications [Dijkstra76].  Explicitly writing
a diverges clause allows one to obtain a partial correctness
specification [Hoare69].  Being able to specify both total and partial
correctness specification cases for a method leads to additional power
[Hesselink92] [Nelson89].

As an example of the use of @code{diverges}, consider the @code{exit}
method in the following class.  (This example is simplified from the
specification of Java's @code{System.exit} method.
This specification says that the method can always be called (the
implicit precondition is @code{true}),
may always not return to the caller (i.e., diverge),
and may never return normally, and
may never throw an exception.
Thus the only thing the method can legally do, aside from causing a JVM
error, is to not return to its caller.

@pindex @code{Diverges}
@example
@include local/Diverges.spec.texinfo
@end example

The diverges clause is also useful to specify things like methods that
are supposed to abort the program when certain conditions occur,
although that isn't really good practice in Java.  In general, it is
most useful for examples like the one given above, when you want to say when
a method cannot return to its caller.

@node When Clauses, Assignable Clauses, Diverges Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection When Clauses

The @code{when} clause allows concurrency aspects of a method or
constructor to be specified [Lerner91] [Rodriguez-etal05].
A caller of a method will be delayed until the condition given in the
@code{when} clause holds.  What is checked is that the method does not
proceed to its commit point, which is the start of execution of
statement with the label @code{commit}, until the given predicate is
true.

The syntax is as follows.
@xref{Requires Clauses}, for the syntax of @var{pred-or-not}.

@cindex @var{when-clause}, defined
@cindex @var{when-keyword}, defined
@cindex @var{when-keyword}, used
@kindex @code{when}
@kindex @code{when_redundantly}
@kindex @code{;}
@display
@var{when-clause} ::= @var{when-keyword} @var{pred-or-not} @code{;}
@var{when-keyword} ::= @code{when} | @code{when_redundantly}
@end display

@cindex when clause, omitted
When a when clause is omitted in a specification case, a default when
clause is used.  For a lightweight specification case, the default
when condition is @code{\not_specified}.  The default when condition
for a heavyweight specification case is @code{true}.

See [Rodriguez-etal05] for more about the @code{when} clause and JML's
plans for support of multithreading.

@c [[[ Need an example of a when clause and how it is used. ]]]

@node Assignable Clauses, Accessible Clauses, When Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Assignable Clauses

@cindex assignable clause
@cindex frame axiom
@cindex axiom, frame
@cindex modifies clause
@cindex modifiable clause
An assignable clause gives a frame axiom for a specification.  It says
that, from the client's point of view, only the locations named, and
locations in the data groups associated with these locations,
can be assigned to during the execution of the method.
The values of all subexpressions used in assignable clauses,
such as @code{i-1} in @code{a[i-1]},
are computed in the pre-state of the method,
because the assignable clause only talks about locations that exist in
the pre-state.

@xref{Data Groups}, for more about specification of data groups.
However, locations that are local to the method (or methods it calls)
and locations that are created during the method's execution are not
subject to this restriction.

The syntax is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}.

@cindex @var{assignable-clause}, defined
@cindex @var{assignable-keyword}, defined
@cindex @var{assignable-keyword}, used
@cindex @var{store-ref-list}, used
@kindex @code{assignable}
@kindex @code{modifies}
@kindex @code{modifiable}
@kindex @code{assignable_redundantly}
@kindex @code{modifies_redundantly}
@kindex @code{modifiable_redundantly}
@kindex @code{;}
@display
@var{assignable-clause} ::= @var{assignable-keyword} @var{store-ref-list} @code{;}
@var{assignable-keyword} ::= @code{assignable} | @code{assignable_redundantly}
        | @code{modifiable} | @code{modifiable_redundantly}
        | @code{modifies} | @code{modifies_redundantly}
@end display

@cindex assignable clause, omitted
@cindex modifiable clause, omitted
@cindex modifies clause, omitted
@cindex frame axiom, omitted
@kindex @code{\everything}
When an assignable clause is omitted in a specification case, a
default assignable clause is used.  This default has a default
@var{store-ref-list}.  For a lightweight specification
case, the default @var{store-ref-list} is
@code{\not_specified}.  The default @var{store-ref-list}
for a heavyweight specification case is @code{\everything}.

@kindex @code{\nothing}
@cindex @code{\nothing}
If one wants the opposite of the default (for a heavyweight
specification case), then one can specify that a method cannot assign to any
locations by writing:
@example
  assignable \nothing;
@end example
Using the modifier @code{pure} on a method achieves the same effect as
specifying @code{assignable \nothing}, but does so for the method's entire
specification as opposed to a single @var{specification-case}.

@cindex assignable clauses, and model fields
Assignable clauses are subject to several restrictive rules in JML.
The first rule has to do with fields of model objects.
Because model objects are abstract 
and do not have a concrete state or concrete fields, the JML typechecker 
does not allow fields of model objects to be listed in the assignable clause; 
that is, such expressions do not specify a set of locations 
(concrete fields) that can be assigned to. Thus expressions 
like @code{f.x} are not allowed in the assignable clause when @code{f} 
is a model field. 

[[[Flesh out other restrictions.  Refer to
[Mueller-Poetzsch-Heffter-Leavens03] for details.]]]

@node Accessible Clauses, Callable Clauses, Assignable Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Accessible Clauses

@cindex accessible clause
The accessible clause is a seldom-used feature of JML.
Together with the @code{assignable} clause (@pxref{Assignable Clauses}), 
it says what (pre-existing) locations a method may
read during its execution.
It has the following syntax.

@cindex @var{accessible-clause}, defined
@cindex @var{accessible-keyword}, defined
@cindex @var{accessible-keyword}, used
@cindex @var{store-ref-list}, used
@cindex @var{store-ref}, used
@cindex @var{store-ref}, used
@kindex @code{accessible}
@kindex @code{accessible_redundantly}
@kindex @code{;}
@kindex @code{,}
@display
@var{accessible-clause} ::= @var{accessible-keyword} @var{store-ref-list} @code{;}
@var{accessible-keyword} ::= @code{accessible} | @code{accessible_redundantly}
@end display

During execution of the method (which includes all directly and
indirectly called methods and constructors),
only locations that either did not exist in the pre-state,
that are local to the method (including the method's formal parameters),
or that are either named in the lists found in the 
@code{accessible} and @code{assignable} clauses
or that are dependees (@pxref{Data Groups}) of such locations,
are read from.
Note that locations that are local to the method (or methods it calls)
and locations that are created during the method's execution are not
subject to this restriction and may be read from freely.

@cindex accessible clause, omitted
@kindex @code{\nothing}
When an accessible clause is omitted in a code contract specification case, a
default accessible clause is used.  
This default has a default @var{store-ref-list} which is  
@code{\everything}.

@xref{Specification for Subtypes}, for more discussion and examples.

@node Callable Clauses, Measured By Clauses, Accessible Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Callable Clauses

@cindex callable clause
The callable clause says what methods may be called, either directly
or indirectly, by the method being specified.  It has the following syntax.

@cindex @var{callable-clause}, defined
@cindex @var{callable-keyword}, defined
@cindex @var{callable-methods-list}, defined
@cindex @var{callable-keyword}, used
@cindex @var{callable-methods-list}, used
@cindex @var{method-name-list}, used
@cindex @var{store-ref-keyword}, used
@kindex @code{;}
@kindex @code{callable}
@kindex @code{callable_redundantly}
@display
@var{callable-clause} ::= @var{callable-keyword} @var{callable-methods-list} @code{;}
@var{callable-keyword} ::= @code{callable} | @code{callable_redundantly}
@var{callable-methods-list} ::= @var{method-name-list} | @var{store-ref-keyword}
@end display

During execution of a method,
the only methods and constructors that may be called are those listed in the
@code{callable} clause's list.

@cindex callable clause, omitted
@kindex @code{\everything}
When a callable clause is omitted in a code contract specification case, a
default callable clause is used.  
This default has a default @var{callable-methods-list} which is  
@code{\everything}.

@xref{Specification for Subtypes}, for more discussion and examples.

@node Measured By Clauses, Captures Clauses, Callable Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Measured By Clauses

@cindex measured by clause
A measured by clause can be used in a termination argument for a
recursive specification.  It has the following syntax.

@cindex @var{measured-clause}, defined
@cindex @var{measured-by-keyword}, defined
@cindex @var{measured-by-keyword}, used
@cindex @var{spec-expression}, used
@cindex @var{predicate}, used
@kindex @code{measured_by}
@kindex @code{measured_by_redundantly}
@kindex @code{if}
@kindex @code{\not_specified}
@kindex @code{;}
@display
@var{measured-clause} ::= @var{measured-by-keyword} @code{\not_specified} @code{;}
        | @var{measured-by-keyword} @var{spec-expression} [ @code{if} @var{predicate} ] @code{;}
@var{measured-by-keyword} ::= @code{measured_by} | @code{measured_by_redundantly}
@end display

The @var{spec-expression} in a measured by clause must have type
@code{int}.

In both lightweight and heavyweight specification cases, an omitted 
measured by clause means the same as a measured by clause of the
following form.
@example
    measured_by \not_specified;
@end example

@node Captures Clauses, Working Space Clauses, Measured By Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Captures Clauses

@cindex captures clause

The captures clause has the following syntax.

@cindex @var{captures-clause}, defined
@cindex @var{captures-keyword}, defined
@cindex @var{captures-keyword}, used
@cindex @var{store-ref-list}, used
@kindex @code{;}
@kindex @code{captures}
@kindex @code{captures_redundantly}
@display
@var{captures-clause} ::= @var{captures-keyword} @var{store-ref-list} @code{;}
@var{captures-keyword} ::= @code{captures} | @code{captures_redundantly}
@end display

The captures clause says that references to the @var{store-ref}s listed can be
retained after the method returns, for example in a field of the
receiver object or in a static field.
Therefore, the captures clause specifies when an object, passed as an 
actual parameter in a method call, may be captured during the call.

An actual parameter object (including the receiver this) is captured if it 
appears on the right-hand side of an assignment statement 
during the call.  
This can also happen indirectly through another method or constructor call 
or by returning the parameter object as the method result (we assume 
the result will be assigned to a field or local variable after the 
call).  

The captures clause is used to prevent certain kinds of representation 
exposure as part of an alias control technique. 
For example, if an object should not be aliased, then   
that object must not be passed to a method that may capture it, 
i.e., may create an alias to it (this includes the receiver). 
Furthermore, objects used as part of the abstract representation of a type
should not be aliased, and thus should not be passed to methods 
that capture it.  
JML tools will eventually prevent such aliasing.

@cindex captures clause, omitted
@kindex @code{\everything}
When a captures clause is omitted in a method specification case, then a
default captures clause is used.  
This default has a default @var{store-ref-list} which is  
@code{\everything}. 
Thus when omitted, a method is allowed to capture any of the actual 
parameter objects or the receiver.

@node Working Space Clauses, Duration Clauses, Captures Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Working Space Clauses

A @var{working-space-clause} can be used to specify the maximum amount
of heap space used by a method, over and above that used by its
callers.  The clause applies only to the particular specification case
it is in, of course
This is adapted from the work of Krone, Ogden, and Sitaraman on
RESOLVE [Krone-Ogden-Sitaraman03].

@cindex @var{working-space-clause}, defined
@cindex @var{working-space-keyword}, defined
@cindex @var{working-space-keyword}, used
@cindex @var{spec-expression}, used
@cindex @var{predicate}, used
@kindex @code{working_space}
@kindex @code{working_space_redundantly}
@kindex @code{if}
@kindex @code{\not_specified}
@kindex @code{;}
@display
@var{working-space-clause} ::= @var{working-space-keyword} @code{\not_specified} @code{;}
        | @var{working-space-keyword} @var{spec-expression} [ @code{if} @var{predicate} ] @code{;}
@var{working-space-keyword} ::= @code{working_space} | @code{working_space_redundantly}
@end display

The @var{spec-expression} in a working space clause must have type
@code{long}.  It is to be understood in units of bytes.

@kindex @code{\old}, in @var{working-space-clause}
@kindex @code{\result}, in @var{working-space-clause}
The @var{spec-expression} in a working space clause may use
@code{\old} and other JML operators appropriate for postconditions.
This is because it is considered to be evaluated in the post-state,
and provides a guarantee of the maximum amount of additional space
used by the call.  In some cases this space may depend on the
@code{\result}, exceptions thrown, or other post-state values.
[[[ There is however no way to identify the exception thrown - DRCok]]]

In both lightweight and heavyweight specification cases, an omitted 
working space clause means the same as a working space clause of the
following form.
@example
    working_space \not_specified;
@end example

@xref{Backslash working space}, for information about the
@code{\working_space} expression that can be used
to describe the working space needed by a
method call.  @xref{Backslash space}, for information about the
@code{\space} expression that can be used
to describe the heap space occupied by an object.

@node Duration Clauses,  , Working Space Clauses, Method Specification Clauses
@c  node-name,  next,  previous,  up
@subsection Duration Clauses

A duration clause can be used to specify the maximum (i.e., worst
case) time needed to process a method call in a particular
specification case.  [[[ Tools are simpler if the argument can simply be an arbitrary expression rather than a method call. -- DRCok ]]]
This is adapted from the work of Krone, Ogden, and Sitaraman on
RESOLVE [Krone-Ogden-Sitaraman03].

@cindex @var{duration-clause}, defined
@cindex @var{duration-keyword}, defined
@cindex @var{duration-keyword}, used
@cindex @var{spec-expression}, used
@cindex @var{predicate}, used
@kindex @code{duration}
@kindex @code{duration_redundantly}
@kindex @code{if}
@kindex @code{\not_specified}
@kindex @code{;}
@display
@var{duration-clause} ::= @var{duration-keyword} @code{\not_specified} @code{;}
        | @var{duration-keyword} @var{spec-expression} [ @code{if} @var{predicate} ] @code{;}
@var{duration-keyword} ::= @code{duration} | @code{duration_redundantly}
@end display

The @var{spec-expression} in a duration clause must have type
@code{long}.  It is to be understood in units of [[[the JVM
instruction that takes the least time to execute, which may be thought
of as the JVM's cycle time.]]]  The time it takes the JVM to execute
such an instruction can be multiplied by the number of such cycles to
arrive at the clock time needed to execute the method in the given
specification case.  [[[This time should also be understood as not
counting garbage collection time.]]]

@kindex @code{\old}, in @var{duration-clause}
@kindex @code{\result}, in @var{duration-clause}
The @var{spec-expression} in a duration clause may use
@code{\old} and other JML operators appropriate for postconditions.
This is because it is considered to be evaluated in the post-state,
and provides a guarantee of the maximum amount of additional space
used by the call.  In some cases this space may depend on the
@code{\result}, exceptions thrown, or other post-state values.
[[[  There is no way to identify the exception thrown -  DRCok]]]

In both lightweight and heavyweight specification cases, an omitted 
duration clause means the same as a duration clause of the
following form.
@example
    duration \not_specified;
@end example

@xref{Backslash duration}, for information about the @code{\duration}
expression that can be used in the duration clause to specify the
duration of other methods.


@c ------- chapter Data Groups ----------------
@node  Data Groups, Predicates and Specification Expressions, Method Specifications, Top
@comment  node-name,  next,  previous,  up
@chapter Data Groups

@cindex data group
@cindex group, data
@cindex location
@cindex information hiding, in assignable clauses
@cindex assignable clauses, and information hiding
A @dfn{data group} is a set of locations; data groups are used in
JML's frame axioms (@pxref{Assignable Clauses}) to name such sets of
locations in a way that does not expose representation details [Leino98].

Each field in a program defines a data group, whose name is the same
as that of the field.

The main purpose for putting locations into data groups is so that
these locations may be assigned during the executions of methods that
have permission to assign to the data group.  For example, if
locations @code{x.f} and @code{x.y} are in data group @code{x.d}, then
an assignable clause of the form

@example
   assignable x.d;
@end example

@noindent
allows @code{x.d}, @code{x.f}, @code{x.y}, and any other locations in
the data group of @code{x.d} to be assigned during the execution of a
method.

One should always put private or protected fields that are used to compute
the value of a public model field (@pxref{Represents Clauses}) into the data
group of that model field.  However, one can also put other fields
into a model field's data group, just to allow them to be assigned
when the model field is assignable.

It is sometimes convenient to declare a data group without any other
information about the model of data.  This can be done using the type
@code{org.jmlspecs.models.JMLDataGroup}. This type has exactly one
non-null object, named @code{JMLDataGroup.IT}.  For example, the class
@code{java.lang.Object} has the following data group declaration.

@example
    //@ public non_null model JMLDataGroup objectState;
@end example

The @code{objectState} data group provides a convenient way to talk
about ``the state'' of an object without committing to any modeling or
representation details.

[[[ needs discussion - default data groups ]]]

To place a field or array element in a data group, one uses the
following syntax.

@cindex @var{jml-data-group-clause}, defined
@cindex @var{in-group-clause}, used
@cindex @var{maps-into-clause}, used
@display
@var{jml-data-group-clause} ::= @var{in-group-clause} | @var{maps-into-clause}
@end display

The details of the two kinds of data group clauses are discussed below.

@menu
* Static Data Group Inclusions::  
* Dynamic Data Group Mappings ::  
@end menu

@node Static Data Group Inclusions, Dynamic Data Group Mappings , Data Groups, Data Groups
@comment  node-name,  next,  previous,  up
@section Static Data Group Inclusions

@cindex @var{in-group-clause}, defined
@cindex @var{in-keyword}, defined
@cindex @var{group-list}, defined
@cindex @var{group-name}, defined
@cindex @var{group-name-prefix}, defined
@cindex @var{in-keyword}, used
@cindex @var{group-list}, used
@cindex @var{group-name}, used
@cindex @var{group-name-prefix}, used
@cindex @var{ident}, used
@kindex @code{;}
@kindex @code{in}
@kindex @code{in_redundantly}
@kindex @code{super}
@kindex @code{this}
@kindex @code{.}
@kindex @code{,}
@display
@var{in-group-clause} ::= @var{in-keyword} @var{group-list} @code{;} 
@var{in-keyword} ::= @code{in} | @code{in_redundantly}
@var{group-list} ::= @var{group-name} [ @code{,} @var{group-name} ] @dots{}
@var{group-name} ::= [ @var{group-name-prefix} ] @var{ident} 
@var{group-name-prefix} ::= @code{super} @code{.} | @code{this} @code{.} 
@end display

The @var{in-group-clause} puts the field being declared in all the
data groups named in the @var{group-list}.

[[[needs discussion]]]

@node Dynamic Data Group Mappings ,  , Static Data Group Inclusions, Data Groups
@comment  node-name,  next,  previous,  up
@section Dynamic Data Group Mappings 

@xref{Store Refs}, for the definition of @var{spec-array-ref-expr}.

@cindex @var{maps-into-clause}, defined
@cindex @var{maps-keyword}, defined
@cindex @var{member-field-ref}, defined
@cindex @var{maps-member-ref-expr}, defined
@cindex @var{maps-array-ref-expr}, defined
@cindex @var{maps-spec-array-dim}, defined
@cindex @var{maps-keyword}, used
@cindex @var{member-field-ref}, used
@cindex @var{maps-into-clause}, used
@cindex @var{maps-array-ref-expr}, used
@cindex @var{maps-member-ref-expr}, used
@cindex @var{group-list}, defined
@cindex @var{group-list}, used
@cindex @var{group-name}, defined
@cindex @var{group-name}, used
@cindex @var{maps-spec-array-dim}, used
@cindex @var{spec-array-ref-expr}, used
@cindex @var{ident}, used
@kindex @code{;}
@kindex @code{\into}
@kindex @code{maps}
@kindex @code{maps_redundantly}
@kindex @code{.}
@kindex @code{*}
@kindex @code{[}
@kindex @code{]}
@display
@var{maps-into-clause} ::= @var{maps-keyword} @var{member-field-ref} @code{\into} @var{group-list} @code{;} 
@var{maps-keyword} ::= @code{maps} | @code{maps_redundantly}
@var{member-field-ref} ::= @var{ident} @code{.} @var{maps-member-ref-expr}
          | @var{maps-array-ref-expr} [ @code{.} @var{maps-member-ref-expr} ]
@var{maps-member-ref-expr} ::= @var{ident} | @code{*} 
@var{maps-array-ref-expr} ::= @var{ident} @var{maps-spec-array-dim}
                        [ @var{maps-spec-array-dim} ] @dots{} 
@var{maps-spec-array-dim} ::= `@code{[}' @var{spec-array-ref-expr} `@code{]}'
@end display

The @var{maps-into-clause} describes elements of a data group that are
determined dynamically, through a field reference or an array index, or
a field of an array index.  The pattern @code{*} may be used to
specify all fields of an object or all elements of an array.

The fields of a model object do not denote locations because model 
objects are abstract and do not have concrete fields.  
Therefore, in JML, the maps clause is not allowed in the declaration of a model 
field because such maps clauses do not denote a specific set of 
locations to be added to a data group, and this is the primary purpose of the 
maps clause (see also the discussion of model fields in the assignable 
clause).  

[[[ needs discussion ]]]

@c ------- chapter Predicates and Specification Expressions ----------------
@node Predicates and Specification Expressions, Statements and Annotation Statements, Data Groups, Top
@comment  node-name,  next,  previous,  up
@chapter Predicates and Specification Expressions

This chapter describes predicates in JML and JML's extensions to
Java's expressions.  It also describes store references, which are
similar to specification expressions, but are used to describe
locations instead of values.  Details are found in the sections below.

@menu
* Predicates::                  
* Specification Expressions::   
* Expressions::                 
* JML Primary Expressions::     
* Set Comprehensions::          
* JML Operators::               
* Store Refs::                  
@end menu

@node Predicates, Specification Expressions, Predicates and Specification Expressions, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section Predicates

@cindex predicate
@cindex expression, boolean-valued
@cindex assertion, expressions for use in
A @dfn{predicate}
The following gives the syntax of predicates, which are simply
@var{spec-expression}s that must have a boolean value.
@xref{Specification Expressions}, for the syntax of specification
expressions. 

@cindex @var{predicate}, defined
@cindex @var{spec-expression}, used
@display
@var{predicate} ::= @var{spec-expression}
@end display

@node Specification Expressions, Expressions, Predicates, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section Specification Expressions

The following gives the syntax of specification expressions in JML.
@xref{Expressions}, for the syntax of @var{expression}.

@cindex @var{spec-expression-list}, defined
@cindex @var{spec-expression}, defined
@cindex @var{spec-expression}, used
@cindex @var{expression}, used
@kindex @code{,}
@display
@var{spec-expression-list} ::= @var{spec-expression}
                         [ @code{,} @var{spec-expression} ] @dots{}
@var{spec-expression} ::= @var{expression} 
@end display

Within a @var{spec-expression}, one cannot use any of the operators
(such as @code{++}, @code{--}, and the assignment operators) that
would necessarily cause side effects.  In addition, one can use
extensions that are specific to JML, in particular the JML primary
expressions.

@node Expressions, JML Primary Expressions, Specification Expressions, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section Expressions

@cindex expression
The JML syntax for expressions extends the Java syntax
with several operators and primitives.

@cindex expressions, precedence of
@cindex operator precedence
@cindex precedence, table of
@cindex table of precedence
The precedence of operators in JML expressions is similar to that in Java
The precedence levels are given in the following table,
where the parentheses, quantified expressions, 
@code{[]}, @code{.}, and method calls 
on the first three lines all have the highest precedence,
and for the rest, only the operators on the same line have the same precedence.

@display
  highest   @code{new ()} @code{\forall} @code{\exists} @code{\max} @code{\min}
                @code{\num_of} @code{\product} @code{\sum} @var{informal-description} 
                @code{[] .} and method calls 
            unary @code{+} and @code{-} @code{~} @code{!} @code{(}typecast@code{)}
            @code{* / %} 
            @code{+} (binary) @code{-} (binary) 
            @code{<< >> >>>} 
            @code{< <= > >= <: instanceof} 
            @code{== !=} 
            @code{&} 
            @code{^} 
            @code{|} 
            @code{&&} 
            @code{||} 
            @code{==>} @code{<==} 
            @code{<==>} @code{<=!=>}
            @code{?:}
  lowest    @code{= *= /= %= += -= <<= >>= >>>= &= ^= |=}
@end display

The following is the syntax of Java expressions, with JML additions.
The additions are
the operators @code{==>}, @code{<==}, @code{<==>}, @code{<=!=>},
and @code{<:}, and the syntax found under the
nonterminals @var{jml-primary}
(@pxref{JML Primary Expressions}) and
@var{set-comprehension} (@pxref{Set Comprehensions}).
The JML additions to the Java syntax can only be used
in assertions and other annotations.
Furthermore, within assertions, one cannot use any of the operators
(such as @code{++}, @code{--}, and the assignment operators) that
would necessarily cause side effects.

@cindex @var{expression-list}, defined
@cindex @var{expression}, defined
@cindex @var{assignment-op}, defined
@cindex @var{conditional-expr}, defined
@cindex @var{equivalence-expr}, defined
@cindex @var{equivalence-op}, defined
@cindex @var{implies-expr}, defined
@cindex @var{implies-non-backward-expr}, defined
@cindex @var{logical-or-expr}, defined
@cindex @var{logical-and-expr}, defined
@cindex @var{inclusive-or-expr}, defined
@cindex @var{exclusive-or-expr}, defined
@cindex @var{and-expr}, defined
@cindex @var{equality-expr}, defined
@cindex @var{relational-expr}, defined
@cindex @var{shift-expr}, defined
@cindex @var{shift-op}, defined
@cindex @var{additive-expr}, defined
@cindex @var{additive-op}, defined
@cindex @var{mult-expr}, defined
@cindex @var{mult-op}, defined
@cindex @var{unary-expr}, defined
@cindex @var{unary-expr-not-plus-minus}, defined
@cindex @var{postfix-expr}, defined
@cindex @var{primary-suffix}, defined
@cindex @var{primary-expr}, defined
@cindex @var{built-in-type}, defined
@cindex @var{constant}, defined
@cindex @var{new-expr}, defined
@cindex @var{new-suffix}, defined
@cindex @var{array-decl}, defined
@cindex @var{dim-exprs}, defined
@cindex @var{array-initializer}, defined
@cindex @var{initializer}, defined
@cindex @var{expression}, used
@cindex @var{assignment-expr}, used
@cindex @var{conditional-expr}, used
@cindex @var{assignment-op}, used
@cindex @var{equivalence-expr}, used
@cindex @var{implies-expr}, used
@cindex @var{equivalence-op}, used
@cindex @var{logical-or-expr}, used
@cindex @var{implies-non-backward-expr}, used
@cindex @var{logical-and-expr}, used
@cindex @var{inclusive-or-expr}, used
@cindex @var{exclusive-or-expr}, used
@cindex @var{and-expr}, used
@cindex @var{equality-expr}, used
@cindex @var{relational-expr}, used
@cindex @var{shift-expr}, used
@cindex @var{type-spec}, used
@cindex @var{additive-expr}, used
@cindex @var{shift-op}, used
@cindex @var{mult-expr}, used
@cindex @var{additive-op}, used
@cindex @var{unary-expr}, used
@cindex @var{mult-op}, used
@cindex @var{unary-expr-not-plus-minus}, used
@cindex @var{built-in-type}, used
@cindex @var{reference-type}, used
@cindex @var{postfix-expr}, used
@cindex @var{primary-expr}, used
@cindex @var{primary-suffix}, used
@cindex @var{ident}, used
@cindex @var{new-expr}, used
@cindex @var{expression-list}, used
@cindex @var{constant}, used
@cindex @var{jml-primary}, used
@cindex @var{java-literal}, used
@cindex @var{type}, used
@cindex @var{new-suffix}, used
@cindex @var{class-block}, used
@cindex @var{array-decl}, used
@cindex @var{array-initializer}, used
@cindex @var{set-comprehension}, used
@cindex @var{dim-exprs}, used
@cindex @var{dims}, used
@cindex @var{initializer}, used
@kindex @code{,}
@kindex @code{=}
@kindex @code{+=}
@kindex @code{-=}
@kindex @code{*=}
@kindex @code{/=}
@kindex @code{%=}
@kindex @code{>>=}
@kindex @code{>>>=}
@kindex @code{<<=}
@kindex @code{&=}
@kindex @code{|=}
@kindex @code{^=}
@kindex @code{?}
@kindex @code{:}
@kindex @code{<==>}
@kindex @code{<=!=>}
@kindex @code{==>}
@kindex @code{<==}
@kindex @code{<==}
@kindex @code{==>}
@kindex @code{||}
@kindex @code{&&}
@kindex @code{|}
@kindex @code{^}
@kindex @code{&}
@kindex @code{==}
@kindex @code{!=}
@kindex @code{<}
@kindex @code{>}
@kindex @code{<=}
@kindex @code{>=}
@kindex @code{<:}
@kindex @code{instanceof}
@kindex @code{<<}
@kindex @code{>>}
@kindex @code{>>>}
@kindex @code{+}
@kindex @code{-}
@kindex @code{*}
@kindex @code{/}
@kindex @code{%}
@kindex @code{(}
@kindex @code{)}
@kindex @code{++}
@kindex @code{--}
@kindex @code{~}
@kindex @code{!}
@kindex @code{[}
@kindex @code{]}
@kindex @code{.}
@kindex @code{this}
@kindex @code{class}
@kindex @code{super}
@kindex @code{true}
@kindex @code{false}
@kindex @code{this}
@kindex @code{null}
@kindex @code{void}
@kindex @code{boolean}
@kindex @code{byte}
@kindex @code{char}
@kindex @code{short}
@kindex @code{int}
@kindex @code{long}
@kindex @code{float}
@kindex @code{double}
@kindex @code{new}
@kindex @code{@{}
@kindex @code{)}
@kindex @code{@}}
@display
@var{expression-list} ::= @var{expression} [ @code{,} @var{expression} ] @dots{}
@var{expression} ::= @var{assignment-expr} 
@var{assignment-expr} ::= @var{conditional-expr}
                    [ @var{assignment-op} @var{assignment-expr} ]
@var{assignment-op} ::=  @code{=} | @code{+=} | @code{-=} | @code{*=} | @code{/=} | @code{%=} | @code{>>=}  
        | @code{>>>=} | @code{<<=} | @code{&=} | `@code{|=}' | @code{^=}
@var{conditional-expr} ::= @var{equivalence-expr}
                   [ @code{?} @var{conditional-expr} @code{:} @var{conditional-expr} ]
@var{equivalence-expr} ::= @var{implies-expr}
                     [ @var{equivalence-op} @var{implies-expr} ] @dots{}
@var{equivalence-op} ::= @code{<==>} | @code{<=!=>}
@var{implies-expr} ::= @var{logical-or-expr}
             [ @code{==>} @var{implies-non-backward-expr} ]
        | @var{logical-or-expr} @code{<==} @var{logical-or-expr}
             [ @code{<==} @var{logical-or-expr} ] @dots{}
@var{implies-non-backward-expr} ::= @var{logical-or-expr}
             [ @code{==>} @var{implies-non-backward-expr} ]
@var{logical-or-expr} ::= @var{logical-and-expr} [ `@code{||}' @var{logical-and-expr} ] @dots{}
@var{logical-and-expr} ::= @var{inclusive-or-expr} [ @code{&&} @var{inclusive-or-expr} ] @dots{}
@var{inclusive-or-expr} ::= @var{exclusive-or-expr} [ `@code{|}' @var{exclusive-or-expr} ] @dots{}
@var{exclusive-or-expr} ::= @var{and-expr} [ @code{^} @var{and-expr} ] @dots{}
@var{and-expr} ::= @var{equality-expr} [ @code{&} @var{equality-expr} ] @dots{}
@var{equality-expr} ::= @var{relational-expr} [ @code{==} @var{relational-expr}] @dots{}
        | @var{relational-expr} [ @code{!=} @var{relational-expr}] @dots{}
@var{relational-expr} ::= @var{shift-expr} @code{<} @var{shift-expr}
        | @var{shift-expr} @code{>} @var{shift-expr}
        | @var{shift-expr} @code{<=} @var{shift-expr}
        | @var{shift-expr} @code{>=} @var{shift-expr}
        | @var{shift-expr} @code{<:} @var{shift-expr}
        | @var{shift-expr} [ @code{instanceof} @var{type-spec} ]
@var{shift-expr} ::= @var{additive-expr} [ @var{shift-op} @var{additive-expr} ] @dots{}
@var{shift-op} ::= @code{<<} | @code{>>} | @code{>>>}
@var{additive-expr} ::= @var{mult-expr} [ @var{additive-op} @var{mult-expr} ] @dots{}
@var{additive-op} ::= @code{+} | @code{-}
@var{mult-expr} ::= @var{unary-expr} [ @var{mult-op} @var{unary-expr} ] @dots{}
@var{mult-op} ::= @code{*} | @code{/} | @code{%}
@var{unary-expr} ::= @code{(} @var{type-spec} @code{)} @var{unary-expr}
        | @code{++} @var{unary-expr}
        | @code{--} @var{unary-expr}
        | @code{+} @var{unary-expr}
        | @code{-} @var{unary-expr}
        | @var{unary-expr-not-plus-minus}
@var{unary-expr-not-plus-minus} ::= @code{~} @var{unary-expr}
        | @code{!} @var{unary-expr}
        | @code{(} @var{built-in-type} @code{)} @var{unary-expr}
        | @code{(} @var{reference-type} @code{)} @var{unary-expr-not-plus-minus}
        | @var{postfix-expr}
@var{postfix-expr} ::= @var{primary-expr} [ @var{primary-suffix} ] @dots{} [ @code{++} ]
        | @var{primary-expr} [ @var{primary-suffix} ] @dots{} [ @code{--} ]
        | @var{built-in-type} [ `@code{[}' `@code{]}' ] @dots{} @code{.} @code{class}
@var{primary-suffix} ::= @code{.} @var{ident}
        | @code{.} @code{this}
        | @code{.} @code{class}
        | @code{.} @var{new-expr}
        | @code{.} @code{super} @code{(} [ @var{expression-list} ] @code{)}
        | @code{(} [ @var{expression-list} ] @code{)}
        | `@code{[}' @var{expression} `@code{]}'
        | [ `@code{[}' `@code{]}' ] @dots{} @code{.} @code{class}
@var{primary-expr} ::= @var{ident} | @var{new-expr} 
        | @var{constant} | @code{super} | @code{true}
        | @code{false} | @code{this} | @code{null}
        | @code{(} @var{expression} @code{)}
        | @var{jml-primary}
@var{built-in-type} ::= @code{void} | @code{boolean} | @code{byte}
        | @code{char} | @code{short} | @code{int}
        | @code{long} | @code{float} | @code{double}
@var{constant} ::= @var{java-literal}
@var{new-expr} ::= @code{new} @var{type} @var{new-suffix}
@var{new-suffix} ::= @code{(} [ @var{expression-list} ] @code{)} [ @var{class-block} ]
        | @var{array-decl} [ @var{array-initializer} ]
        | @var{set-comprehension}
@var{array-decl} ::= @var{dim-exprs} [ @var{dims} ]
@var{dim-exprs} ::= `@code{[}' @var{expression} `@code{]}' [ `@code{[}' @var{expression} `@code{]}' ] @dots{}
@var{array-initializer} ::= @code{@{} [ @var{initializer} [ @code{,} @var{initializer} ] @dots{} [ @code{,} ] ] @code{@}}
@var{initializer} ::= @var{expression}
        | @var{array-initializer}
@end display

[[[Need to have semantics of the new things explained here.]]]

@node JML Primary Expressions, Set Comprehensions, Expressions, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section JML Primary Expressions

The following is the syntax of @var{jml-primary}.

@cindex @var{jml-primary}, defined
@cindex @var{result-expression}, used
@cindex @var{old-expression}, used
@cindex @var{not-assigned-expression}, used
@cindex @var{not-modified-expression}, used
@cindex @var{fresh-expression}, used
@cindex @var{reach-expression}, used
@cindex @var{duration-expression}, used
@cindex @var{space-expression}, used
@cindex @var{max-expression}, used
@cindex @var{working-space-expression}, used
@cindex @var{informal-description}, used
@cindex @var{nonnullelements-expression}, used
@cindex @var{typeof-expression}, used
@cindex @var{elemtype-expression}, used
@cindex @var{type-expression}, used
@cindex @var{lockset-expression}, used
@cindex @var{is-initialized-expression}, used
@cindex @var{invariant-for-expression}, used
@cindex @var{lblneg-expression}, used
@cindex @var{lblpos-expression}, used
@cindex @var{spec-quantified-expr}, used
@display
@var{jml-primary} ::= @var{result-expression}
        | @var{old-expression}
        | @var{not-assigned-expression}
        | @var{not-modified-expression}
        | @var{only-accessed-expression}
        | @var{only-assigned-expression}
        | @var{only-called-expression}
        | @var{only-captured-expression}
        | @var{fresh-expression}
        | @var{reach-expression}
        | @var{duration-expression}
        | @var{space-expression}
        | @var{working-space-expression}
        | @var{nonnullelements-expression}
        | @var{informal-description}
        | @var{typeof-expression}
        | @var{elemtype-expression}
        | @var{type-expression}
        | @var{lockset-expression}
        | @var{max-expression}
        | @var{is-initialized-expression}
        | @var{invariant-for-expression}
        | @var{lblneg-expression}
        | @var{lblpos-expression}
        | @var{spec-quantified-expr}
@end display

All of the JML keywords that can be used in expressions which would
otherwise start with an alphabetic character
start with a backslash (@code{\}),
so that they cannot clash with the program's variable names.

The new expressions that JML introduces are described below.
Several of the descriptions below quote, without attribution,
descriptions from [Leavens-Baker-Ruby06].

@c [[[ Suggest that we not allow [dims] after an ident - only as part of the
@c typespec. - DRCok ]]]

@menu
* Backslash result::            
* Backslash old and Backslash pre::  
* Backslash not_assigned::      
* Backslash not_modified::      
* Backslash only_accessed::     
* Backslash only_assigned::     
* Backslash only_called::       
* Backslash only_captured::     
* Backslash fresh::             
* Backslash reach::             
* Backslash duration::          
* Backslash space::             
* Backslash working space::     
* Backslash nonnullelements::   
* Informal Predicates::         
* Backslash typeof::            
* Backslash elemtype::          
* Backslash type::              
* Backslash lockset::           
* Backslash max::               
* Backslash is_initialized::    
* Backslash invariant_for::     
* Backslash lblneg and lblpos::  
* Quantified Expressions::      
@end menu

@node Backslash result, Backslash old and Backslash pre, JML Primary Expressions, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\result} 

The syntax of a @var{result-expression} is as follows.

@cindex @var{result-expression}, defined
@kindex @code{\result}
@display
@var{result-expression} ::= @code{\result}
@end display

The primary @code{\result} can only be used in @code{ensures},
@code{duration}, and @code{workingspace}
clauses of a non-void method.  Its value is the value returned by the
method.  Its type is the return type of the method; hence it is a type
error to use @code{\result} in a void method or in a constructor.

@node Backslash old and Backslash pre, Backslash not_assigned, Backslash result, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\old} and @code{\pre}

@cindex @var{old-expression}
An @var{old-expression} has the following syntax.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{old-expression}, defined
@cindex @var{spec-expression}, used
@cindex @var{ident}, used
@kindex @code{\old}
@kindex @code{\pre}
@kindex @code{,}
@kindex @code{(}
@kindex @code{)}
@display
@var{old-expression} ::= @code{\old} @code{(} @var{spec-expression} [ @code{,} @var{ident} ] @code{)}
        | @code{\pre} @code{(} @var{spec-expression} @code{)}
@end display

An expression of the form
@code{\old(}@i{Expr}@code{)} refers to the value that the expression
@i{Expr} had in the pre-state of a method.

@cindex reference semantics
JML uses Java's reference semantics, hence the pre-state value of an
expression whose type is a reference type is simply the reference;
it is @emph{not} a clone of the object the reference points to.
For example, suppose in the pre-state that
@code{v} is field that holds a reference to a @code{HashMap};
concretely, suppose that the location stored in @code{v} is
0x952ab340.  Then the expression @code{\old(v)} denotes the pre-state value
of @code{v}, which is the same reference, i.e.,
it is the address 0x952ab340.  Note that @code{\old(v)} is not a
reference to a copy of the @code{HashMap} stored at that location, but
simply a copy of the location's address (the reference), which is the
value of @code{v}.  If the fields of the object
at that location have changed in the post-state, then changes to those
fields will be visible through @code{\old(v)}; for example,
@code{\old(v).size()} will be the same as @code{v.size()}.
To write a post-condition that refers to @code{v}'s size in the pre-state,
one should instead write @code{\old(v.size())}.
Indeed as a general rule, it is always safest to use @code{\old()} only around
expressions whose type is a value type or a type with immutable
values, such as @code{String}. 

Expressions of this form may be used in both normal and exceptional
postconditions (@pxref{Method Specifications},
for more about such @code{ensures} and @code{signals} clauses), 
in history constraints, in duration and working space clauses, 
and also in assertions that appear in the bodies of methods
(@pxref{Statements and Annotation Statements}, for more about
@code{assert} and @code{assume} statements, loop
invariants, and variant functions).

However, we recommend that inside the bodies of methods, one of the
two other forms of @var{old-expression} (see below) be used instead.
The reason for this is that the reader 
may wonder whether @code{\old(@i{Expr})} in the body of a method means
the pre-state value of @i{Expr} (which it does) or the value of
@i{Expr} before some previous statement (which it does not).

@cindex @code{\pre}
An expression of the form
@code{\pre(}@i{Expr}@code{)} also refers to the value that the expression
@i{Expr} had in the pre-state of a method.
Expressions of this form may only be used in assertions that appear in
the bodies of methods 
(i.e., in @code{assert} and @code{assume} statements, and in loop
invariants and variant functions).
That is, such expressions may not be used in specification cases, and
hence may not appear in normal or exceptional
postconditions, in history constraints, or in duration and working
space clauses.

An expression of the form
@code{\old(}@i{Expr}@code{,} @i{Label}@code{)}
refers to the value that the expression
@i{Expr} had when control last reached the statement label @i{Label}.
That is, it refers to the value of the expression just before control
reached the statement the label is attached to.
Expressions of this form may only be used in assertions that appear in
the bodies of methods (i.e., in @code{assert} and @code{assume}
statements, and in loop invariants and variant functions).
That is, such expressions may not be used in specification cases, and
hence may not appear in normal or exceptional
postconditions, in history constraints, or in duration and working
space clauses.

In an expression of the form
@code{\old(}@i{Expr}@code{,} @i{Label}@code{)},
@i{Label} must be a label defined in the current method.
The type of 
@code{\old(}@i{Expr}@code{)},
@code{\old(}@i{Expr}@code{,} @i{Label}@code{)},
or @code{\pre(}@i{Expr}@code{)},
is simply the type of @i{Expr}.

It is a type error if @code{\old()} or @code{\pre()}
encloses a free occurrence of a
quantified variable.  For example, in the following,
@code{\old()} encloses a free occurrence of the quantified variable
@code{i}, which is declared in the surrounding quantifier, and thus
the example is illegal.
@example
    (\forall int i; 0 <= i && i < 7; \old(i < y))  // illegal
@end example
@noindent
The problem with the above example is that there is no easy way to
evaluate @code{\old(i < y)} in the pre-state.

@c [[[ Why isn't it just equivalent to the expression below, instead
@c of being illegal ? - DRCok]]] [[[Because such a rewriting isn't
@c always possible.]]]

However, constructions like the following are legal, as in the first
the use of @code{\old()} does not enclose the quantified variable,
@code{i}, and in the second use of @code{\old()} does not enclose a
free occurrence of the quantified variable (the variable is bound by
the declaration which is inside of @code{\old()}.

@example
     (\forall int i; 0 <= i && i < 7; i < \old(y))  // ok
     \old((\forall int i; 0 <= i && i < 7; i < y))  // ok
@end example

@c [[[Need to talk about quantifiers and purity]]]

@node Backslash not_assigned, Backslash not_modified, Backslash old and Backslash pre, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\not_assigned} 

The syntax of a @var{not-assigned-expression} is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}. 

@cindex @var{not-assigned-expression}, defined
@cindex @var{store-ref-list}, used
@kindex @code{\not_assigned}
@kindex @code{(}
@kindex @code{)}
@display
@var{not-assigned-expression} ::= @code{\not_assigned} @code{(} @var{store-ref-list} @code{)}
@end display

The JML operator @code{\not_assigned} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  It asserts that the locations
in the data group (@pxref{Data Groups}) named by the argument were not
assigned to during 
the execution of the method being specified (or all methods to which a
history constraint applies).
For example, @code{\not_assigned(xval,yval)} says that the locations
in the data groups named by @code{xval} and @code{yval} were not
assigned during the method's execution.

A predicate such as @code{\not_assigned(x.f)} refers to the entire
data group named by @code{x.f} not just to the location @code{x.f}
itself.  This allows one to specify absence of even temporary
side-effects in various cases of a method.
@xref{Backslash not_modified}, for ways to specify that just the value
of a given field was not changed, which allows temporary side effects.

The @code{\not_assigned} operator can be applied to both concrete and
model or ghost fields.  When applied to a model field, the meaning is
that all (concrete) locations in that model field's data group were
not assigned. 
[[[A real example would help here.]]]

The type of a @code{\not_assigned} expression is @code{boolean}.

@node Backslash not_modified, Backslash only_accessed, Backslash not_assigned, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\not_modified} 

The syntax of a @var{not-modified-expression} is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}. 

@cindex @var{not-modified-expression}, defined
@cindex @var{store-ref-list}, used
@kindex @code{\not_modified}
@kindex @code{(}
@kindex @code{)}
@display
@var{not-modified-expression} ::= @code{\not_modified} @code{(} @var{store-ref-list} @code{)}
@end display

@kindex @code{\not_modified}
The JML operator @code{\not_modified} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  It asserts that the values of
the named fields are the same in the post-state as in the pre-state;
for example, @code{\not_modified(xval,yval)} says that the fields
@code{xval} and @code{yval} 
have the same value in the pre- and post-states
(in the sense of the @code{equals} method for their types).

A predicate such as @code{\not_modified(x.f)} refers to the location
named by @code{x.f}, not to the entire data group of @code{x.f}.  This
allows one to specify benevolent side-effects, as one can name
@code{x.f} (or a data group in which it participates) in an assignable
clause, but use @code{\not_modified(x.f)} in the postcondition.
@xref{Backslash not_assigned}, for ways to specify that no assignments
were made to any location in a data group, disallowing temporary side effects.

The @code{\not_modified} operator can be applied to both concrete and
model or ghost fields.  When applied to a model field, the meaning is
that only the value of the model field is unchanged (in the sense of
its type's equals operation); concrete fields involved in its
representation may have changed.
[[[A real example would help here.]]]

The type of a @code{\not_modified} expression is @code{boolean}.

@node Backslash only_accessed, Backslash only_assigned, Backslash not_modified, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\only_accessed} 

The syntax of an @var{only-accessed-expression} is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}. 

@cindex @var{only-accessed-expression}, defined
@cindex @var{store-ref-list}, used
@kindex @code{\only_accessed}
@kindex @code{(}
@kindex @code{)}
@display
@var{only-accessed-expression} ::= @code{\only_accessed} @code{(} @var{store-ref-list} @code{)}
@end display

@kindex @code{\only_accessed}
The JML operator @code{\only_accessed} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  Used in a method's
postcondition (perhaps implicitly in a history constraint), it asserts
that the method's execution only reads from a subset of the data groups
named by the given fields.
For example, @code{\only_accessed(xval,yval)} says that no fields,
outside of the data groups of @code{xval} and @code{yval} were read by
the method. This includes both direct reads in the body of the
method, and reads during calls that were made by the method (and
methods those methods called, etc.).

A predicate such as @code{\only_accessed(x.f)} refers to the entire
data group named by @code{x.f} not just to the location @code{x.f}
itself. 

The @code{\only_accessed} operator can be applied to both concrete and
model or ghost fields.  When applied to a model field, the meaning is
that the (concrete) locations in that model field's data group are
permitted to be accessed during the method's execution.
@c [[[A real example would help here.]]]

The type of an @code{\only_accessed} expression is @code{boolean}.

@node Backslash only_assigned, Backslash only_called, Backslash only_accessed, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\only_assigned} 

The syntax of an @var{only-assigned-expression} is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}. 

@cindex @var{only-assigned-expression}, defined
@cindex @var{store-ref-list}, used
@kindex @code{\only_assigned}
@kindex @code{(}
@kindex @code{)}
@display
@var{only-assigned-expression} ::= @code{\only_assigned} @code{(} @var{store-ref-list} @code{)}
@end display

@kindex @code{\only_assigned}
The JML operator @code{\only_assigned} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  Used in a method's
postcondition (perhaps implicitly in a history constraint), it asserts
that the method's execution only assigned to a subset of the data groups
named by the given fields.
For example, @code{\only_assigned(xval,yval)} says that no fields,
outside of the data groups of @code{xval} and @code{yval} were assigned by
the method.  This includes both direct assignments in the body of the
method, and assignments during calls that were made by the method (and
methods those methods called, etc.).

A predicate such as @code{\only_assigned(x.f)} refers to the entire
data group named by @code{x.f} not just to the location @code{x.f}
itself. 

The @code{\only_assigned} operator can be applied to both concrete and
model or ghost fields.  When applied to a model field, the meaning is
that the (concrete) locations in that model field's data group are
permitted to be assigned during the method's execution.
@c [[[A real example would help here.]]]

The type of an @code{\only_assigned} expression is @code{boolean}.

@node Backslash only_called, Backslash only_captured, Backslash only_assigned, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\only_called} 

The syntax of an @var{only-called-expression} is as follows.
@xref{Constraints}, for the syntax of @var{method-name-list}. 

@cindex @var{only-called-expression}, defined
@cindex @var{method-name-list}, used
@kindex @code{\only_called}
@kindex @code{(}
@kindex @code{)}
@display
@var{only-called-expression} ::= @code{\only_called} @code{(} @var{method-name-list} @code{)}
@end display

@kindex @code{\only_called}
The JML operator @code{\only_called} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  Used in a method's
postcondition (perhaps implicitly in a history constraint), it asserts
that the method's execution only called from a subset of methods given
in the @var{method-name-list}.
For example, @code{\only_called(p,q)} says that methods, apart from
@code{p} and @code{q}, were called during this method's execution.

@c [[[A real example would help here.]]]

The type of an @code{\only_called} expression is @code{boolean}.

@node Backslash only_captured, Backslash fresh, Backslash only_called, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\only_captured} 

The syntax of an @var{only-captured-expression} is as follows.
@xref{Store Refs}, for the syntax of @var{store-ref-list}. 

@cindex @var{only-captured-expression}, defined
@cindex @var{store-ref-list}, used
@kindex @code{\only_captured}
@kindex @code{(}
@kindex @code{)}
@display
@var{only-captured-expression} ::= @code{\only_captured} @code{(} @var{store-ref-list} @code{)}
@end display

@kindex @code{\only_captured}
The JML operator @code{\only_captured} can be used in both normal and
exceptional preconditions (i.e., in @code{ensures} and @code{signals}
clauses), and in history constraints.  Used in a method's
postcondition (perhaps implicitly in a history constraint), it asserts
that the method's execution only captured references from a subset of
the data groups named by the given fields.
For example, @code{\only_captured(xv,yv)} says that no references,
outside of the data groups of @code{xv} and @code{yv} were captured by
the method.

@cindex captured
A reference is @dfn{captured} when it is stored into a field (as
opposed to a local variable).  Typically a method captures a formal
parameter (or a reference stored in a static field) by assigning it to
a field in the method's receiver (the @code{this} object), a field in
some object (or to an array element), or to a static field.

A predicate such as @code{\only_captured(x.f)} refers to the
references stored in the entire data group named by @code{x.f} in the
pre-state, not just to those stored in the location @code{x.f} itself. 
However, since the references being captured are usually found in
formal parameters, the complications of data groups can usually be ignored.

The @code{\only_captured} operator can be applied to both concrete and
model or ghost fields.  When applied to a model field, the meaning is
that the (concrete) locations in that model field's data group are
permitted to be captured during the method's execution.
@c [[[A real example would help here.]]]

The type of an @code{\only_captured} expression is @code{boolean}.

@node Backslash fresh, Backslash reach, Backslash only_captured, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\fresh}

The syntax of a @var{fresh-expression} is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression-list}.

@cindex @var{fresh-expression}, defined
@cindex @var{spec-expression-list}, used
@kindex @code{\fresh}
@kindex @code{(}
@kindex @code{)}
@display
@var{fresh-expression} ::= @code{\fresh} @code{(} @var{spec-expression-list} @code{)}
@end display

@cindex fresh predicate
The operator @code{\fresh} asserts that objects were freshly allocated;
for example, @code{\fresh(x,y)} asserts that
@code{x} and @code{y} are not null
and that the objects bound to these identifiers
were not allocated in the pre-state.
The arguments to @code{\fresh} can have any reference type,
and the type of the overall expression is @code{boolean}.

@cindex fresh, and constructor specifications
@kindex @code{\fresh}, and constructor specifications
@cindex constructor specifications, and @code{\fresh}
Note that it is wrong to use @code{\fresh(this)} in the specification
of a constructor, because Java's @code{new} operator allocates storage
for the object; the constructor's job is just to initialize that
storage.

@node Backslash reach, Backslash duration, Backslash fresh, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\reach}

The syntax of a @var{reach-expression} is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{reach-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\reach}
@kindex @code{(}
@kindex @code{)}
@display
@var{reach-expression} ::= @code{\reach} @code{(} @var{spec-expression} @code{)}
@end display

@cindex reachable objects
The @code{\reach} expression 
allows one to refer to the set of objects reachable from some particular object.
The syntax @code{\reach(}@i{x}@code{)}
denotes the smallest @code{JMLObjectSet} containing the object denoted by
@i{x}, if any,
and all objects accessible through all fields of objects in this set.
That is, if @i{x} is @code{null}, then this set is empty
otherwise it contains @i{x},
all objects accessible through all fields of @i{x},
all objects accessible through all fields of these objects,
and so on, recursively.
If @i{x} denotes a model field (or data group), then 
@code{\reach(}@i{x}@code{)}
denotes the smallest @code{JMLObjectSet} containing the objects
reachable from @i{x} or reachable from the objects referenced by 
fields in that data group.

@node Backslash duration, Backslash space, Backslash reach, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\duration} 

The syntax of a @var{duration-expression} is as follows.
@xref{Expressions}, for the syntax of @var{expression}.

@cindex @var{duration-expression}, defined
@cindex @var{expression}, used
@kindex @code{\duration}
@kindex @code{(}
@kindex @code{)}
@display
@var{duration-expression} ::= @code{\duration} @code{(} @var{expression} @code{)}
@end display

@cindex duration, specification of
@cindex time, specification of
@cindex resources, specification of
@code{\duration}, which describes the specified maximum number of
virtual machine cycle times needed to execute the method call or
explicit constructor invocation expression that is its argument; e.g.,
@code{\duration(myStack.push(o))} is the maximum number of virtual
machine cycles needed to execute the call @code{myStack.push(o)},
according to the contract of the static type of @code{myStack}'s
type's @code{push} method, when passed argument @code{o}.  Note that
the expression used as an argument to @code{\duration} should be
thought of as quoted, in the sense that it is not to be executed; thus
the method or constructor called need not be free of side effects.
Note that the argument to @code{\duration} is an
@var{expression} instead of just the name of a method,
because different method calls, i.e., those with different parameters,
can take different amounts of time [Krone-Ogden-Sitaraman03]. 

The argument expression passed to @code{\duration}
must be a method call or explicit constructor
invocation expression; the type of a @code{\duration} expression is
@code{long}.

@c [[[ Why not make this simply an arbitrary expression? - DRCok ]]]

@cindex virtual machine cycle time
@cindex cycle, virtual machine
@cindex time, virtual machine cycle
For a given Java Virtual Machine, a @dfn{virtual machine cycle} is
defined to be the minimum of the maximum over all Java Virtual Machine
instructions, @i{i}, of the length of time needed to execute
instruction @i{i}.


@node Backslash space, Backslash working space, Backslash duration, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\space} 

The syntax of a @var{space-expression} is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.
[[[ Shouldn't this take an expression instead of a spec-expression? - DRC]]]
@cindex @var{space-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\space}
@kindex @code{(}
@kindex @code{)}
@display
@var{space-expression} ::= @code{\space} @code{(} @var{spec-expression} @code{)}
@end display

@cindex space, specification of
@cindex space, taken up by an object
@cindex resources, specification of
@code{\space}, which describes the amount of heap space, in bytes,
allocated to the object referred to by its argument [Krone-Ogden-Sitaraman03];
e.g., @code{\space(myStack)} is number of bytes in the heap used by
@code{myStack}, not including the objects it contains.  The type of
the @var{spec-expression} that is the argument must be a reference
type, and the result type of a @code{\space} expression is
@code{long}.  

@c [[[ The argument is evaluated, no? - DRCok ]]]

@node Backslash working space, Backslash nonnullelements, Backslash space, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\working_space} 

@cindex @var{working-space-expression}, defined
@cindex @var{expression}, used
@kindex @code{\working_space}
@kindex @code{(}
@kindex @code{)}
@display
@var{working-space-expression} ::= @code{\working_space} @code{(} @var{expression} @code{)}
@end display

@cindex working space, specification of
@cindex method call, space used by
@cindex resources, specification of
@code{\working_space}, which describes the maximum specified amount of
heap space, in bytes, used by the method call or explicit constructor
invocation expression that is its argument; e.g.,
@code{\working_space(myStack.push(o))} is the maximum number of bytes
needed on the heap to execute the call @code{myStack.push(o)},
according to the contract of the static type of @code{myStack}'s
type's @code{push} method, when passed argument @code{o}.  
@c [[[ Why not allow the argument to be an expression ? - DRCok ]]]
Note that
the expression used as an argument to @code{\working_space} should be
thought of as quoted, in the sense that it is not to be executed; thus
the method or constructor called need not be free of side effects.
The detailed arguments are needed in the specification of the call
because different method calls, i.e., those with different parameters,
can use take different amounts of space [Krone-Ogden-Sitaraman03]. 
The argument expression must be a method call or explicit constructor
invocation expression; the result type of a @code{\working_space}
expression is @code{long}.

@node Backslash nonnullelements, Informal Predicates, Backslash working space, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\nonnullelements}

The syntax of a @var{nonnullelements-expression} is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{nonnullelements-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\nonnullelements}
@kindex @code{(}
@kindex @code{)}
@display
@var{nonnullelements-expression} ::= @code{\nonnullelements} @code{(} @var{spec-expression} @code{)}
@end display

@cindex non-null elements, of an array
@cindex array, specifying elements are non-null
The operator @code{\nonnullelements}
can be used to assert that an array and its elements are all non-null.
For example, @code{\nonnullelements(myArray)}, is equivalent to
[Leino-Nelson-Saxe00]

@example
  myArray != null &&
  (\forall int i; 0 <= i && i < myArray.length;
                  myArray[i] != null)
@end example

@node Informal Predicates, Backslash typeof, Backslash nonnullelements, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection Informal Predicates

An @var{informal-description} is some text enclosed in @code{(*} and
@code{*)}.
@xref{Tokens}, for details of its syntax.
It is used as an escape form formality.

An informal description used as a predicate has type boolean.
Hence the text in an informal description should describe a condition,
for example @code{(* the value of x is displayed *)}.

The value of an informal description is only known to the user, not to
any JML tools, so it is never executable.  Informal descriptions
should thus be avoided when possible, but can be used to avoid
formalizing everything when doing so would be too expensive.

@node Backslash typeof, Backslash elemtype, Informal Predicates, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\typeof}

The syntax of a @var{typeof-expression} is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{typeof-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\typeof}
@kindex @code{(}
@kindex @code{)}
@display
@var{typeof-expression} ::= @code{\typeof} @code{(} @var{spec-expression} @code{)}
@end display

@cindex typeof expression
@cindex dynamic type of an expression
The operator @code{\typeof} returns the most-specific dynamic type of an
expression's value [Leino-Nelson-Saxe00].  The meaning of
@code{\typeof(}@i{E}@code{)} is unspecified if @i{E} is null.  If @i{E}
has a static type that is a reference type, then
@code{\typeof(}@i{E}@code{)} means the same thing as
@i{E}@code{.getClass()}.  For example, if @code{c} is a variable of
static type @code{Collection} that holds an object of class
@code{HashSet}, then @code{\typeof(c)} is @code{HashSet.class}, which is
the same thing as @code{\type(HashSet)}.  If @i{E} has a static type
that is not a reference type, then @code{\typeof(}@i{E}@code{)} means
the instance of @code{java.lang.Class} that represents its static type.
For example, @code{\typeof(true)} is @code{Boolean.TYPE}, which is the
same as @code{\type(boolean)}.  Thus an expression of the form
@code{\typeof(}@i{E}@code{)} has type @code{\TYPE}, which JML considers
to be the same as @code{java.lang.Class}.

@node Backslash elemtype, Backslash type, Backslash typeof, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\elemtype}

The syntax of a @var{elemtype-expression} is as follows.

@cindex @var{elemtype-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\elemtype}
@kindex @code{(}
@kindex @code{)}
@display
@var{elemtype-expression} ::= @code{\elemtype} @code{(} @var{spec-expression} @code{)}
@end display

@cindex element type, of array, expression
@cindex array, element type expression
The @code{\elemtype} operator returns the most-specific static type
shared by all elements of its array argument [Leino-Nelson-Saxe00].  For
example, @code{\elemtype(\type(int[]))} is @code{\type(int)}.  The
argument to @code{\elemtype} must be an expression of type @code{\TYPE},
which JML considers to be the same as @code{java.lang.Class}, and its
result also has type @code{\TYPE} (@pxref{Type-Specs}).  If the argument is not an array type,
then the result is @code{null}.  For example, @code{\elemtype(\type(int))}
and @code{\elemtype(\type(Object))} are both @code{null}.

@c [[[ Should the result be null or \typeof(null)??  It's null, since
@c a TYPE is an object reference.]]]

@node Backslash type, Backslash lockset, Backslash elemtype, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\type}

The syntax of a @var{type-expression} is as follows.
@xref{Type-Specs}, for the syntax of @var{type}.

@cindex @var{type-expression}, defined
@cindex @var{type}, used
@kindex @code{\type}
@kindex @code{(}
@kindex @code{)}
@display
@var{type-expression} ::= @code{\type} @code{(} @var{type} @code{)}
@end display
@cindex types, marking in expressions
@cindex reflection in assertions
@cindex @code{java.lang.Class}, vs. @code{\type()}
The operator @code{\type} can be used to introduce literals of type
@code{\TYPE} in expressions.
An expression of the form @code{\type(T)},
where @code{T} is a type name, has the type @code{\TYPE}.
Since in JML @code{\TYPE} is the same as @code{java.lang.Class},
an expression of the form @code{\type(}@i{T}@code{)}
means the same thing as @i{T}@code{.class}, if @i{T} is a reference type.
If @i{T} is a primitive type, then @code{\type(T)} is equivalent to the value
of the @code{TYPE} field of the corresponding reference type.  Thus
@code{\type(boolean)} equals @code{Boolean.TYPE}.

For example, in

@example
   \typeof(myObj) <: \type(PlusAccount)
@end example

@noindent
the use of @code{\type(PlusAccount)} is used to introduce 
the type @code{PlusAccount} into this expression context.

@node Backslash lockset, Backslash max, Backslash type, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\lockset}

The syntax of a @var{lockset-expression} is as follows.

@cindex @var{lockset-expression}, defined
@kindex @code{\lockset}
@display
@var{lockset-expression} ::= @code{\lockset}
@end display

@cindex locks held by a thread
@cindex thread, specifying locks held by
@cindex ESC/Java
@cindex Leino
The @code{\lockset} primitive denotes
the set of locks held by the current thread.
It is of type @code{JMLObjectSet}.
(This is an adaptation from ESC/Java [Leino-etal00]
[Leino-Nelson-Saxe00] for dealing with threads.)

@node Backslash max, Backslash is_initialized, Backslash lockset, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\max}

The syntax of a @var{max-expression} is as follows. 
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{max-expression}, defined
@cindex @var{spec-expression}, used
@kindex @code{\max}
@kindex @code{(}
@kindex @code{)}
@display
@var{max-expression} ::= @code{\max} @code{(} @var{spec-expression} @code{)}
@end display
@cindex max of a set of lock objects
@cindex ESC/Java
The @code{\max} operator returns the "largest" (as defined by @code{<}) of a
set of lock objects, given a lock set as an argument.  The result is of type Object.
(This is an adaptation from ESC/Java [Leino-etal00]
[Leino-Nelson-Saxe00] for dealing with threads.)

If you are looking to take the maximum of several integers, use the
max quantifier
(@pxref{Generalized Quantifiers}).

@node Backslash is_initialized, Backslash invariant_for, Backslash max, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\is_initialized}

The syntax of the @var{is-initialized-expression} is as follows.
@xref{Type-Specs}, for the syntax of @var{reference-type}

@cindex @var{is-initialized-expression}, defined
@cindex @var{reference-type}, used
@kindex @code{\is_initialized}
@kindex @code{(}
@kindex @code{)}
@display
@var{is-initialized-expression} ::= @code{\is_initialized} @code{(} @var{reference-type} @code{)}
@end display

@cindex initialization, specification that a class is
@cindex class initialization predicate
The @code{\is_initialized} operator returns true just when its
@var{reference-type} argument is a class that has finished its static
initialization.  It is of type @code{boolean}.

@node Backslash invariant_for, Backslash lblneg and lblpos, Backslash is_initialized, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\invariant_for}

@cindex @var{invariant-for-expression}, defined
@kindex @code{\invariant_for}
@kindex @code{(}
@kindex @code{)}
@display
@var{invariant-for-expression} ::= @code{\invariant_for} @code{(} @var{spec-expression} @code{)}
@end display

@cindex invariant, for an object
The @code{\invariant_for} operator returns true just when its argument
satisfies the invariant of its static type; for example,
@code{\invariant_for((MyClass)o)} is true when @code{o} satisfies the
invariant of @code{MyClass}.  The entire @code{\invariant_for}
expression is of type @code{boolean}.

@node Backslash lblneg and lblpos, Quantified Expressions, Backslash invariant_for, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection @code{\lblneg} and @code{\lblpos}

The syntax of the two kinds of labeled expressions is as follows.
@xref{Specification Expressions}, for the syntax of @var{spec-expression}.

@cindex @var{lblneg-expression}, defined
@cindex @var{lblpos-expression}, defined
@cindex @var{spec-expression}, used
@cindex @var{ident}, used
@kindex @code{\lblneg}
@kindex @code{\lblpos}
@kindex @code{(}
@kindex @code{)}
@display
@var{lblneg-expression} ::= @code{(} @code{\lblneg} @var{ident} @var{spec-expression} @code{)}
@var{lblpos-expression} ::= @code{(} @code{\lblpos} @var{ident} @var{spec-expression} @code{)}
@end display

@cindex label expression (negative)
@cindex label expression (positive)
Parenthesized expressions that start with
@code{\lblneg} and @code{\lblpos}
can be used to attach labels to expressions [Leino-Nelson-Saxe00];
these labels might be printed in various messages by support tools,
for example, to identify an assertion that failed.
Such an expression has a @dfn{label} and a @dfn{body};
for example, in

@example
   (\lblneg indexInBounds 0 <= index && index < length)
@end example

@noindent
the label is @code{indexInBounds}
and the body is the expression @code{0 <= index && index < length}.
The value of a labeled expression is the value of its body,
hence its type is the type of its body.
The idea is that if this expression is used in an assertion
and its value is @code{false} (e.g., when doing run-time checking
of assertions), then a warning will be printed that includes
the label @code{indexInBounds}.
The form using @code{\lblpos} has a similar syntax,
but should be used for warnings when the value of the enclosed expression
is @code{true}.

@node Quantified Expressions,  , Backslash lblneg and lblpos, JML Primary Expressions
@comment  node-name,  next,  previous,  up
@subsection Quantified Expressions

@cindex bound variable, in quantifier
@cindex range predicate, in quantifier
@cindex body, in quantifier
@cindex quantifier, range predicate in
@cindex quantifier, body of
@kindex @code{;}, in quantifiers
@cindex @var{spec-quantified-expr}, defined
@cindex @var{quantifier}, defined
@cindex @var{quantified-var-decls}, defined
@cindex @var{quantified-var-declarator}, defined
@cindex @var{spec-variable-declarators}, defined
@cindex @var{spec-variable-declarator}, defined
@cindex @var{spec-variable-declarator}, defined
@cindex @var{spec-array-initializer}, defined
@cindex @var{spec-initializer}, defined
@cindex @var{quantifier}, used
@cindex @var{quantified-var-decls}, used
@cindex @var{predicate}, used
@cindex @var{spec-expression}, used
@cindex @var{type-spec}, used
@cindex @var{quantified-var-declarator}, used
@cindex @var{bound-var-modifiers}, used
@cindex @var{ident}, used
@cindex @var{dims}, used
@cindex @var{spec-variable-declarator}, used
@cindex @var{spec-initializer}, used
@cindex @var{spec-array-initializer}, used
@kindex @code{(}
@kindex @code{;}
@kindex @code{)}
@kindex @code{\forall}
@kindex @code{\exists}
@kindex @code{\max}
@kindex @code{\min}
@kindex @code{\num_of}
@kindex @code{\product}
@kindex @code{\sum}
@kindex @code{,}
@kindex @code{=}
@display
@var{spec-quantified-expr} ::= @code{(} @var{quantifier} @var{quantified-var-decls} @code{;}
                           [ [ @var{predicate} ] @code{;} ]
                           @var{spec-expression} @code{)}
@var{quantifier} ::= @code{\forall} | @code{\exists}
        | @code{\max} | @code{\min}
        | @code{\num_of} | @code{\product} | @code{\sum}
@var{quantified-var-decls} ::= [ @var{bound-var-modifiers} ] @var{type-spec} @var{quantified-var-declarator}
                         [ @code{,} @var{quantified-var-declarator} ] @dots{}
@var{quantified-var-declarator} ::= @var{ident} [ @var{dims} ]
@var{spec-variable-declarators} ::= @var{spec-variable-declarator}
                          [ @code{,} @var{spec-variable-declarator} ] @dots{}
@var{spec-variable-declarator} ::= @var{ident} [ @var{dims} ]
                             [ @code{=} @var{spec-initializer} ]
@var{spec-array-initializer} ::= @code{@{} [ @var{spec-initializer}
             [ @code{,} @var{spec-initializer} ] @dots{} [ @code{,} ] ] @code{@}}
@var{spec-initializer} ::= @var{spec-expression}
        | @var{spec-array-initializer}
@end display

Note that each quantified expression includes a set of parentheses; these
parentheses cannot be omitted.  The first part of a quantified expression is
the @var{quantifier}, which determines the operation to be performed. Every
quantifier starts with a backslash (@code{\}).  Following the quantifier are
@var{quantified-var-decls}, which declare @dfn{bound variables} whose scope is
the @var{spec-quantified-expr}. The bound variables may not conflict with
existing local variables, but may hide static and instance fields. The
optional predicate between the two semicolons is the @dfn{range predicate}; a
quantifier ranges over all possible values of its bound variables that satisfy
the range predicate (for a discussion of the ranges of values for reference
types, @pxref{Quantifying over Reference Types}). If the range predicate is
omitted, it defaults to @code{true}. The final @var{spec-expression} is called
the @dfn{body} of the quantifier. 

We discuss the various kinds of quantified expressions below.

@menu
* Universal and Existential Quantifiers::  
* Generalized Quantifiers::     
* Numerical Quantifier::        
* Executability of Quantified Expressions::  
* Modifiers for Bound Variables::  
* Quantifying over Reference Types::  
@end menu

@node Universal and Existential Quantifiers, Generalized Quantifiers, Quantified Expressions, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Universal and Existential Quantifiers

@kindex @code{\forall}
@kindex @code{\exists}
The quantifiers
@code{\forall} and @code{\exists},
are universal and existential quantifiers (respectively).
For example,

@example
  (\forall int i,j; 0 <= i && i < j && j < 10; a[i] < a[j])
@end example

@noindent
says that the values @code{a[0]} @dots{} @code{a[9]} are sorted. 

The body of a universal or existential quantifier must be of type 
@code{boolean}. The type of a universal or existential quantified expression 
as a whole is @code{boolean}. When the range predicate is not satisfiable, the value of a @code{\forall} expression is @code{true} and the value of an @code{\exists} expression is @code{false}. For example:
@cindex empty range
@cindex range predicate, not satisfiable
@example
  (\forall int i; 0 < i && i < 0; 0 < i) == true
  (\exists int i; 0 < i && i < 0; 0 < i) == false
@end example

@node Generalized Quantifiers, Numerical Quantifier, Universal and Existential Quantifiers, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Generalized Quantifiers

@kindex @code{\max}
@kindex @code{\min}
@kindex @code{\product}
@kindex @code{\sum}
@cindex product, see @code{\product}
@cindex summation, see @code{\sum}
@cindex quantified addition, see @code{\sum}
@cindex quantified multiplication, see @code{\product}
@cindex addition, quantified see @code{\sum}
@cindex multiplication, quantified, see @code{\product}
@cindex maximum, see @code{\max}
@cindex minimum, see @code{\min}
@cindex quantified maximum, see @code{\max}
@cindex quantified minimum, see @code{\min}
@cindex quantifier, generalized
@cindex generalized quantifier
@cindex body of a quantifier
@cindex quantifier, body
@cindex Cohen
The quantifiers @code{\max}, @code{\min}, @code{\product}, and
@code{\sum}, are generalized quantifiers that return the maximum,
minimum, product, or sum of the values of the expressions given, where
the variables satisfy the given range. The expression in the body must be of a 
built-in numeric type, such as @code{int} or @code{double}; the type of the
quantified expression as a whole is the type of its body.  For example, the 
following equations are all true (see chapter 3 of [Cohen90]):
@example
  (\sum int i; 0 <= i && i < 5; i) == 0 + 1 + 2 + 3 + 4
  (\product int i; 0 < i && i < 5; i) == 1 * 2 * 3 * 4
  (\max int i; 0 <= i && i < 5; i) == 4
  (\min int i; 0 <= i && i < 5; i-1) == -1
@end example

For computing the value of a sum or product, Java's arithmetic is
used.  [[[ This would depend on the arithmetic mode in force - DRC]]]The meaning thus depends on the type of the expression.  For
example, in Java, floating point numbers use the IEEE 754 standard,
and thus when an overflow occurs, the appropriate positive or negative
infinity is returned.  However, Java integers wrap on overflow.
Consider the following examples.
@example
  (\product float f; 1.0e30f < f && f < 1.0e38f; f)
    == Float.POSITIVE_INFINITY

  (\sum int i; i == Integer.MAX_VALUE || i == 1; i)
    == Integer.MAX_VALUE + 1
    == Integer.MIN_VALUE
@end example

@cindex empty range
@cindex range predicate, not satisfiable
When the range predicate is not satisfiable, the sum is 0 and the
product is 1; for example:
@example
  (\sum int i; false; i) == 0
  (\product double d; false; d*d) == 1.0
@end example

When the range predicate is not satisfiable for @code{\max} the result
is the smallest number with the type of the expression in the body;
for floating point numbers, negative infinity is used.  Similarly,
when the range predicate is not satisfiable for @code{\min}, the
result is the largest number with the type of the expression in the
body.  [[[ Or should this be undefined - DRC]]]

@c [[[ What about if the body type is \bigint ? - DRCok ]]]

@node Numerical Quantifier, Executability of Quantified Expressions, Generalized Quantifiers, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Numerical Quantifier

@cindex @code{\num_of}
@cindex numerical quantifier, see @code{\num_of}
@cindex Cohen
The numerical quantifier, @code{\num_of}, returns the number of values
for its variables for which the range and the expression in its body
are true.  The body must have type @code{boolean}, and the entire quantified 
expression has type @code{long}.  The meaning of this quantifier is defined by 
the following equation (see p. 57 of [Cohen90]).

@example
  (\num_of T x; R(x); P(x)) == (\sum T x; R(x) && P(x); 1L)
@end example

@node Executability of Quantified Expressions, Modifiers for Bound Variables, Numerical Quantifier, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Executability of Quantified Expressions

@cindex quantifier, executability of
@cindex range predicate, and executability of quantifiers
@cindex executability of quantified expressions
When are universal or existential quantifiers executable for purposes
of runtime assertion checking?
If the type of the quantified variable is @code{boolean}, then it is
always executable.  Otherwise a @var{spec-quantified-expr} 
is only executable if the form of the expression
matches a pattern that the runtime assertion checker understands. 
This varies by tool implementation, but you can expect that the
runtime assertion checker understands patterns where the range predicate
gives a finite range for an ordinal primitive value type (such as
@code{int}) or where the range predicate requires the quantified
variable to be drawn from some set.
Examples include the following.
[[[Make these examples be real examples in the samples directory]]]

@example
     (\forall int x; 0 <= x && x < somelimit; ...)
     (\forall Object x; someSet.has(x); ...)
@end example

@cindex @code{jmlc}
@cindex @code{jmlc}, warnings for non-executable assertions
You should get warnings from the @code{jmlc} tool
when assertions are not executable,
but you have to use the @code{-w2} flag to see them.

If a @var{spec-quantified-expr}, @i{QE}, is executable, then a tool executing
it should only evaluate any range expression in @i{QE}
once per execution of @i{QE}.  Since the value of such a range expression
cannot change, this evaluation strategy will not change the value of
@i{QE}, but it will save time to only evaluate the
range expression once for each evaluation of @i{QE}.

@node Modifiers for Bound Variables, Quantifying over Reference Types, Executability of Quantified Expressions, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Modifiers for Bound Variables

@cindex bound variables, modifiers for
@cindex modifiers for bound variables
@cindex @var{bound-var-modifiers}, defined
@display
@var{bound-var-modifiers} ::= @code{non_null} | @code{nullable}
@end display

Logical variables can be bound in 

@itemize @bullet
@item quantified expressions (@pxref{Quantified Expressions}),
@item set comprehension expressions (@pxref{Set Comprehensions}),
@item forall clauses of method contracts (@pxref{Forall Variable Declarations}), or
@item old clauses of method contracts (@pxref{Old Variable Declarations}).
@end itemize

Note that in JML, @code{non_null} and @code{nullable} are not reserved
words, hence such identifiers can be used as type names. In order to
quantify over the elements of a type named @code{non_null} or
@code{nullable} is necessary to provide an explicit nullity
modifier.  For example,
@example
  (\forall non_null non_null nn; ...)
@end example
where the first @code{non_null} is one of the @var{bound-var-modifiers} and
the second is the type @code{non_null}.

@node Quantifying over Reference Types,  , Modifiers for Bound Variables, Quantified Expressions
@comment  node-name,  next,  previous,  up
@subsubsection Quantifying over Reference Types

The range of values for a quantified variable that is declared to be of a reference type:
@itemize @bullet
@item
Does not include @code{null} unless the bound variable is declared
@code{nullable} (@pxref{Non-null by Default}). 
@cindex @code{null}
@cindex @code{nullable}

@item
May include references to objects that are not constructed by the program;
one should use a range predicate to eliminate such cases if they are not desired.
@end itemize

@node Set Comprehensions, JML Operators, JML Primary Expressions, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section Set Comprehensions

@cindex set comprehension
The syntax of a @var{set-comprehension} expression is as follows.

@cindex @var{set-comprehension}, defined
@cindex @var{type-spec}, used
@cindex @var{quantified-var-declarator}, used
@cindex @var{postfix-expr}, used
@cindex @var{ident}, used
@cindex @var{predicate}, used
@kindex @code{@{}
@kindex @code{|}
@kindex @code{@}}
@kindex @code{.}
@kindex @code{has}
@kindex @code{&&}
@display
@var{set-comprehension} ::= @code{@{} [ @var{bound-var-modifiers} ] @var{type-spec}
            @var{quantified-var-declarator} `@code{|}'
            @var{postfix-expr} @code{&&} @var{predicate} @code{@}}
@end display

The set comprehension notation can be used to succinctly define sets.
For example, the following is the @code{JMLObjectSet} that is the
subset of non-@code{null} @code{Integer} objects found in the set
@code{myIntSet} whose values are between 0 and 10, inclusive.

@example
  new JMLObjectSet @{Integer i | myIntSet.has(i) && 
      i != null && 0 <= i.intValue() && i.intValue() <= 10 @}
@end example

The syntax of JML limits set comprehensions so that the @var{postfix-expr}
following the vertical bar (@code{|}) is always a method invocation with the 
bound variable declared in the @var{quantified-var-declarator} as its 
parameter; the method may be either the @code{has} method of an 
@code{org.jmlspecs.models.JMLObjectSet} or 
@code{org.jmlspecs.models.JMLValueSet}, or the @code{contains} method of a 
@code{java.util.Collection}. This restriction is used to avoid Russell's 
paradox [Whitehead-Russell25]. The bound variable, whose scope is the 
@var{set-comprehension}, may not conflict with existing local variables, but 
may hide static and instance fields. The bound variable type is used to restrict the objects that become part of the resulting set; if the set called in the @var{postfix-expr} contains objects that are not assignable to the bound variable, they are not contained in the resulting set comprehension. Thus, the following two set comprehension expressions result in identical sets:

@example
  new JMLObjectSet @{Integer i | s.has(i) && 0 < i.intValue() @}
  new JMLObjectSet @{Object i | s.has(i) && i instanceof Integer && 
      0 < ((Integer) i).intValue() @}
@end example

In practice, one starts either from some relevant set at hand or from the sets 
found in @code{JMLObjectSet} and @code{JMLValueSet} containing the objects of 
primitive types. The type of a set comprehension is the type named following 
@code{new}, which must be @code{JMLObjectSet} or @code{JMLValueSet}. The bound
variable type must be compatible with the set comprehension type; in 
particular, the bound variable type must be a subtype of
@code{org.jmlspecs.models.JMLType} if the set comprehension type is 
@code{JMLValueSet}. 

@node JML Operators, Store Refs, Set Comprehensions, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section JML Operators

@cindex operators, added to JML
In this section we describe the various new operators that JML adds to
Java expressions.  The following can all be used in @var{spec-expression}s.

@menu
* Subtype operator::            
* Equivalence and Inequivalence Operators::  
* Forward and Reverse Implication Operators::  
* Lockset Ordering::            
@end menu

@node Subtype operator, Equivalence and Inequivalence Operators, JML Operators, JML Operators
@comment  node-name,  next,  previous,  up
@subsection Subtype operator

@kindex @code{<:}
@cindex subtype relation
@cindex types, comparing
@cindex @code{isAssignableFrom}, method of @code{java.lang.Class}
The relational operator @code{<:} compares two reference types and
returns true when the type on the left is a subtype of the type on the
right [Leino-Nelson-Saxe00].  Although the notation might suggest
otherwise, this operator is also reflexive; a type will compare as
@code{<:} with itself.  In an expression of the form @i{E1} @code{<:}
@i{E2}, both @i{E1} and @i{E2} must have type @code{\TYPE}; since in JML
@code{\TYPE} is the same as @code{java.lang.Class} the expression @i{E1}
@code{<:} @i{E2} means the same thing as the expression
@i{E2}@code{.isAssignableFrom(}@i{E1}@code{)}.
As a result, primitive types are not subtypes of @code{java.lang.Object},
nor of each other, though they are of themselves; so, for example, @code{Integer.TYPE <: Integer.TYPE} is true.

@node Equivalence and Inequivalence Operators, Forward and Reverse Implication Operators, Subtype operator, JML Operators
@comment  node-name,  next,  previous,  up
@subsection Equivalence and Inequivalence Operators

@kindex @code{<==>}
@kindex @code{<=!=>}
The operators @code{<==>} and @code{<=!=>} work only on
boolean-subexpressions and have the same meaning as @code{==} and
@code{!=}, respectively.  However, they have very low precedence, and
so are useful at the top-level of a @var{spec-expression}.
Unlike @code{==} and @code{!=}, the
operators @code{<==>} and @code{<=!=>} are also associative and symmetric.

The notation @code{<==>} can be read ``if and only if''.  It has the same
meaning for Boolean  values as @code{==}, but has a lower precedence.
Therefore, the expression ``@code{\result <==> size == 0}''
means the same thing as ``@code{\result == (size == 0)}''.

The notation @code{<=!=>} can be read ``is not equivalent to''.
It has the same meaning for Boolean  values as @code{!=}, but has a
lower precedence. Therefore, the expression ``@code{\result <=!=> size == 0}''
means the same thing as ``@code{\result != (size == 0)}''.

The expressions on either side of these operators must be of type
@code{boolean}, and the type of the result is also @code{boolean}.

@node Forward and Reverse Implication Operators, Lockset Ordering, Equivalence and Inequivalence Operators, JML Operators
@comment  node-name,  next,  previous,  up
@subsection Forward and Reverse Implication Operators

@kindex @code{==>}
@kindex @code{<==}
@cindex implication, see @code{==>}
@cindex reverse implication, see @code{<==}
@cindex logical implication, see @code{==>}
The operators @code{==>} and @code{<==} work only on
boolean-subexpressions.  They compute forward and reverse
implications, respectively.

For example, the formula @code{raining ==> getsWet} is true if either
@code{raining} is false or @code{getsWet} is true.
The formula @code{getsWet <== raining} means the same thing.
The @code{==>} operator associates to the right, but
the @code{<==} operator associates to the left.
The expressions on either side of these operators must be of type
@code{boolean}, and the type of the result is also @code{boolean}.

These two operators are evaluated in short-circuit fashion, left to right.
Thus, in @code{a ==> b}, if @code{a} is false, then the expression is true
and @code{b} is not evaluated.  Similarly, in @code{a <== b}, if @code{a} is true, the expression is true and @code{b} is not evaluated.  In other words, @code{a ==> b} is equivalent to @code{!a || b} and @code{a <== b} is equivalent to @code{ a || !b}.

Because of this short-circuit evaluation, @code{a ==> b} is not quite 
equivalent to @code{b <== a}.  For example, @code{x != null ==> x.a > 0}
will be true if @code{x} is @code{null}, but @code{x.a>0 <== x != null}
would be undefined (or throw a NullPointerException) if @code{x} is @code{null}.

@node Lockset Ordering,  , Forward and Reverse Implication Operators, JML Operators
@comment  node-name,  next,  previous,  up
@subsection Lockset Ordering

@kindex @code{<}
@kindex @code{<=}
@cindex locking order
JML uses
@code{<} and @code{<=} to test order of locks.
JML extends these two operators, but not
@code{>} and @code{>=}, as comparisons on Objects.
Using @code{synchronized} statements, Java
programs can establish monitor locks to permit only one thread at a
time to execute given sections of code. Any object can be used as
a lock. In order for ESC/Java [Leino-Nelson-Saxe00] to
reason about the possibility of deadlocks among threads, a partial order
must be statically declared on lock objects, with "larger" objects
being objects whose locks should be acquired later.  ESC/Java suggests
the use of @var{axiom-clause}s to declare this partial order.

The @code{<} and @code{<=} operators test this partial order in assertions.
When used in this way, the subexpressions to either side of @code{<}
or @code{<=} must be reference types, and the result is of type boolean.

@node Store Refs,  , JML Operators, Predicates and Specification Expressions
@comment  node-name,  next,  previous,  up
@section Store Refs

The syntax related to the @var{store-ref} production is used in several places.

@cindex @var{store-ref-list}, defined
@cindex @var{store-ref}, defined
@cindex @var{store-ref-expression}, defined
@cindex @var{store-ref-expression}, defined
@cindex @var{store-ref-name}, defined
@cindex @var{store-ref-name-suffix}, defined
@cindex @var{spec-array-ref-expr}, defined
@cindex @var{store-ref-keyword}, defined
@cindex @var{store-ref}, used
@cindex @var{store-ref-expression}, used
@cindex @var{informal-description}, used
@cindex @var{store-ref-keyword}, used
@cindex @var{store-ref-name}, used
@cindex @var{store-ref-name-suffix}, used
@cindex @var{ident}, used
@cindex @var{spec-array-ref-expr}, used
@cindex @var{spec-expression}, used
@kindex @code{,}
@kindex @code{super}
@kindex @code{this}
@kindex @code{.}
@kindex @code{[}
@kindex @code{]}
@kindex @code{*}
@kindex @code{..}
@kindex @code{\nothing}
@kindex @code{\everything}
@kindex @code{\not_specified}
@display
@var{store-ref-list} ::= @var{store-ref-keyword} | @var{store-ref} [ @code{,} @var{store-ref} ] @dots{}
@var{store-ref} ::= @var{store-ref-expression}
        | @var{informal-description} 
@var{store-ref-expression} ::= @var{store-ref-name} [ @var{store-ref-name-suffix} ] @dots{}
@var{store-ref-name} ::= @var{ident} | @code{super} | @code{this}
@var{store-ref-name-suffix} ::= @code{.} @var{ident} | @code{.} @code{this} | `@code{[}' @var{spec-array-ref-expr} `@code{]}' | @code{.} @code{*} 
@var{spec-array-ref-expr} ::= @var{spec-expression}
        | @var{spec-expression} @code{..} @var{spec-expression}
        | @code{*}
@var{store-ref-keyword} ::= @code{\nothing} | @code{\everything} | @code{\not_specified}
@end display

A @var{store-ref} denotes a set of locations in general.

The form @code{\nothing} denotes the empty set of locations.
The form @code{\everything} denotes the set of all locations in the program.
The form @code{\not_specified} denotes a unspecified set of locations,
whose usage is determined by the tool.

The form @i{SR}@code{.*} refers to all fields of the object denoted by @i{SR}.
Similarly, the form @i{A}@code{[*]} refers to all locations of
elements in the array @i{A}.  [[[ And their datagroups? - DRC]]]

Otherwise if a @var{store-ref} refers to a field, it denotes that
field's data group (@pxref{Data Groups}).
If a @var{store-ref} refers to an element or a range of elements, it
refers to all of the named locations in that array.


@c ------- chapter Statements and Annotation Statements ----------------
@node Statements and Annotation Statements, Redundancy, Predicates and Specification Expressions, Top
@comment  node-name,  next,  previous,  up
@chapter Statements and Annotation Statements

JML also defines a number of annotation statements that may be interspersed
with Java statements in the body of a method, constructor, or initialization
block.

The following gives the syntax of statements.
These are the standard Java statements, with the addition of annotations,
the @var{hence-by-statement}, @var{assert-redundantly-statement},
@var{assume-statement}, @var{set-statement}, @var{unreachable-statement},
@var{debug-statement},
and the various forms of @var{model-prog-statement}.
@xref{Model Programs}, for the syntax of @var{model-prog-statement},
which is only allowed in model programs.
[[[ Does this include local class declarations?]]]

@cindex @var{compound-statement}, defined
@cindex @var{statement}, defined
@cindex @var{switch-statement}, defined
@cindex @var{switch-body}, defined
@cindex @var{switch-label-seq}, defined
@cindex @var{switch-label}, defined
@cindex @var{try-block}, defined
@cindex @var{handler}, defined
@cindex @var{statement}, used
@cindex @var{compound-statement}, used
@cindex @var{local-declaration}, used
@cindex @var{ident}, used
@cindex @var{expression}, used
@cindex @var{possibly-annotated-loop}, used
@cindex @var{switch-statement}, used
@cindex @var{try-block}, used
@cindex @var{jml-annotation-statement}, used
@cindex @var{assert-statement}, used
@cindex @var{jml-annotation-statement}, used
@cindex @var{model-prog-statement}, used
@cindex @var{switch-body}, used
@cindex @var{switch-label-seq}, used
@cindex @var{switch-label}, used
@cindex @var{param-declaration}, used
@kindex @code{@{}
@kindex @code{@}}
@kindex @code{;}
@kindex @code{:}
@kindex @code{if}
@kindex @code{(}
@kindex @code{)}
@kindex @code{else}
@kindex @code{break}
@kindex @code{continue}
@kindex @code{return}
@kindex @code{throw}
@kindex @code{throw}
@kindex @code{synchronized}
@kindex @code{switch}
@kindex @code{case}
@kindex @code{default}
@kindex @code{try}
@kindex @code{finally}
@kindex @code{catch}
@display
@var{compound-statement} ::= @code{@{} @var{statement} [ @var{statement} ] @dots{} @code{@}}
@var{statement} ::= @var{compound-statement}
        | @var{local-declaration} @code{;}
        | @var{ident} @code{:} @var{statement}
        | @var{expression} @code{;}
        | @code{if} @code{(} @var{expression} @code{)}
          @var{statement} [ @code{else} @var{statement} ]
        | @var{possibly-annotated-loop}
        | @code{break} [ @var{ident} ] @code{;}
        | @code{continue} [ @var{ident} ] @code{;}
        | @code{return} [ @var{expression} ] @code{;}
        | @var{switch-statement}
        | @var{try-block} 
        | @code{throw} @var{expression} @code{;}
        | @code{synchronized} @code{(} @var{expression} @code{)} @var{statement}
        | @code{;}
        | @var{jml-annotation-statement}
        | @var{assert-statement}
        | @var{jml-annotation-statement}
        | @var{model-prog-statement} @i{// only allowed in model programs}
@var{switch-statement} ::= @code{switch} @code{(} @var{expression} @code{)} @code{@{}
                     [ @var{switch-body} ] @dots{} @code{@}}
@var{switch-body} ::= @var{switch-label-seq} [ @var{statement} ] @dots{}
@var{switch-label-seq} ::= @var{switch-label} [ @var{switch-label} ] @dots{}
@var{switch-label} ::= @code{case} @var{expression} @code{:} | @code{default} @code{:}
@var{try-block} ::= @code{try} @var{compound-statement}
              [ @var{handler} ] @dots{}
              [ @code{finally} @var{compound-statement} ]
@var{handler} ::= @code{catch} @code{(} @var{param-declaration} @code{)} @var{compound-statement}
@end display

The semantics of the Java statements are as in Java 
[Arnold-Gosling-Holmes00] [Gosling-etal00].
More details on the JML-specific features related to statements are
described below.

@menu
* Local Declaration Statements::  
* Loop Statements::             
* Assert Statements::           
* JML Annotation Statements::   
@end menu

@node Local Declaration Statements, Loop Statements, Statements and Annotation Statements, Statements and Annotation Statements
@comment  node-name,  next,  previous,  up
@section Local Declaration Statements

The following is the syntax of local declaration statements.
@xref{Field and Variable Declarations}, for the syntax of @var{variable-decls}.

@cindex @var{local-declaration}, defined
@cindex @var{local-modifiers}, used
@cindex @var{variable-decls}, used
@display
@var{local-declaration} ::= @var{local-modifiers} @var{variable-decls}
@end display

@menu
* Modifiers for Local Declarations::  
@end menu

@node Modifiers for Local Declarations,  , Local Declaration Statements, Local Declaration Statements
@comment  node-name,  next,  previous,  up
@subsection Modifiers for Local Declarations

JML allows the modifiers @code{ghost}, @code{uninitialized}, @code{non_null} and @code{nullable}
in addition 
to Java's @code{final} modifier on local variable declarations.
@xref{Universe Type System}, for the grammar of @var{ownership-modifier}.

@cindex @var{local-modifiers}, defined
@cindex @var{local-modifier}, defined
@cindex @var{local-modifier}, used
@cindex @var{ownership-modifier}, used
@kindex @code{ghost}
@kindex @code{final}
@kindex @code{non_null}
@kindex @code{nullable}
@display
@var{local-modifiers} ::= [ @var{local-modifier} ] @dots{}
@var{local-modifier} ::= @code{ghost} | @code{final}  @code{uninitialized} | @code{non_null} | @code{nullable}
         | @var{ownership-modifier}  @i{// when the Universe type system is on}
@end display

The JML modifiers are discussed to some extent below.
@xref{JML Modifiers for Fields}, for more about these modifiers.

When used as a local variable modifier, @code{uninitialized} means that
the variable should be considered by the tools to be uninitialized, even
if it has an initialization.  This allows the tools to check for uses
before a ``real'' initialization.

A @dfn{local ghost declaration} is a variable declaration with a @code{ghost}
modifier, entirely contained in an annotation.  It introduces a new variable
that may be used in subsequent annotations within the remainder of the 
block in which the declaration appears.  A ghost variable is not used in
program execution as Java variables are, but is used by 
runtime assertion checkers or a static checker to
reason about the execution of the routine body in which the ghost variable
is used.
@itemize @bullet
@item
The variable name may not be already declared as a local variable or
local ghost variable or
as a formal parameter of the routine in which the declaration appears.
@item
Each variable declared may have an initializer; the initializer is in
the scope of the newly declared variable.
@item
The modifiers @code{final}, @code{uninitialized}, @code{non_null} and
@code{nullable} may be used on the ghost declaration.
@end itemize

In the following, the body of the method @code{ghostLocalExample}
contains several examples of local ghost declarations.
@pindex @code{GhostLocals}
@example
@include local/GhostLocals.java.texinfo
@end example

@node Loop Statements, Assert Statements, Local Declaration Statements, Statements and Annotation Statements
@comment  node-name,  next,  previous,  up
@section Loop Statements

The following is the syntax of loop statements.

@cindex @var{possibly-annotated-loop}, defined
@cindex @var{loop-stmt}, defined
@cindex @var{for-init}, defined
@cindex @var{loop-invariant}, used
@cindex @var{variant-function}, used
@cindex @var{ident}, used
@cindex @var{expression}, used
@cindex @var{statement}, used
@cindex @var{for-init}, used
@cindex @var{expression-list}, used
@cindex @var{local-declaration}, used
@kindex @code{:}
@kindex @code{while}
@kindex @code{(}
@kindex @code{)}
@kindex @code{do}
@kindex @code{while}
@kindex @code{for}
@kindex @code{;}
@display
@var{possibly-annotated-loop} ::=
          [ @var{loop-invariant} ] @dots{}
          [ @var{variant-function} ] @dots{}
          [ @var{ident} @code{:} ] @var{loop-stmt}
@var{loop-stmt} ::= @code{while} @code{(} @var{expression} @code{)} @var{statement}
        | @code{do} @var{statement} @code{while} @code{(} @var{expression} @code{)} @code{;}
        | @code{for} @code{(} [ @var{for-init} ] @code{;} [ @var{expression} ] @code{;} [ @var{expression-list} ] @code{)}
             @var{statement}
@var{for-init} ::= @var{local-declaration} | @var{expression-list}
@end display

In JML a loop statement can be annotated with one or more loop
invariants, and one or more variant functions.  The following class
contains an example in the middle of the method @code{sumArray}.
This example has a @code{while} loop with two loop invariants, which
follow the keyword @code{maintaining}, and a single variant function,
which follows the keyword @code{decreasing}.  The invariants and
variant function are written above the loop itself.
The first loop invariant describes the range that the variable
@code{i} can take, and the second relates @code{i} and the value in
@code{sum}. 

@pindex @code{SumArrayLoop}
@example
@include local/SumArrayLoop.java.texinfo
@end example

At the end of the loop, the negation of the loop's test expression and
the loop invariants hold.  This is shown by the assertions after the loop.

Loop invariants and variant functions are discussed in more detail below.
(Thanks to K. Rustan M. Leino, Claude Marche, and Steve M. Shaner
for discussions on this topic, including details of the semantics.)

@menu
* Loop Invariants::             
* Loop Variant Functions::      
@end menu

@node Loop Invariants, Loop Variant Functions, Loop Statements, Loop Statements
@comment  node-name,  next,  previous,  up
@subsection Loop Invariants

A loop can specify one or more loop invariants, using the following syntax.

@cindex @var{loop-invariant}, defined
@cindex @var{maintaining-keyword}, defined
@cindex @var{maintaining-keyword}, used
@cindex @var{predicate}, used
@kindex @code{;}
@kindex @code{maintaining}
@kindex @code{maintaining_redundantly}
@kindex @code{loop_invariant}
@kindex @code{loop_invariant_redundantly}
@display
@var{loop-invariant} ::= @var{maintaining-keyword} @var{predicate} @code{;}
@var{maintaining-keyword} ::= @code{maintaining} | @code{maintaining_redundantly}
        | @code{loop_invariant} | @code{loop_invariant_redundantly}
@end display

A @var{loop-invariant} is used to help prove partial correctness of a
loop statement. 

The meaning of a loop, which does not contain a use of @code{break} that
exits the loop itself (as opposed to some inner loop), such as
@display
  //@@ maintaining @i{J};
  while (@i{B}) @{ @i{S} @}
@end display
is as follows.
@display
  while (true) @{
    //@@ assert @i{J};
    if (!(@i{B})) @{ break; @}
    @i{S}
  @}
@end display
So that the loop invariant holds at the beginning of each iteration of
the loop.

The rule for deducing what is true after the loop can be stated simply
if the loop does not contain any @code{break} statements that exit the loop,
and if the loop test, @code{@i{B}}, is both a Java @var{expression} and a JML
@var{specification-expression}
(@pxref{Specification Expressions}).  (This means that @code{@i{B}} is
side-effect free.)
For such loops, the rule is that, after a loop with condition
@code{@i{B}} and invariant @code{@i{J}} 
the negation of the condition, @code{(!@i{B})}, conjoined with the invariant,
@code{@i{J}}, holds.
This is summarized in the following program schema.

@display
   //@@ maintaining @i{J};
   while (@i{B}) @{  // @i{assuming B has no side effects}
     @i{S}
   @}
   //@ assert !(@i{B}) && @i{J};
@end display

@kindex @code{break}, loops containing
@cindex loop, exiting via @code{break}
If the loop contains a @code{break} statement that exits the loop
itself, then more detailed reasoning is necessary to establish what
will be true after the loop.  The intended condition that should be
true after the loop when it is exited via a @code{break} statement can
be recorded in the code using an @code{assert} statement.
For example, if the loop has the form:
@display
 //@@ maintaining @i{J};
 while (true) @{
   @i{S1}
   if (@i{C}) @{
      @i{S2}
      //@@ assert @i{Q};
      break;
   @}
   @i{S3}
 @}
@end display
then after the loop the asserted condition, @code{@i{Q}}, should hold,
assuming there are no other @code{break} statements that exit the loop.


@node Loop Variant Functions,  , Loop Invariants, Loop Statements
@comment  node-name,  next,  previous,  up
@subsection Loop Variant Functions

A loop can also specify one or more variant functions, using the
following syntax.

@cindex @var{variant-function}, defined
@cindex @var{decreasing-keyword}, defined
@cindex @var{decreasing-keyword}, used
@cindex @var{spec-expression}, used
@kindex @code{;}
@kindex @code{decreasing}
@kindex @code{decreasing_redundantly}
@kindex @code{decreases}
@kindex @code{decreases_redundantly}
@display
@var{variant-function} ::= @var{decreasing-keyword} @var{spec-expression} @code{;}
@var{decreasing-keyword} ::= @code{decreasing} | @code{decreasing_redundantly}
        | @code{decreases} | @code{decreases_redundantly}
@end display

A @var{variant-function} is used to help prove termination of a loop statement.
It specifies an expression of type @code{long} or @code{int} that must
be no less than 0 when the loop is executing, and must decrease by at
least one (1) each time around the loop.

The meaning of a loop such as
@display
 //@@ decreasing @i{E};
 while (@i{B}) @{ @i{S} @}
@end display
in which @i{S} does not use @code{continue}, is as follows.
@display
  while (true) @{
    long vf = @i{E};      // assuming vf is a fresh variable name
    if (!(@i{B})) @{ break; @}
    @i{S}
    //@@ assert 0 <= vf;
    //@@ assert @i{E} < vf;
  @}
@end display

@kindex @code{continue}
If the loop contains a @code{continue} statement,
then the loop variant is checked just before each use of
@code{continue}.
For example, if the loop has the form:
@display
 //@@ decreasing @i{E};
 while (@i{B}) @{ @i{S1} if (@i{C}) @{ @i{S2} continue; @} @i{S3} @}
@end display
then the meaning is as follows.
@display
  while (true) @{
    long vf = @i{E};      // assuming vf is a fresh variable name
    if (!(@i{B})) @{ break; @}
    @i{S1}
    if (@i{C}) @{
       @i{S2}
       //@@ assert 0 <= vf;
       //@@ assert @i{E} < vf;
       continue;
    @}
    @i{S3}
    //@@ assert 0 <= vf;
    //@@ assert @i{E} < vf;
  @}
@end display

@node Assert Statements, JML Annotation Statements, Loop Statements, Statements and Annotation Statements
@comment  node-name,  next,  previous,  up
@section Assert Statements

The syntax of assert and redundant assert statements is as follows.

@cindex @var{assert-statement}, defined
@cindex @var{assert-redundantly-statement}, defined
@cindex @var{expression}, used
@cindex @var{predicate}, used
@kindex @code{assert}
@kindex @code{assert_redundantly}
@kindex @code{:}
@kindex @code{;}
@display
@var{assert-statement} ::= @code{assert} @var{expression} [ @code{:} @var{expression} ] @code{;}
        | @code{assert} @var{predicate} [ @code{:} @var{expression} ] @code{;}
@var{assert-redundantly-statement} ::= @code{assert_redundantly} @var{predicate}
                                 [ @code{:} @var{expression} ] @code{;}
@end display

@cindex @var{assert-statement}, in JML vs. Java
@kindex @code{assert}, in JML vs. Java
Note that Java (as of J2SDK 1.4) also has its own @code{assert}
statement.  For this reason JML distinguishes between assert
statements that occur inside and outside annotations.

Outside an annotation, an assert statement is a Java
assert statement, whose syntax follows the first
@var{assert-statement} production above.
Thus in such an assert statement, the first @var{expression} can have side
effects (potentially, although it shouldn't).  The second expression
is supposed to have type @code{String}, and will be used in a message
should the assertion fail.

Inside an annotation, an assert statement is a JML assert statement,
and the second syntax is used for @var{assert-statement}.  Thus instead of an @var{expression}
before the optional colon, there is a JML @var{predicate}.
This predicate cannot have side effects, but can use the various JML
extensions to the Java expression syntax
(@pxref{Specification Expressions}, for details.)
As in a Java assert statement, the optional expression that follows
the colon must be a @code{String}, which is printed if the assertion
fails.

An assert statements tells JML to check that the specified
@var{predicate} is true at the given point in the program.  The
runtime assertion checker checks such assertions during execution of
the program, when control reaches the assert statement.  Other tools,
such as verification tools, will try to prove that the assertion
always holds at that program point, for every possible execution.

The @var{assert-redundantly-statement} must appear in an annotation.
It has the same semantics as the JML form of an assert statement, but
is marked as redundant.  Thus it would be used to call attention to
some property, but need not be checked.

@node JML Annotation Statements,  , Assert Statements, Statements and Annotation Statements
@comment  node-name,  next,  previous,  up
@section JML Annotation Statements

The following gives the syntax of JML annotation statements.  These
can appear anywhere in normal Java code, but must be enclosed in
annotations.
@xref{Assert Statements}, for the syntax of the
@var{assert-redundantly-statement}.
@xref{Model Programs}, for the syntax of additional statements
that can only be used in model programs.

@cindex @var{jml-annotation-statement}, defined
@cindex @var{assert-redundantly-statement}, used
@cindex @var{assume-statement}, used
@cindex @var{hence-by-statement}, used
@cindex @var{set-statement}, used
@cindex @var{refining-statement}, used
@cindex @var{unreachable-statement}, used
@cindex @var{debug-statement}, used
@display
@var{jml-annotation-statement} ::= @var{assert-redundantly-statement}
        | @var{assume-statement}
        | @var{hence-by-statement}
        | @var{set-statement}
        | @var{refining-statement}
        | @var{unreachable-statement}
        | @var{debug-statement}
@end display

@menu
* Assume Statements::           
* Set Statements::              
* Refining Statements::         
* Unreachable Statements::      
* Debug Statements::            
* Hence By Statements::         
@end menu

@node Assume Statements, Set Statements, JML Annotation Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Assume Statements

The syntax of an assume statement is as follows.
As in a Java assert statement, the optional expression that follows
the colon must be a @code{String}, which is printed if the assumption fails.

@cindex @var{assume-statement}, defined
@cindex @var{assume-keyword}, defined
@cindex @var{assume-keyword}, used
@cindex @var{predicate}, used
@cindex @var{expression}, used
@kindex @code{:}
@kindex @code{;}
@kindex @code{assume}
@kindex @code{assume_redundantly}
@display
@var{assume-statement} ::= @var{assume-keyword} @var{predicate}
                     [ @code{:} @var{expression} ] @code{;}
@var{assume-keyword} ::= @code{assume} | @code{assume_redundantly}
@end display

In runtime assertion checking, assumptions are checked in the same way
that assert statements are checked (@pxref{Assert Statements}).

However, in static analysis tools, the assume statement is used to
tell the tool that the given predicate is assumed to be true, and thus
need not be checked.  

@node Set Statements, Refining Statements, Assume Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Set Statements

The syntax of a set statement is as follows.
@xref{Expressions}, for the syntax of @var{assignment-expr}.

@cindex @var{set-statement}, defined
@cindex  @var{assignment-expr}, used
@kindex @code{set}
@kindex @code{;}
@display
@var{set-statement} ::= @code{set} @var{assignment-expr} @code{;}
@end display

A set statement is the equivalent of an assignment statement but is within
an annotation.  It is used to assign a value to a ghost variable or to a
ghost field.  A set statement serves to assist the static checker in 
reasoning about the execution of the routine body in which it appears.
@itemize @bullet
@item the target of the set statement must be a ghost variable or a ghost field
@item the right-hand-side of the set statement must be pure (not have side effects)
@end itemize
@*@strong{Examples:}
@example
        //@@ set i = 0;
        //@@ set collection.elementType = \type(int);
@end example

[[[ Questions: must the rhs be pure?  Should we allow an arbitrary statement, not just an assignment? such as set ++i; or set i += 5; ]]]

@node Refining Statements, Unreachable Statements, Set Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Refining Statements

@cindex refining statement
@cindex statement, refining
The syntax of a refining statement is as follows.
@xref{Specification Statements},
for the syntax of @var{spec-statement} and @var{generic-spec-statement-case}.
@xref{Statements and Annotation Statements}, 
for the syntax of @var{statement}.

@cindex @var{refining-statement}, defined
@cindex @var{spec-statement}, used
@cindex @var{generic-spec-statement-case}, used
@cindex @var{statement}, used
@kindex @code{refining}
@display
@var{refining-statement} ::= @code{refining} @var{spec-statement} @var{statement}
        | @code{refining} @var{generic-spec-statement-case} @var{statement}
@end display

@cindex specification, in refining statement
@cindex body, of refining statement
A refining statement allows one to annotate a specification with
a specification.  It has two parts, a @dfn{specification} and a @dfn{body}.
The specification part can be either a
@var{spec-statement} (@pxref{Specification Statements}), 
which includes the grammar for a heavyweight specification case, 
or a @var{generic-spec-statement-case} (@pxref{Specification Statements}),
which includes the grammar for a lightweight specification case.
The body is simply a statement.  In particular, the body can be a
@var{compound-statement} or a @var{jml-annotation-statement},
including a nested @var{refining-statement}.

Annotating the body with a specification is a way of collecting all
the specification information about the statement in one place.
Giving such an annotation is especially useful for framing, 
e.g., writing @var{assignable-clause}s.
For example, by using a refining statement, one can
write an assignable clause for a loop statement 
or for the statement in the body of a loop.

Refining statements are also used in connection with model program
specification cases (@pxref{Model Programs}).
Within the implementation of a method with such a model program
specification, a refining statement indicates exactly what
@var{spec-statement} is implemented by its body,
since its specification part would be exactly that @var{spec-statement}.
This is helpful for ``matching'' the implementation against the model
program specification [Shaner-Leavens-Naumann07].

Note that the scope of any declarations made 
in the specification part of a refining statement are limited to the
specification part, and do not extend into the body.
Thus a refining statement is type correct if each of its subparts is
type correct, using the surrounding context 
for separately type checking the specification and body.

The meaning of a refining statement of the form 
@code{refining} @i{S} @i{B}
is that the body @i{B} must refine the specification given in @i{S}.
This means that @i{B} has to obey all the specifications given in @i{S}.
For example, @i{B} may not assume a stronger precondition than that
given by @i{S}.
(Standard defaults are used for omitted clauses in the specification
part of a refining statement; thus, if there is no requires clause in
a @var{spec-statement}, then the precondition defaults to true.)
Similarly, @i{B} may not assign to locations that are not permitted to
be assigned to by @i{S}, and, assuming @i{S}'s precondition held, then
when @i{B} terminates normally it must establish @i{S}'s normal
postcondition.
@xref{Method Specifications}, for more about what it means to satisfy
such a specification.

When @code{\old()} or @code{\pre()} are used in the specification part
of a refining statement, they have the same meaning as in a
specification statement (@pxref{Specification Statements}).

In execution, a refining statement of the form 
@code{refining} @i{S} @i{B} just executes its body @i{B}.
For this reason, typically the 
@code{refining} keyword and the specification @i{S}
would be in JML annotations, 
but the body @i{B} would be normal Java code (outside of any annotation).

@xref{Model Programs}, for more examples.

@node Unreachable Statements, Debug Statements, Refining Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Unreachable Statements

The syntax of the @code{unreachable} statement is as follows.

@cindex @var{unreachable-statement}, defined
@kindex @code{unreachable}
@kindex @code{;}
@display
@var{unreachable-statement} ::= @code{unreachable} @code{;}
@end display

The @code{unreachable} statement is an annotation that asserts that the
control flow of a routine will never reach that point in the program.  It is
equivalent to the annotation @code{assert false}.  If control flow does reach an
@code{unreachable} statement, a tool that checks (by reasoning or at runtime)
the behavior of the routine should issue an error of some kind.
The following is an example:
@example
        if (true) @{
                ...
        @} else @{
                //@@ unreachable;
        @}
@end example

@node Debug Statements, Hence By Statements, Unreachable Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Debug Statements

The syntax of the @code{debug} statement is as follows.
@xref{Expressions}, for the syntax of @var{expression}.

@cindex @var{debug-statement}, defined
@cindex @var{expression}, used
@kindex @code{debug}
@kindex @code{;}
@display
@var{debug-statement} ::= @code{debug} @var{expression} @code{;}
@end display

A @code{debug} statement is the equivalent of an expression statement
but is within an annotation. Thus, features visible only in the JML
scope can also appear in the @code{debug} statement. Examples of such
features include ghost variables, model methods, @code{spec_public}
fields, and JML-specific expression constructs, to name a few.

The main use of the @code{debug} statement is to help debugging
specifications, e.g., by printing the value of a JML expression, as
shown below.

@example
        //@@ debug System.err.println(x);
@end example

In the above example, the variable @code{x} may be a ghost variable.
Note that using @code{System.err} automatically flushes output, unlike
@code{System.out}.  This flushing of output is helpful for debugging.

As shown in the above example, expressions with side-effects are
allowed in the @code{debug} statement. These include not only methods
with side-effects but also increment (@code{++}) and decrement
(@code{--}) operators and various forms of assignment expressions
(e.g., @code{=}, @code{+=}, etc.). Thus, the @code{debug} statement
can also be used to assign a value to a variable, or mutate the state
of an object.

@example
        //@@ debug x = x + 1;
        //@@ debug aList.add(y);
@end example

However, a model variable cannot be assigned to, nor can its state be
mutated by using the @code{debug} statement, as its value is given by
a @code{represents} clause (@pxref{Represents Clauses}).

There is no restriction on the type of expression allowed in the
@code{debug} statement.

Tools should allow debug statements to be turned on or off easily.
Thus programmers should not count on debug statements being executed.
For example, if one needs to assign to a ghost variable, the proper way to
do it is to use a @var{set-statement} (@pxref{Set Statements}),
which would execute even if debug statements are not being executed.

@node Hence By Statements,  , Debug Statements, JML Annotation Statements
@comment  node-name,  next,  previous,  up
@subsection Hence By Statements

The syntax of the @code{hence_by} statement is as follows.

@cindex @var{hence-by-statement}, defined
@cindex @var{hence-by-keyword}, defined
@cindex @var{hence-by-keyword}, used
@cindex @var{predicate}, used
@kindex @code{;}
@kindex @code{hence_by}
@kindex @code{hence_by_redundantly}
@display
@var{hence-by-statement} ::= @var{hence-by-keyword} @var{predicate} @code{;}
@var{hence-by-keyword} ::= @code{hence_by} | @code{hence_by_redundantly}
@end display

The @code{hence_by} statement is used to record reasoning when writing
a proof by intermittent assertions.  It would normally be used between
two assert statements (@pxref{Assert Statements}) or between two
assume statements (@pxref{Assume Statements}).

[[[Needs example.]]]

@c ------- chapter Redundancy ----------------
@node Redundancy, Model Programs, Statements and Annotation Statements, Top
@comment  node-name,  next,  previous,  up
@chapter Redundancy

@cindex Leavens
@cindex Baker
JML has several features that allow the specification of implications [Tan95]
and examples [Leavens97c] [Leavens-Baker99].  
They are redundant in the sense that they do not constrain an
implementation directly.
Instead, they are useful for pointing out consequences to the specification's
readers, for example to draw attention to some consequences of the
specification of a method, or to illustrate it by an example.

In addition to clauses of the form @i{X}@code{_redundantly}, such as
@code{requires_redundantly}, @code{ensures_redundantly}, etc., there
are two sections of a method specification that are devoted to such
redundant specifications.
These sections of a method specification are described by the
following grammar. 

@cindex @var{redundant-spec}, defined
@cindex @var{implications}, used
@cindex @var{examples}, used
@display
@var{redundant-spec} ::= @var{implications} [ @var{examples} ] | @var{examples}
@end display

The two subsections below explain these features.  The description of 
clauses of the form @i{X}@code{_redundantly} is contained in the first
section.

@menu
* Redundant Implications and Redundantly Clauses::  
* Redundant Examples::          
@end menu


@node Redundant Implications and Redundantly Clauses, Redundant Examples, Redundancy, Redundancy
@comment  node-name,  next,  previous,  up
@section Redundant Implications and Redundantly Clauses

@cindex redundant implication
@cindex implication, redundant
@cindex claims, about a specification
@cindex Leavens
@cindex Baker
A @dfn{redudant implication} is a way of stating a claim about a
specification.
By itself it does not constrain an implication, but can be thought of
a stating a theorem to be proven about a specification.
Such redundant implications are useful for drawing the reader's
attention to some point that might otherwise be overlooked, or that is
important for rhetorical purposes [Leavens-Baker99].

Redundant implications can be specified in two ways in JML.
The first is by using clauses of the form 
@i{X}@code{_redundantly}.
The second is by use of the @var{implications} section of a method
specification, which starts with the keyword @code{implies_that}.
(@xref{Organization of Method Specifications}, for the syntax of 
@var{spec-case-seq}.)

@cindex @var{implications}, defined
@cindex @var{spec-case-seq}, used
@kindex @code{implies_that}
@display
@var{implications} ::= @code{implies_that} @var{spec-case-seq}
@end display

The @var{implications} section of a method
specification says that for each visibility level @i{V},
and for each @var{spec-case} of visibility @i{V} in its 
@var{spec-case-seq}, that @var{spec-case}
is refined by the entire non-redundant specification of the method that
applies at visibility level @i{V}.
Thus every correct implementation of the non-redundant specification 
must satisfy each of the @var{spec-case}s in the
@var{implications} section.

For example, suppose that the (desugared) meaning of the non-redundant
part of a method's specification has the form:

@example
@i{V} behavior        // non-redundant
   requires @i{Pre};
   assignable @i{x1}, @i{x2};
   ensures @i{NormPost};
   signals_only @i{Ex1};
   signals (Exception e) @i{ExPost};
@end example

and suppose that one of the @var{spec-case}s in its @var{implications}
section has the following (desugared) meaning:

@example
@i{V} behavior        // redundant
   requires @i{RedPre};
   assignable @i{x1}, @i{x2};
   ensures @i{RedNormPost};
   signals_only @i{Ex1};
   signals (Exception e) @i{RedExPost};
@end example

Then it must be the case that
(by definition of refinement for method specifications [Leavens-Naumann06])
the following implications hold:

@itemize @bullet
@item 
@code{\old(@i{RedPre}) ==> @i{Pre}},

@item
@code{(\old(@i{RedPre}) && @i{NormPost}) ==> @i{RedNormPost}}, and

@item
@code{(\old(@i{RedPre}) && @i{ExPost}) ==> @i{RedExPost}}.
@end itemize

These implications are only sensible if the
specifications have the same visibility (@code{@i{V}}), 
the same @code{assignable} clauses,
and the same @code{signals_only} clauses.
@cindex assignable, in comparing specifications
@cindex signals_only, in comparing specifications
If the @code{assignable} clauses differ, one can adjust by adding elements to
the non-redundant parts of the assignable clause, to widen it,
but preserve its meaning by adding restrictions 
(e.g., using the @code{\only_assigned} predicate), to the postconditions.
Similar adjustments can be made to the non-redundant
@code{signals_only} clause, by adding exceptions (or supertypes of
exceptions) to the non-redundant @code{signals_only},
preserving its meaning by adding restrictions in the @code{signals} clause.

@cindex Tan
@cindex procedure claims
@cindex claim, procedure
@cindex redundant clause
@kindex @code{redundantly}
Redundant clauses are a syntactic variant of Tan's procedure claims
[Tan95].
The meaning of a redundant clause,
of the form @i{X}@code{_redundantly} is also defined as making a claim
about implications, but in this case only one simple implication.
The claim is that the predicate in the redundant clause follows from
the meaning of the non-redundant @i{X} clauses.

As an example, consider the following requires clauses.

@example
   requires @i{Pre};
   requires_redundantly @i{RedPre};
@end example

These state the claim that @code{@i{Pre} ==> @i{RedPre}}.
That is, in all pre-states, whenever @code{@i{Pre}} is true, then
@code{@i{RedPre}} must be true.
The same pattern holds for all other clauses and their redundant
counterparts, including ensures clauses, signals clauses (which must
first be standardized to have the same exception
[Raghavan-Leavens05]), invariants, etc.

For example, recall that multiple clauses are conjoined, and thus

@example
   ensures @i{Q1};
   ensures @i{Q2};
   ensures_redundantly @i{RedQ1};
   ensures_redundantly @i{RedQ2};
@end example

@noindent
is equivalent to

@example
   ensures @i{Q1} && @i{Q2};
   ensures_redundantly @i{RedQ1} && @i{RedQ2};
@end example

In this example, the claim stated is that:
@example
  (@i{Q1} && @i{Q2}) ==> (@i{RedQ1} && @i{RedQ2}).
@end example

If one is using a theorem prover, then these implications can be
thought of as theorems to prove (in the context of the overall class
or interface specification).

A runtime assertion checker is free to check the specifications in
the @var{implications} section,
since they must all hold, as they should be refined by the
non-redundant specification.
If a redundant specification case in a method's @var{implications}
section is violated, this could indicate that either:
(a) the implications
described above do not hold, or that 
(b) there is a violation of the
specification by the caller (e.g., if the precondition does not hold)
or by the implementation of the method (e.g., if the normal
postcondition does not hold).

[[[Needs concrete examples.]]]

@node Redundant Examples,  , Redundant Implications and Redundantly Clauses, Redundancy
@comment  node-name,  next,  previous,  up
@section Redundant Examples

@cindex examples, specification of
@cindex specifying examples
@cindex Leavens
@cindex Baker
@cindex Ruby
Examples are, used to point out, to readers or testing tools,
particular cases of a method specification [Leavens97c]
[Leavens-Baker99] [Leavens-Baker-Ruby06].
The following gives the syntax of the @var{examples} section of a
method specification.
This section starts with the @code{for_example} keyword, and includes
one or more @var{example}s.
Each @var{example} is much like a @var{spec-case}
(@pxref{Organization of Method Specifications}),
but uses various @code{example} keywords instead of @code{behavior}
keywords, and does not permit @var{model-program} cases.

@cindex @var{examples}, defined
@cindex @var{example}, defined
@cindex @var{exceptional-example-body}, defined
@cindex @var{normal-example-body}, defined
@cindex @var{example}, used
@cindex @var{privacy}, used
@cindex @code{example}, used
@cindex @var{spec-var-decls}, used
@cindex @var{spec-header}, used
@cindex @var{simple-spec-body}, used
@cindex @var{exceptional-example-body}, used
@cindex @code{exceptional_example}, used
@cindex @code{normal_example}, used
@cindex @var{normal-example-body}, used
@cindex @var{exceptional-spec-clause}, used
@cindex @var{normal-spec-clause}, used
@kindex @code{for_example}
@kindex @code{also}
@kindex @code{example}
@kindex @code{exceptional_example}
@kindex @code{normal_example}
@display
@var{examples} ::= @code{for_example} @var{example} [ @code{also} @var{example} ] @dots{}
@var{example} ::= [ [ @var{privacy} ] @code{example} ]
            [ @var{spec-var-decls} ]
            [ @var{spec-header} ]
            @var{simple-spec-body}
        | [ @var{privacy} ] @code{exceptional_example}
          [ @var{spec-var-decls} ]
          @var{spec-header}
          [ @var{exceptional-example-body} ]
        | [ @var{privacy} ] @code{exceptional_example}
          [ @var{spec-var-decls} ]
          @var{exceptional-example-body}
        | [ @var{privacy} ] @code{normal_example}
          [ @var{spec-var-decls} ]
          @var{spec-header}
          [ @var{normal-example-body} ]
        | [ @var{privacy} ] @code{normal_example}
          [ @var{spec-var-decls} ]
          @var{normal-example-body}
@var{exceptional-example-body} ::= @var{exceptional-spec-clause}
                             [ @var{exceptional-spec-clause} ] @dots{}
@var{normal-example-body} ::= @var{normal-spec-clause}
                        [ @var{normal-spec-clause} ] @dots{}
@end display

As in method @var{spec-case}s
(@pxref{Organization of Method Specifications})
there are both heavyweight and lightweight examples.
@cindex lightweight example
@cindex example, lightweight
A @dfn{lightweight} example does not use one of the @code{example}
keywords.
@cindex heavyweight example
@cindex example, heavyweight
A @dfn{heavyweight} example uses one of the example keywords.
As with @var{spec-case}s, only heavyweight examples can have a
specified visibility; lightweight examples all have the same
visibility as the method (or constructor) being specified.

@cindex example, defaults for
The defaults for omitted clauses in lightweight @var{example}s are the
same as those for omitted clauses in lightweight @var{spec-case}s.
Similarly, heavyweight @var{example}s have the same defaults as heavyweight
@var{spec-case}s. 
(@xref{Semantics of flat behavior specification cases}, for the
defaults for a lightweight and heavyweight specification cases.)

@cindex examples, checking
@cindex examples, semantics
@cindex examples, meaning
@cindex semantics, of examples
As described in the ``Preliminary Design of JML''
[Leavens-Baker-Ruby06] (section 2.3.2.1)
``the specification in each example should be such that:
@itemize @bullet
@item
the example's precondition implies
the precondition of the expanded meaning of the specified behaviors,

@item
the example's assignable clause
specifies a subset of the locations that are assignable
according to the expanded meaning of the specified behaviors, and

@item
assuming the example's assignable clause,
the conjunction of:
@itemize @bullet
@item
the example's precondition (wrapped by @code{\old()}),

@item
the precondition of the expanded meaning of the specified behaviors
(also wrapped by @code{\old()}),
and

@item
the postcondition of the expanded meaning of the specified behaviors
@end itemize
should be equivalent to the example's postcondition.
@end itemize
Requiring equivalence to the example's postcondition
means that it can serve as a test oracle for the
inputs described by the example's precondition.
If there is only one specified @code{public normal_behavior}''
specification case
``and if there are no preconditions and assignable clauses,
then the example's postcondition should the equivalent to
the conjunction of the example's precondition
and the postcondition of the @code{public normal_behavior} specification.''

[[[(Needs concrete examples :-)]]]

@c ------- chapter Model Programs ----------------
@node Model Programs, Specification for Subtypes, Redundancy, Top
@comment  node-name,  next,  previous,  up
@chapter Model Programs

@cindex refinement calculus
@cindex Back
@cindex von Wright
@cindex Buechi
@cindex Morgan
@cindex Morris
This chapter discusses JML's model programs, which 
are adapted from the refinement calculus
[Back88] [Back-vonWright89a] [Buechi-Weck00] [Morgan94] [Morris87].
Details of JML's design and semantics for model program specifications
are described in a recent paper [Shaner-Leavens-Naumann07].

@menu
* Ideas Behind Model Programs::  
* Extracting Model Program Specifications::  
* Details of Model Programs::   
* Nondeterministic Choice Statement::  
* Nondeterministic If Statement::  
* Specification Statements::    
@end menu

@node Ideas Behind Model Programs, Extracting Model Program Specifications, Model Programs, Model Programs
@comment  node-name,  next,  previous,  up
@section Ideas Behind Model Programs

@cindex model program, ideas behind
@cindex abstract algorithm
The basic idea of a model program is that it is a specification that is
written as an abstract algorithm.  Such an abstract algorithm 
specifies a method in the sense that the method's execution should be
a refinement of the model program.

@cindex B@"{u}chi
@cindex Weck
@cindex grey-box specification
@cindex higher-order method specification
JML adopts ideas from B@"{u}chi and Weck's "grey-box approach" 
to specification [Buechi-Weck00] [Buechi00].
@cindex refinement, of model program specification
However, JML structurally restricts the notion of 
refinement by not permitting all implementations with
behavior that refines the model program, but only allowing
implementations that syntactically match the model program
@cindex Shaner
@cindex Leavens
@cindex Naumann
[Shaner-Leavens-Naumann07].
The current JML notion of matching uses @var{refining-statement}s
(@pxref{Refining Statements}), as explained below.
This turns out to be a simple and easy to understand
technique for specifying and verifying both 
higher-order features and callbacks.

@cindex Leavens
@cindex Dhara
Consider the following example (from a survey on behavioral subtyping by
Leavens and Dhara [Leavens-Dhara00]).
In this example, both the methods are specified using model programs,
which are explained below.

@pindex @code{Directory}
@example
@include dirobserver/Directory.java.texinfo
@end example

@cindex specification statement
@kindex @code{normal_behavior}
Both model programs in the above example are formed from a specification
statement, which begins with the keyword @code{normal_behavior} in these
examples, and a for-loop.  The key event in the for loop bodies is a
method call to a method (@code{addNotification}
or @code{removeNotification}).  These calls must occur in a state
equivalent to the one reached in the model program for the
implementation to be legal.

The specification statements abstract away part of a correct implementation.
The @code{normal_behavior} statements in these examples both have a
precondition, a frame axiom, and a postcondition.  These mean that the
statements that they abstract away from must be able to, in any state
satisfying the precondition, finish in a state satisfying the
postcondition, while only assigning to the locations (and their
dependees) named in the frame axiom.
For example, the first specification statement says that whenever
@code{in_notifier} is false, @code{n} is not null and not empty, and
@code{f} is not null, then this part of the method can assign to
@code{entries} something that isn't null and that is equal to the old
value of @code{entries} extended with a pair consisting of the string
@code{n} and the file @code{f}.

The model field @code{entries}, of type @code{JMLValueToObjectMap},
is declared in the supertype @code{RODirectory} [Leavens-Dhara00].

@cindex matching, of implemetations to model programs
@cindex model program, matching of
@cindex refining statement
Implementations of model programs must match each specification
statement in a model program with a corresponding refining statement.
In the matching refining statement, 
the specification part must be textually equal to the specification statement.
The body of the refining statement must thus implement the given
specification for that statement
(@pxref{Refining Statements}).

@node Extracting Model Program Specifications, Details of Model Programs, Ideas Behind Model Programs, Model Programs
@comment  node-name,  next,  previous,  up
@section Extracting Model Program Specifications

@kindex @code{extract}
Since refining statements contain both specifications and
implementations, it is possible to extract a model program
specification from an implementation with (zero or more) refining
statements. This is done by using the modifier @code{extract} on the
method [Shaner-Leavens-Naumann07].
[[[Give example.]]]

@node Details of Model Programs, Nondeterministic Choice Statement, Extracting Model Program Specifications, Model Programs
@comment  node-name,  next,  previous,  up
@section Details of Model Programs

The following gives the syntax of model programs.
@xref{Statements and Annotation Statements}, for the parts of the
syntax of statements that are unchanged from Java.  The
@var{jml-compound-statement} and 
@var{jml-statement} syntax is the same as the @var{compound-statement}
and @var{statement} syntax, except that @var{model-prog-statement}s
are not flagged as errors within the @var{jml-compound-statement} and
@var{jml-statement}s.

@cindex @var{model-program}, defined
@cindex @var{jml-compound-statement}, defined
@cindex @var{jml-statement}, defined
@cindex @var{model-prog-statement}, defined
@cindex @var{privacy}, used
@kindex @code{code}
@cindex @var{jml-compound-statement}, used
@cindex @var{compound-statement}, used
@cindex @var{statement}, used
@cindex @var{nondeterministic-choice}, used
@cindex @var{nondeterministic-if}, used
@cindex @var{spec-statement}, used
@cindex @var{invariant}, used
@kindex @code{model_program}
@display
@var{model-program} ::= [ @var{privacy} ] [ @code{code} ] @code{model_program} 
                  @var{jml-compound-statement}
@var{jml-compound-statement} ::= @var{compound-statement}
@var{jml-statement} ::= @var{statement}
@var{model-prog-statement} ::= @var{nondeterministic-choice}
        | @var{nondeterministic-if}
        | @var{spec-statement}
        | @var{invariant}
@end display

@node Nondeterministic Choice Statement, Nondeterministic If Statement, Details of Model Programs, Model Programs
@c  node-name,  next,  previous,  up
@section Nondeterministic Choice Statement

The syntax of the @var{nondeterministic-choice} statement is as
follows.

@cindex @var{nondeterministic-choice}, defined
@cindex @var{alternative-statements}, defined
@cindex @var{alternative-statements}, used
@cindex @var{jml-compound-statement}, used
@kindex @code{or}
@kindex @code{choose}
@display
@var{nondeterministic-choice} ::= @code{choose} @var{alternative-statements}
@var{alternative-statements} ::= @var{jml-compound-statement}
             [ @code{or} @var{jml-compound-statement} ] @dots{}
@end display

The meaning is that a correct implementation can dynamically execute
(e.g., with an @code{if} or @code{switch} statement), one of the alternatives.
Code may also make a static choice of one of the alternatives.

@node Nondeterministic If Statement, Specification Statements, Nondeterministic Choice Statement, Model Programs
@c  node-name,  next,  previous,  up
@section Nondeterministic If Statement

@cindex @var{nondeterministic-if}, defined
@cindex @var{guarded-statements}, defined
@cindex @var{guarded-statement}, defined
@cindex @var{guarded-statements}, used
@cindex @var{jml-compound-statement}, used
@cindex @var{guarded-statement}, used
@cindex @var{assume-statement}, used
@cindex @var{jml-statement}, used
@kindex @code{choose_if}
@kindex @code{else}
@kindex @code{or}
@kindex @code{@{}
@kindex @code{@}}
@display
@var{nondeterministic-if} ::= @code{choose_if} @var{guarded-statements}
             [ @code{else} @var{jml-compound-statement} ]
@var{guarded-statements} ::= @var{guarded-statement}
             [ @code{or} @var{guarded-statement} ] @dots{}
@var{guarded-statement} ::= @code{@{}
             @var{assume-statement}
             @var{jml-statement} [ @var{jml-statement}] @dots{} @code{@}}
@end display

The meaning of a nondeterministic if statement is that a correct
implementation may dynamically choose any of the guarded-statements
for which the guard (the first @var{assume-statement} in the 
@var{guarded-statement}) is true.  If none of these are true, then it
must execute the @var{jml-compound-statement} given following
@code{else}, but it may not do that if one of the guards in the
guarded statements is true.

@node Specification Statements,  , Nondeterministic If Statement, Model Programs
@c  node-name,  next,  previous,  up
@section Specification Statements

The grammar for specification statements appears below.  It is
unusual, compared to specification statements in refinement calculus,
in that it allows one to specify statements that can signal
exceptions, or terminate abruptly.  The reasons for this are based on
verification logics for Java [Huisman01] [Jacobs-Poll01] [Ruby06], which have
these possibilities.  The meaning of an @var{abrupt-spec-case} is that
the normal termination and signaling an exception are forbidden; that
is, the equivalent @var{spec-statement} using @code{behavior} would
have @code{ensures false;} and @code{signals (Exception) false;}
clauses.  Hence in an @var{abrupt-spec-case}, JML does not allow use
of an @var{ensures-clause}, @var{signals-only-clause}, or
@var{signals-clause}. 

@cindex @var{spec-statement}, defined
@cindex @var{generic-spec-statement-case}, defined
@cindex @var{generic-spec-statement-body}, defined
@cindex @var{generic-spec-statement-body-seq}, defined
@cindex @var{simple-spec-statement-body}, defined
@cindex @var{simple-spec-statement-clause}, defined
@kindex @code{abrupt-behavior-keyword}, defined
@cindex @var{abrupt-spec-case}, defined
@kindex @code{behavior-keyword}, used
@kindex @code{exceptional-behavior-keyword}, used
@kindex @code{normal-behavior-keyword}, used
@kindex @code{abrupt-behavior-keyword}, used
@cindex @var{privacy}, used
@cindex @var{generic-spec-statement-case}, used
@cindex @var{exceptional-spec-case}, used
@cindex @var{normal-spec-case}, used
@cindex @var{abrupt-spec-case}, used
@cindex @var{spec-var-decls}, used
@cindex @var{generic-spec-statement-body}, used
@cindex @var{spec-header}, used
@cindex @var{simple-spec-statement-body}, used
@cindex @var{generic-spec-statement-case-seq}, used
@cindex @var{simple-spec-statement-clause}, used
@cindex @var{diverges-clause}, used
@cindex @var{assignable-clause}, used
@cindex @var{when-clause}, used
@cindex @var{working-space-clause}, used
@cindex @var{duration-clause}, used
@cindex @var{ensures-clause}, used
@cindex @var{signals-only-clause}, used
@cindex @var{signals-clause}, used
@cindex @var{continues-clause}, used
@cindex @var{breaks-clause}, used
@cindex @var{returns-clause}, used
@kindex @code{abrupt_behavior}
@kindex @code{@{|}
@kindex @code{|@}}
@kindex @code{also}
@display
@var{spec-statement} ::= [ @var{privacy} ] @var{behavior-keyword}
                   @var{generic-spec-statement-case}
        | [ @var{privacy} ] @var{exceptional-behavior-keyword}
          @var{exceptional-spec-case}
        | [ @var{privacy} ] @var{normal-behavior-keyword}
          @var{normal-spec-case}
        | [ @var{privacy} ] @var{abrupt-behavior-keyword}
          @var{abrupt-spec-case}
@var{generic-spec-statement-case} ::= [ @var{spec-var-decls} ]
                                @var{generic-spec-statement-body}
        | [ @var{spec-var-decls} ]
          @var{spec-header}
          [ @var{generic-spec-statement-body} ]
@var{generic-spec-statement-body} ::= @var{simple-spec-statement-body}
        | @code{@{|} @var{generic-spec-statement-case-seq} @code{|@}}
@var{generic-spec-statement-body-seq} ::= @var{generic-spec-statement-case}
             [ @code{also} @var{generic-spec-statement-case} ] @dots{}
@var{simple-spec-statement-body} ::= @var{simple-spec-statement-clause}
                               [ @var{simple-spec-statement-clause} ] @dots{} 
@var{simple-spec-statement-clause} ::= @var{diverges-clause}
        | @var{assignable-clause}
        | @var{when-clause} | @var{working-space-clause} | @var{duration-clause}
        | @var{ensures-clause} | @var{signals-only-clause} | @var{signals-clause}
        | @var{continues-clause} | @var{breaks-clause} | @var{returns-clause}
@var{abrupt-behavior-keyword} ::= @code{abrupt_behavior} | @code{abrupt_behaviour}
@var{abrupt-spec-case} ::= @var{generic-spec-statement-case}
@end display

The meaning of a @var{spec-statement} is that the code in a correct
implementation must refine the given specification.
One way to ensure this is to use a @var{refining-statement} in the
implementation that contains the @var{spec-statement}
in its specification part (@pxref{Refining Statements}).

The following subsections describe details of each of the new clauses
that may appear in an @var{abrupt-spec-case} or a
@var{generic-spec-statement-case}. 

@menu
* Continues Clause::            
* Breaks Clause::               
* Returns Clause::              
@end menu

@node Continues Clause, Breaks Clause, Specification Statements, Specification Statements
@c  node-name,  next,  previous,  up
@subsection Continues Clause

@cindex @var{continues-clause}, defined
@cindex @var{continues-keyword}, defined
@cindex @var{continues-keyword}, used
@cindex @var{pred-or-not}, used
@cindex @var{target-label}, used
@cindex @var{ident}, used
@kindex @code{;}
@kindex @code{continues}
@kindex @code{continues_redundantly}
@kindex @code{->}
@kindex @code{(}
@kindex @code{)}
@display
@var{continues-clause} ::= @var{continues-keyword} [ @var{target-label} ]
                     [ @var{pred-or-not} ] @code{;}
@var{continues-keyword} ::= @code{continues} | @code{continues_redundantly}
@var{target-label} ::= @code{->} @code{(} @var{ident} @code{)}
@end display

The meaning of the @var{continues-clause} is that if the statement that
implements the specification statement executes a @code{continue},
then it must continue to the given @var{target-label} (if any),
and the given predicate (if any) must hold in the state just before
the @code{continue} is executed.

@node Breaks Clause, Returns Clause, Continues Clause, Specification Statements
@c  node-name,  next,  previous,  up
@subsection Breaks Clause

@cindex @var{breaks-clause}, defined
@cindex @var{breaks-keyword}, defined
@cindex @var{breaks-keyword}, used
@cindex @var{pred-or-not}, used
@cindex @var{target-label}, used
@kindex @code{;}
@kindex @code{breaks}
@kindex @code{breaks_redundantly}
@display
@var{breaks-clause} ::= @var{breaks-keyword} [ @var{target-label} ]
                  [ @var{pred-or-not} ] @code{;}
@var{breaks-keyword} ::= @code{breaks} | @code{breaks_redundantly}
@end display

The meaning of the @var{breaks-clause} is that if the statement that
implements the specification statement executes a @code{break},
then it must break to the given @var{target-label} (if any),
and the given predicate (if any) must hold in the state just before
the @code{break} is executed.

@node Returns Clause,  , Breaks Clause, Specification Statements
@c  node-name,  next,  previous,  up
@subsection Returns Clause

@cindex @var{returns-clause}, defined
@cindex @var{returns-keyword}, defined
@cindex @var{returns-keyword}, used
@cindex @var{pred-or-not}, used
@kindex @code{;}
@kindex @code{returns}
@kindex @code{returns_redundantly}
@display
@var{returns-clause} ::= @var{returns-keyword} [ @var{pred-or-not} ] @code{;}
@var{returns-keyword} ::= @code{returns} | @code{returns_redundantly}
@end display

The meaning of the @var{returns-clause} is that if the statement that
implements the specification statement executes a @code{return},
then the given predicate (if any) must hold in the state following
evaluation of the return value, but just before
the @code{return} is executed.  
The predicate (if any) in a returns clause may use @code{\result}
to name the computed return value.

@c --------- chapter Specification for Subtypes ------
@node Specification for Subtypes, Refinement, Model Programs, Top
@c  node-name,  next,  previous,  up
@chapter Specification for Subtypes

@cindex specification for subtypes
@cindex subtypes, specification for
@cindex supertypes, specification of
This chapter describes how JML specifies a type so that one can
program subtypes from the specification, without the need to see the
code of the supertypes that have been specified.

@cindex Kiczales
@cindex Lamping
@cindex Steyaert
The problem of specifying enough about superclasses has been discussed
by Kiczales and Lamping [Kiczales-Lamping92]
and by Steyaert, et al. [Steyaert-etal96].  This problem is difficult
because of the many ways that subclasses can depend on coding details
of a superclass.  For example, a subclass can depend on the calling
pattern among a superclass's method and the fields that a superclass
can access [Kiczales-Lamping92] [Steyaert-etal96].

@cindex Ruby
@cindex Leavens
JML builds on the work of Ruby and Leavens to solve this problem
[Ruby-Leavens00] [Ruby06], which builds on the earlier works described above.
The idea is to write specifications for subclasses in three parts.
The first is the usual, public specification, which is primarily for
clients but also useful to subclasses, who need to know what public
interface they must meet.  The second is a protected specification,
which specifies fields and methods that are usable by the subclass.
The third is the code contract.  The code contract has a different
syntax in JML than it did in [Ruby-Leavens00].
@cindex code contract
@kindex @code{code}.
In the current JML
a @dfn{code contract}
is a heavyweight behavior specification case
(@pxref{Heavyweight Specification Cases})
or as a model program (@pxref{Model Programs})
that uses the keyword ``@code{code}.''
The @code{code} keyword is used just before one of the behavior
keywords or just before the keyword @code{model_program}.

@cindex Ruby
@cindex Leavens
While code contracts can be generated automatically by a tool, as
imagined by Ruby and Leavens [Ruby-Leavens00] [Ruby06], they can also be
written by users directly.  This is sometimes useful for documenting
the implementation of a method. The code contract is intended to be
created automatically, by a tool (which does not, as of this writing, exist).
It has the following syntax.

In code contracts as described in the work of Ruby and Leavens,
the main clauses used are the @var{accessible-clause} and the
@var{callable-clause}. 
@xref{Accessible Clauses}, for the syntax and semantics of the
@var{accessible-clause}. 
@xref{Callable Clauses}, for the syntax and semantics of the
@var{callable-clause}. 

@menu
* Method of Specifying for Subclasses::  
* Code Contracts::              
@end menu

@node Method of Specifying for Subclasses, Code Contracts, Specification for Subtypes, Specification for Subtypes
@c  node-name,  next,  previous,  up
@section Method of Specifying for Subclasses

[[[This should be a synopsis of Clyde Ruby's dissertation, with an example.]]]

@node Code Contracts,  , Method of Specifying for Subclasses, Specification for Subtypes
@c  node-name,  next,  previous,  up
@section Code Contracts

@cindex code contract
@cindex @code{code}, modifier, semantics of
This section discusses the semantics of 
``code contracts,'' which are specification cases that use the
``@code{code}'' keyword.
(@xref{Behavior Specification Cases}, for the detailed syntax of such
specification cases.)

@cindex Khurshid
@cindex Marinov
@cindex Jackson
This feature was inspired by ``does'' clause of the Alloy Annotation Language
[Khurshid-Marinov-Jackson02].

The modifier @code{code} may not be used on an abstract method.
It follows that the @code{code} modifier cannot be used to document
normal Java methods in interfaces.
(In an interface,
@code{code} could only be used in the specification of a model method that
has a body.)

Tools for JML should warn the user
if @code{code} is used in a specification case for a constructor, or
for a final, static, or private method.  It does no harm there, but is
not needed. 

The meaning of the @code{code} modifier is just that specification cases or
model programs containing them are not inherited.  That is, whenever
the method is overridden, it does not inherit code contracts from its
supertypes. 

@cindex Dhara
@cindex Leavens
In verification of a method call, you can use all non-code
specification cases, that are visible at a call site, for the
statically-determined method being called.  Such specifications are
inherited by each subtype's method overrides to preserve behavioral
subtyping [Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b].

In verification of a method call, you can use a code specification
case for a method @i{m} given in a class @i{C} only if you can prove that the
method being called is method @i{m} in class @i{C}.  This applies in
particular to super calls, which is the main use for such code
contracts.  (It would also apply to calls to final methods,
calls to methods in final classes, and calls to private or static
methods.)

@c [[[Need examples]]]

@c --------- chapter Refinement ------
@node Refinement, MultiJava Extensions to JML, Specification for Subtypes, Top
@c  node-name,  next,  previous,  up
@chapter Refinement

This chapter explains JML's notion of refinement files, which uses the
following syntax.

@cindex @var{refine-prefix}, defined
@cindex @var{refine-keyword}, defined
@cindex @var{refine-keyword}, used
@kindex @code{refine}
@kindex @code{refines}
@cindex @var{string-literal}, used
@kindex @code{;}
@display
@var{refine-prefix} ::= @var{refine-keyword} @var{string-literal} @code{;}
@var{refine-keyword} ::= @code{refine} | @code{refines}
@end display

The @var{refine-prefix} in a compilation unit says that the
declarations in this compilation unit refine the corresponding
declarations in the file named by the @var{string-literal}.  The
@var{string-literal} should name a file, complete with a suffix, for
example, @code{"MyType.java-refined"}.  The suffix of such a file is
used by JML tools to find the file that is the base of a refinement
chain, and all other files in the chain are found using the files
named in the @var{refine-prefix} of a previous file in the chain.

One can use either keyword, @code{refine} or @code{refines} in a
@var{refine-prefix}, although for historical reasons most examples use
@code{refine}.

The following gives more details about the checks and meaning of this
feature of JML.

@menu
* File Name Suffixes::          
* Using Separate Files::        
* Refinement Chains::           
* Type Checking Refinements::   
* Refinement Viewpoints::       
@end menu

@node File Name Suffixes, Using Separate Files, Refinement, Refinement
@c  node-name,  next,  previous,  up
@section File Name Suffixes

@cindex filename suffixes
@cindex suffixes, of filenames
@cindex active suffixes, of filenames
@cindex passive suffixes, of filenames
@cindex @file{.refines-java}
@cindex @file{.refines-spec}
@cindex @file{.refines-jml}
@cindex @file{.java}
@cindex @file{.spec}
@cindex @file{.jml}
@cindex @file{.java-refined}
@cindex @file{.spec-refined}
@cindex @file{.jml-refined}
@cindex @file{refines-java} filename suffix
@cindex @file{refines-spec} filename suffix
@cindex @file{refines-jml} filename suffix
@cindex @file{java} filename suffix
@cindex @file{spec} filename suffix
@cindex @file{jml} filename suffix
@cindex @file{java-refined} filename suffix
@cindex @file{spec-refined} filename suffix
@cindex @file{jml-refined} filename suffix
The JML tools recognize several filename suffixes.  The following are
considered to be @dfn{active} suffixes: @file{.refines-java},
@file{.refines-spec}, @file{.refines-jml}, @file{.java}, @file{.spec},
and @file{.jml}; There are also three @dfn{passive} suffixes:
@file{.java-refined}, @file{.spec-refined}, and @file{.jml-refined}.
Files with passive suffixes can be used in refinements but should not
normally be passed explicitly to the tools directly.
These filename suffixes are ordered from most active to least active,
in the order given above.
Graphical user interface tools for JML should, by default,
only present the active suffixes for selection.
Among files in a directory with the same prefix,
but with different active suffixes, the one whose suffix appears first
in the list of active suffixes above should be considered primary
by such a tool.

@xref{Using Separate Files}, for guidelines on how to use these
suffixes.
@xref{Refinement Chains}, for details on the semantics of
specifications written using separate files.

@node Using Separate Files, Refinement Chains, File Name Suffixes, Refinement
@c  node-name,  next,  previous,  up
@section Using Separate Files

@cindex filename suffixes
@cindex separating code and specification
@cindex separating specification and code
Typically, JML specifications are written into annotation comments in
@file{.java} files, and this is certainly the simplest way to use JML
and its tools. 

However, there are some circumstances in which one may wish to
separate the specification from the Java code.  An important example
of this is when you do not own the sources for the Java code, but wish
to specify it.  This might happen if you are specifying a class
library or framework that you are using. When you do not have control
of the code, it is best to put the specification in a different file.

@cindex @file{.refines-java}
@cindex @file{.refines-spec}
@cindex @file{.refines-jml}
To add specifications to such a library or framework,
one would use a filename with an active suffix,
such as @file{.refines-java} (or @file{.refines-spec} or
@file{.refines-jml}). The file with such a name would hold
the specifications of the corresponding
Java compilation unit.  For example, if one wants to specify the type
@code{LibraryType}, without touching the file @file{LibraryType.java}
then one could write specifications in the file
@file{LibraryType.refines-java}, and include in that file the following
@var{refine-prefix}.

@cindex @var{refine-prefix}, example of
@example
  refine "LibraryType.java";
@end example

@cindex @file{.spec}
@cindex @file{.jml}
If you are specifying code for which no sources are available (a
class library in binary form), then you should use the @file{.spec} or
@file{.jml} suffixes to write the specification.  Such specifications
act much like those written in @file{.refines-spec} or
@file{.refines-jml} files, but would not include a
@var{refine-prefix}.
They allow specifications to be written without having to write Java
code for the bodies of methods (as do all non-@file{.java}) files.

Another reason for writing specifications in different files is to
prevent the specifications from ``cluttering up'' the code (making it
hard to see all of the code at once). This is also possible by using
separate files for the specification and the code.
In such a case one has a choice of suffixes, depending on whether one
considers the code to be primary or the specification.  If the code is
primary, or has been written already, then one can treat the code as
if it were written in an extra library, using the @file{.refines-java}
(or @file{.refines-spec} or @file{.refines-jml}) suffixes to specify the
Java files as above.

@cindex @file{.java-refined}
@cindex @file{.spec-refined}
@cindex @file{.jml-refined}
On the other hand, if the specification is primary, or is to be
written first, one could instead use the @file{.java-refined}
(or @file{.spec-refined} or @file{.jml-refined}) suffixes,
and then write a @var{refine-prefix} in the @file{.java} file.
For example, one might specify
the class @code{MyType} in a file named @file{MyType.java-refined}.
Then one could write the implementation of @code{MyType} in a file
called @file{MyType.java}.  The file @file{MyType.java} would include
the following @var{refine-prefix}:

@cindex @var{refine-prefix}, example of
@example
  refine "MyType.java-refined";
@end example

@noindent
In this case,
the specification found in @file{MyType.java-refined}
@dfn{is a refinement} of the implementation found in @file{MyType.java}.

Combinations of these techniques can also be used, by using several
files instead of just a code file and a specification file.
@xref{Refinement Chains}, for the meaning of JML specifications in
this general case.

To summarize, aside from the standard @file{.java} suffix,
one would use file name suffixes as follows.
@itemize @bullet
@item
If you are specifying before coding, but
want to keep the specifications in a different file,
but you want to have the @file{.java} file refer directly to the
specification, then use one of the 
suffixes: @file{.java-refined}, @file{.spec-refined}, or
@file{.jml-refined}).  The @file{.java} file would name the file it
refines (as would other files in the chain) in a @var{refine-prefix}.

@item
If you have a @file{.java} file, but the @var{refine-prefix} cannot
or should not appear in that @file{.java} file, then use one of the
suffixes: @file{.refines-java}, @file{.refines-spec}, or
@file{.refines-jml}.

@item
If there is no @file{.java} source file that will be available to the
tools, the specify the type using a @file{.spec} or @file{.jml} file,
without using a @var{refine-prefix}.
@end itemize

@node Refinement Chains, Type Checking Refinements, Using Separate Files, Refinement
@c  node-name,  next,  previous,  up
@section Refinement Chains

Compilation Units that jointly give the specifications of a type form a
refinement chain.  It begins at a base (or most-refined) compilation unit,
proceeding by means of the @code{refine} annotation links, until a file
is found that has no @code{refine} statement.  That file is the end of
the refinement chain and is the least-refined compilation unit.

For a given type in a given package, the base of the refinement chain is
found as follows.  Each entry of the classpath is searched in order for a 
directory whose name matches the package of the type and that contains a file
whose name has a prefix matching the type name and a suffix that is an active
suffix as defined above.  The first such file found is the base of the
refinement chain.  If the first classpath entry to contain a candidate file
contains more than one candidate file, then the file with the most active
suffix is the base of the chain.

The subsequent elements of the refinement chain are given by the filenames
provided in the @code{refine} statements.  Each element of the chain is in
the same package.  Thus the file corresponding to the @code{refine} 
statement is the first file found by searching the classpath entries in
order and that is in the directory corresponding to the package of the type
and has the filename and suffix given in the @code{refine} statement.

To help ensure that the base is correctly selected, the file with the
most active suffix must be the base of a refinement sequence, otherwise
the JML typechecker issues an error message.  Also, the prefix of the
base file must be the same as the public type declared in that
compilation unit or an error message is issued.  However, it is not
necessary that the file being refined have the same prefix as the file
at the base of the refinement chain (except that the .java file, if it is
in the refinement sequence, must have a name given by the Java rules for
naming compilation units).  Furthermore, a file with the same
prefix as the base file may not be in a different refinement sequence.
For example, @file{SomeName.java-refined} can be refined by
@file{MyType.java} as long as there is no refinement sequence with
@file{SomeName} as the prefix of the base of another refinement.

The JML tools deal with all files in a refinement chain whenever one of
them is selected for processing by the tool.  This allows all of the
specifications that apply to be consistently dealt with at all times.
For example, suppose that there are files named @file{Foo.refines-java}
and @file{Foo.java}, then if a tool selects the @file{Foo.java}, e.g.,
with the command:

@example
   jmlc *.java
@end example

@noindent
then it will see both the @file{Foo.refines-java} and the
@file{Foo.java} file (as long as @file{Foo.refines-java} appears in
a specification path directory before or with @file{Foo.java}).

A given .java file (that is, compilation unit)
may have more than one top-level class declaration
within it.  Only one may be public, and Java requires that the name of that
type match the name of the file, so that the definition of the type can be
found in the file system.  The non-public types within that 
compilation unit may be 
referred to only within that compilation unit.  Consequently, all specifications
of those non-public types must occur along with the specifications of the 
public type in that compilation unit.  For example, suppose a file @file{A.java}
contains the Java declaration of types @code{A} and @code{B}.  Then if the
specifications of type @code{A} are in @file{A.refines-java}, the specifications of
type @code{B} must also be in @file{A.refines-java}.  For simple one-file programs,
the one compilation unit may contain only non-public types.  Then the specifications
for those types are found in specification files with the same prefix as the filename
of the Java file containing the type declarations.

@node Type Checking Refinements, Refinement Viewpoints, Refinement Chains, Refinement
@c  node-name,  next,  previous,  up
@section Type Checking Refinements

There are some restrictions on what can appear in the different files
involved in a particular refinement.  Since the Java compilers only
see the @file{.java} files, executable code (that is not just for use
in specifications) should only be placed in the @file{.java} files.
In particular the following restrictions are enforced by JML.
@itemize @bullet
@item
@cindex same method
@cindex refinement of methods
@cindex method refinement
@kindex @code{public}, modifier in refinement
@kindex @code{protected}, modifier in refinement
@kindex @code{private}, modifier in refinement
@kindex @code{static}, modifier in refinement
@kindex @code{final}, modifier in refinement
When the same method is declared in more than one file in a refinement
sequence, most parts of the method declaration must be identical in
all the files.  (Two method declarations are considered to be
declaring the @dfn{same method} if they have the same signature, i.e.,
same name, same generic type parameters, and static formal parameter types.)  
However, in addition to
the signature of such a method, the return type, the names of the
formal parameters, the declared exceptions the method may throw, and
the non-JML modifiers @code{public}, @code{protected}, @code{private},
@code{static}, and @code{final}, must all match exactly in each such
declaration in a refinement chain.

@item
@kindex @code{model}, modifier in refinement
The @code{model} modifier must appear in all declarations of a given
method or it must appear in none of them.  It is not permitted to
implement a model method with a non-model method or to refine a
non-model method with a model method.  Use a @code{spec_public} or
@code{spec_protected} method if you want to use a non-model method in a
specification.  Also, there may be no nesting of model declarations: 
model classes and model methods may not contain model or ghost declarations. 

@item
@kindex @code{pure}, modifier in refinement
@kindex @code{non_null}, modifier in refinement
@kindex @code{nullable}, modifier in refinement
@kindex @code{spec_public}, modifier in refinement
@kindex @code{spec_protected}, modifier in refinement
Some of the JML method modifiers do not always have to match in all
declarations of the same method in a refinement chain.  One may add
@code{pure}, @code{non_null}, @code{nullable}, @code{spec_public}, or
@code{spec_protected} to any of the declarations for a method in any
file.  However, if @code{pure} is added to a method specification,
then all subsequent declarations of that method in a refinement
sequence must also be declared @code{pure}.  Also, it is, of course,
not permitted to add @code{spec_protected} to a method that has been
declared @code{public} or @code{spec_public} in other declarations.
One can add @code{non_null} or @code{nullable} to any formal parameter in any file,
although good style suggests that all of these annotations appear on
one declaration of that method.

@item
@cindex refining method declaration
@cindex method declaration, refining
@kindex @code{also}, in refinements
The specification of a refining method declaration must start with the
JML keyword @code{also}; if it does not an error message is issued.  A
@dfn{refining method declaration} is a declaration that overrides a
superclass method or refines the specification of the same method in a
refinement chain.  In JML, method specifications are inherited by
subclasses and in refinement chains.  The @code{also} keyword
indicates that the current specification is refining the specification
inherited either from the superclass or from the previous declaration
of the method in a refinement sequence.  Therefore, it is an error if
the specification of a non-refining method begins with @code{also}
(unless it overrides an inherited method).

@item
@cindex model method, in refinements
@cindex body, of method, in refinements
@cindex method body, in refinements
@kindex @code{model}, in refinements
If a non-model method has a body, then the body can only appear in a
@file{.java} file; an error message is issued if the body of a
non-model method appears in a file with any other suffix.
Furthermore, the body of a model method may only appear in one file of
a refinement sequence.  This means that each method of each class can
have at most one method body.

@item
@cindex same field
@cindex refinement of field declarations
@cindex field declaration refinement
@kindex @code{public}, modifier in refinement
@kindex @code{protected}, modifier in refinement
@kindex @code{private}, modifier in refinement
@kindex @code{static}, modifier in refinement
@kindex @code{final}, modifier in refinement
When the same field is declared in more than one file in a refinement
sequence, then the signature of each such declaration must be
identical in all the files.  (Two field declarations are considered to
be declaring the @dfn{same field} if they have the same name.)  The
signature of such a field, including its type, the non-JML modifiers
@code{public}, @code{protected}, @code{private}, @code{static}, and
@code{final}, must all match exactly in each such declaration.

@item
@kindex @code{model}, modifier in refinement
@kindex @code{ghost}, modifier in refinement
All declarations of a given field must either use the modifier
@code{model} or not.  It is not permitted to implement a model field
with a non-model field or vice versa.  Use a @code{spec_public} or
@code{spec_protected} field if you want to use the same name.  The
same comment holds for @code{ghost} fields as well.

@item
@kindex @code{non_null}, modifier in refinement
@kindex @code{nullable}, modifier in refinement
@kindex @code{spec_public}, modifier in refinement
@kindex @code{spec_protected}, modifier in refinement
Some of the JML field modifiers do not always have to match in all
declarations of the same field in a refinement chain.  One may add
@code{non_null}, @code{nullable}, @code{spec_public}, or @code{spec_protected} to any
of the declarations for a field in any file.  However, it is of
course not permitted to add @code{spec_protected} to a field that has
been declared public in other declarations.


@item
@cindex field initializers
@cindex initializers, for fields field
@kindex @code{model}, modifier in refinement
Initializers are not allowed in all field declarations.  A non-model
field can have an initializer expression but it can only appear in a
@file{.java} file because this is where a compiler expects to find it.

@kindex @code{ghost}, modifier in refinement
Fields declared using the @code{ghost} modifier can have an
initializer expression in any file, but they may have at most one
initializer expression in all the files.

@kindex @code{initially}, clause and refinement
Model fields cannot have an initializer expression because there is no
storage associated with such fields.  Use the @code{initially} clause
to specify the initial state of model fields (although the initial
state is usually determined from the represents clause).

@item
@cindex @var{jml-var-assertion}
Any number of @var{jml-var-assertion}'s [[[ what is this? the name must have changed - DRC]]] can be declared for any field
declaration and these are all conjoined.  For example, if a variable
@code{int count} is declared and there are two @code{initially} clauses,
in the same or different files, then these initially clause predicates
are conjoined; that is, both must be satisfied initially.

@item
@cindex initializers, and refinement
@kindex @code{initializer}, and refinement
@kindex @code{static_initializer}, and refinement
An initializer block or a static initializer block (with code) may
only appear in a @file{.java} file.  One can write annotations to
specify the effects of such initializers in JML annotations in other
files, using the keywords @code{initializer} and
@code{static_initializer}.
@end itemize

@c [[[This next paragraph is out of place]]]
JML uses specification inheritance to impose the specifications of
supertypes on their subtypes [Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b]
to support the concept of
behavioral subtyping [America87] [Leavens90] [Leavens91]
[Leavens-Weihl90] [Leavens-Weihl95] [Liskov-Wing94].  JML also supports
a notion of weak behavioral subtyping [Dhara-Leavens94b] [Dhara97].

@node Refinement Viewpoints,  , Type Checking Refinements, Refinement
@c  node-name,  next,  previous,  up
@section Refinement Viewpoints

In refinements, specification inheritance allows the specifier to
separate the public, protected, and private specifications into
different files.  Public specifications give the public behavior and are
meant for clients of the class.  Protected specifications are meant for
programmers creating subclasses and give the protected behavior of the
type; they give the behavior of protected methods and fields that are
not visible to clients.  Similarly, private specifications are meant for
implementors of the class and provide the behavior related to private
methods and fields of the class; implementors must satisfy the combined
public, protected, and private specifications of a method.

[[[Needs work]]]

@menu
* Default Constructor Refinement::  
@end menu

@node Default Constructor Refinement,  , Refinement Viewpoints, Refinement Viewpoints
@c  node-name,  next,  previous,  up
@subsection Default Constructor Refinement

In Java, a default constructor is automatically generated for a class 
when no constructors are declared in a class. 
However, in JML, a default constructor is not generated for a class unless 
the file suffix is @file{.java} 
(the same constructor is generated as in the Java language). 
Consider, for example, the refinement sequence defined by the
following three files, @code{RefineDemo.jml-refined},
@code{RefineDemo.jml}, and @code{RefineDemo.java}.

@pindex @code{RefineDemo.jml-refined}
@example
@include local/RefineDemo.jml-refined.texinfo
@end example

@pindex @code{RefineDemo.jml}
@example
@include local/RefineDemo.jml.texinfo
@end example

@pindex @code{RefineDemo.java}
@example
@include local/RefineDemo.java.texinfo
@end example

In the protected specification declared in @file{RefineDemo.jml}, 
no constructor is defined.  
If JML were to generate a default constructor for this class declaration, 
then the @code{public} constructor defined 
earlier in the refinement chain, in @file{RefineDemo.jml-refined}, 
could have a visibility modifier 
that conflicts with the one automatically generated for the protected 
specification. (The visibility modifier of an automatically generated 
default constructor depends on other factors including the visibility 
of the class.  @xref{Lightweight Specification Cases}, for more details.) 
Recall that the signature, including the visibility modifier, must 
match for every method and constructor declared in a refinement chain.  
To avoid such conflicts, JML does not generate a default constructor unless 
the file suffix is @file{.java} (as part of the standard 
compilation process). 

A similar problem can occur when the only constructor is protected or 
private as in the refinement sequence defined by the
following three files, @code{RefineDemo2.jml-refined},
@code{RefineDemo2.jml}, and @code{RefineDemo2.java}.

@pindex @code{RefineDemo2.jml-refined}
@example
@include local/RefineDemo2.jml-refined.texinfo
@end example

@pindex @code{RefineDemo2.jml}
@example
@include local/RefineDemo2.jml.texinfo
@end example

@pindex @code{RefineDemo2.java}
@example
@include local/RefineDemo2.java.texinfo
@end example

In this example, notice that 
no constructor is defined for the public specification 
in @file{RefineDemo2.jml-refined}.
If a default constructor were generated for this class declaration, 
then the @code{protected} constructor defined 
later in the refinement chain, in @file{RefineDemo2.jml}, 
would have a visibility modifier 
that conflicts with the one automatically generated and 
JML would emit an error. 
Thus JML only generates the default constructor for the executable 
declaration of a class in the @file{.java} file and only when required by the 
Java language. 
 
@c --------- chapter MultiJava Extensions to JML -----------
@node MultiJava Extensions to JML, Universe Type System, Refinement, Top
@c  node-name,  next,  previous,  up
@chapter MultiJava Extensions to JML

@cindex MultiJava
@cindex Clifton
This section describes extensions to JML to support the MultiJava
[Clifton-etal00] language.  All of these extensions are optional and
are only used when an option (or special tool) is used to parse this syntax.

The sections below explain the extensions that MultiJava makes to JML.

@menu
* Augmenting Method Declarations::  
* MultiMethods::                
@end menu

@node Augmenting Method Declarations, MultiMethods, MultiJava Extensions to JML, MultiJava Extensions to JML
@c  node-name,  next,  previous,  up
@section Augmenting Method Declarations

@cindex open classes
@cindex augmenting methods
@cindex Clifton
MultiJava has a feature, called ``open classes''
[Clifton-etal00] or ``augmenting methods'' that allows methods to be
added to an existing class.
It has the following syntax, which, in JML, permits method specifications.

@cindex @var{multijava-top-level-declaration}, defined
@cindex @var{multijava-top-level-method}, defined
@cindex @var{extending-method-head}, defined
@cindex @var{multijava-top-level-method}, used
@cindex @var{extending-method-head}, used
@cindex @var{method-specification}, used
@cindex @var{modifiers}, used
@cindex @var{type-spec}, used
@cindex @var{method-body}, used
@cindex @var{name}, used
@cindex @code{ident}, used
@cindex @var{formals}, used
@cindex @var{dims}, used
@cindex @var{throws-clause}, used
@kindex @code{method}
@kindex @code{.}
@display
@var{multijava-top-level-declaration} ::= @var{multijava-top-level-method}
@var{multijava-top-level-method} ::= [ @var{method-specification} ]
              @var{modifiers} [ @code{method} ]
              [ @var{type-spec} ] @var{extending-method-head} @var{method-body}
@var{extending-method-head} ::= @var{name} @code{.} @code{ident} @var{formals} [@var{dims} ]
                          [ @var{throws-clause} ]
@end display

This syntax adds a method to the class named by the @var{name} in the
@var{extending-method-head}.

The method must satisfy the given @var{method-specification}, if there
is one.

@node MultiMethods,  , Augmenting Method Declarations, MultiJava Extensions to JML
@c  node-name,  next,  previous,  up
@section MultiMethods

@cindex multiple dispatch
@cindex multimethods
The other feature in MultiJava is multiple dispatch, which is used to
define multimethods.  Multiple dispatch is defined using the following syntax.

@cindex @var{multijava-param-declaration}, defined
@cindex @var{specializer}, defined
@cindex @var{value-specializer}, defined
@cindex @var{specializer}, used
@cindex @var{value-specializer}, used
@cindex @var{param-modifier}, used
@cindex @var{type-spec}, used
@cindex @var{ident}, used
@cindex @var{dims}, used
@cindex @var{expression}, used
@kindex @code{@@}
@kindex @code{@@@@}
@display
@var{multijava-param-declaration} ::= [ @var{param-modifier} ] @dots{}
                 @var{type-spec} @var{specializer} @var{ident} [ @var{dims} ]
@var{specializer} ::= @code{@@} @var{type-spec}
        | @code{@@@@} @var{value-specializer}
@var{value-specializer} ::= @var{expression}
@end display

See the MultiJava paper [Clifton-etal00] for how the use of a
@var{specializer} affects the meaning of method calls.

@c --------- chapter Universe Type System -----------
@node Universe Type System, Safe Math Extensions, MultiJava Extensions to JML, Top
@c  node-name,  next,  previous,  up
@chapter Universe Type System

@cindex Mueller
@cindex Dietl
@cindex Poetzsch-Heffter
@cindex Universe type system
@cindex universe type system
@cindex type system, Universe
@cindex alias control, universe type system for
This section describes how the Universe type system
[Dietl-Drossopoulou-Mueller07] [Dietl-Mueller05] [Dietl-Mueller-Schregenberger-08] [Mueller-Poetzsch-Heffter01a]
is realized in JML and the impact it has on JML specifications.
The Universe type system is a lightweight ownership type system that
hierarchically structures the object store and confines the possible
effects of expressions.

The syntax for the Universe type system consists of three ownership
modifiers.  

@cindex @var{ownership-modifiers}, defined
@cindex @var{ownership-modifier}, defined
@cindex @var{reserved-ownership-modifier}, defined
@cindex @var{ownership-modifier}, used
@cindex @var{reserved-ownership-modifier}, used
@kindex @code{rep}
@kindex @code{peer}
@kindex @code{readonly}
@kindex @code{\rep}
@kindex @code{\peer}
@kindex @code{\readonly}
@display
@var{ownership-modifiers} ::= @var{ownership-modifier} [ @var{ownership-modifier} ]
@var{ownership-modifier} ::= @code{\rep} | @code{\peer} | @code{\readonly}
         | @var{reserved-ownership-modifier} @i{// with --universesx parse or --universesx full}
@var{reserved-ownership-modifier} ::= @code{rep} | @code{peer} | @code{readonly}
@end display

Depending on the options selected, one can use either form of the
modifiers, with or 
without the backslash, in annotations.
The forms without the backslashes are the only ones that can be used
in Java code, and when they are enabled, they are treated as new
reserved words in both JML annotations and in Java code.

@cindex universe type system, options for
Currently the Universe type checking and the
@var{reserved-ownership-modifier} syntax are not enabled by default in
JML, but is only available when various options are used in the tools.
It can also be used with different levels of checking.  If the
@code{--universesx no} option is used, only the @var{ownership-modifier}s
@code{\rep}, @code{\peer}, and @code{\readonly} are available.

To enable just parsing of the full syntax, one can use the
@code{--universesx parse} option; in this case, all of the syntax is
parsed, and @code{rep}, @code{peer}, and @code{readonly} are treated as
reserved words.  However, with this option, none of the checking
described below is done.

To enable checking, but without reserving the keywords @code{rep},
@code{peer}, and @code{readonly},
one uses the @code{--universesx check} option.
With this option, only the @var{ownership-modifier}s
@code{\rep}, @code{\peer}, and @code{\readonly} are available.
This allows the use of universe annotations in specifications, but not
in Java code.
@c [[[this will eventually be the default in JML.]]]

One can also enable both checking and all of the syntax by using the 
@code{--universesx full} option.  An equivalent option is
@code{--universes} (synonym @code{-e}). This parses and type checks all
the @var{ownership-modifier}s, not only in specifications, but also in
Java code.

For a simple reference type, one can use only one
@var{ownership-modifier} where @var{ownership-modifiers} appears in
the grammar.  The only case where two @var{ownership-modifier}s can be
used is for array types as described below.

Note that in [Dietl-Drossopoulou-Mueller07] the Universe type system is
extended to type genericity as found in Java 5. The JML tools support
Generic Universe Types and also recognize the @code{any} modifier as
synonym for @code{readonly}.
As the rest of this report is about non-generic Java, we refer to
[Dietl-Drossopoulou-Mueller07] [Dietl-Mueller-Schregenberger08]
for details.

In the sections below we just use the forms without the backslashes
when discussing the semantics of each form.

@menu
* Basic Concepts of Universes::  
* Rep and Peer::                
* Readonly::                    
* Ownership Modifiers for Array Types::  
* Default Ownership Modifiers::  
* Ownership Type Rules::        
* Casts and Ownership Types::   
@end menu

@node Basic Concepts of Universes, Rep and Peer, Universe Type System, Universe Type System
@c  node-name,  next,  previous,  up
@section Basic Concepts of Universes

@cindex ownership context
@cindex context, ownership
@cindex owner
@cindex root ownership context
@cindex ownership context, root
@cindex Dietl
@cindex M@"uller
@cindex Poetzsch-Heffter
@cindex Universe type system, basic concepts
The Universe type system organizes
objects into ownership contexts [Dietl-Mueller05] [Mueller-Poetzsch-Heffter01a].
Each object has 0 or 1 @dfn{owner} objects.
The owner of an object (or the absence of an owner) is determined by the
@code{new} expression that creates the object.
Once determined, the owner of an object cannot be changed.

An @dfn{ownership context} is a set of objects with the same owner.
There is also a @dfn{root ownership context}, which is the set of all objects
that have no owner.
Each object thus belongs to exactly one ownership context.
The contexts form a hierarchy, with the root ownership context at the top.
The owner of an ownership context is not considered to be part of the
context it owns, 
but rather part of that context's parent context.

@cindex owner-as-modifier property
@cindex Dietl
@cindex M@"uller
The Universe type system enforces the ``owner-as-modifier'' property
(see section 1 of [Dietl-Mueller05]).
This property says ``an object @i{X} can be referenced by any other
object, but reference chains that do not pass through @i{X}s owner
must not be used to modify @i{X}'' (section 1 of [Dietl-Mueller05]).
Thus, if one looks at all the references from outside an ownership context into
objects within the context, all of these references must be readonly
references, with the exception of any references from the context's owner.

@node Rep and Peer, Readonly, Basic Concepts of Universes, Universe Type System
@c  node-name,  next,  previous,  up
@section Rep and Peer

@kindex @code{rep}
@kindex @code{peer}
The @code{rep} and @code{peer} annotations are type modifiers
(@pxref{Type-Specs}) that specify ownership relative to a receiver object.
The @dfn{receiver} object is defined as follows:
@itemize @bullet
@item
For a field access of the form @i{E.f}, the receiver object is the
result of the expression @i{E}.

@item
For a call to an instance method of the form @i{E.m(@dots{})}, the
receiver object is the result of the expression @i{E}.

@item
For all other expressions occurring in the declaration of an instance
method or constructor (including the specification),
or in an instance invariant or instance history constraint,
the receiver object is @code{this}.

@item
For all other expressions in the declaration of a static method, there
is no receiver object.  In this case, the ownership modifier specifies
ownership relative to the current ownership context, as explained below.
@end itemize

@kindex @code{rep}
@kindex @code{\rep}
A @code{rep} modifier says that the referenced object
is owned by the receiver object. 
Thus if @code{myList} has a field @code{head} of type @code{rep Node},
then @code{myList.head} is owned by @code{myList},
because @code{myList} is the receiver.
If @code{n} is a local variable of type @code{rep Node} in an instance
method, then @code{n} is owned by @code{this}.
(Formal parameters are treated in exactly the same way as local
variables.)

@cindex @code{this}, and @code{rep}
Since the meaning of the @code{rep} modifier depends on the existence
of a receiver object, it cannot be used in static
declarations where there is no receiver object.
Hence, a @code{rep} modifier cannot be used in a static field
declaration.  It also cannot be used in the declaration of a static method or
in its specification.  Furthermore, it cannot be used in static
invariants or static history constraints.

@kindex @code{peer}
@kindex @code{\peer}
@kindex @code{this}
A @code{peer}
modifier says that the referenced object has the same
owner as the receiver object. 
Thus if @code{myNode} has a field @code{next} of type @code{peer Node},
then @code{myNode.next} is owned by the owner of @code{myNode},
because @code{myNode} is the receiver.
If @code{n} is a local variable of type @code{peer Node} in an instance
method, then @code{n} is owned by the owner of @code{this}.

The @code{peer} modifier can be used in all declarations, even in
static declarations.
Currently, a @code{peer} modifier in a static field declaration leads
to type unsafety and should therefore not be used.  (The tools give a
warning in this situation, and a safe semantics is a subject of
current research.)
The same remark applies to static invariants and static history constraints.

@cindex current ownership context
When used in a static method or its specification, @code{peer} refers
to the current ownership context.
The @dfn{current ownership context} for a method execution
is defined as follows.
For executions of instance methods the current ownership context is the
one containing the @code{this} object.
For executions of static methods, the current ownership context is
determined by the current ownership context of the caller and the
ownership modifier (@code{rep} or @code{peer}) used in the call as follows:
@itemize @bullet
@item
If the call has the form
@code{peer} @i{T}@code{.}@i{m}@code{(@dots{})},
then @i{m} executes in the same ownership context as the code making
the call (and hence in the current ownership context of the caller).

@item
If the call has the form
@code{rep} @i{T}@code{.}@i{m}@code{(@dots{})},
then @i{m} executes in the ownership context owned by the caller's
@code{this} object; hence this form
of static method call cannot be used in static declarations.
@end itemize

For example, if @code{p} is a local variable of type @code{peer Node}
in a static method, then @code{p} is in the current ownership
context, because there is no receiver object.

@xref{Ownership Modifiers for Array Types}, for the usage of these
modifiers with array types.

@node Readonly, Ownership Modifiers for Array Types, Rep and Peer, Universe Type System
@c  node-name,  next,  previous,  up
@section Readonly

@kindex @code{readonly}
@kindex @code{\readonly}
The @code{readonly} (or @code{\readonly}) modifier does not specify an
ownership context. 
Therefore, following the owner-as-modifier property, references
specified with the @code{readonly} modifier cannot be used to modify
the referenced object.  (Note that this does not guarantee that the
object referenced cannot change, only that it cannot be changed using
this reference.)

A readonly type thus cannot be used as the type of the receiver
expression of: a field update, or a call to a non-@code{pure} method.
(@xref{Pure Methods and Constructors}, for more about pure methods.)

@node Ownership Modifiers for Array Types, Default Ownership Modifiers, Readonly, Universe Type System
@c  node-name,  next,  previous,  up
@section Ownership Modifiers for Array Types

@cindex ownership modifiers for array types
@cindex array types, ownership modifiers for
An array of reference types always has two ownership modifiers, the
first for the array object itself and the second for the elements.
Both modifiers express ownership relative to the receiver object and both
modifiers can be any of the @var{ownership-modifier}s.
For example, the type @code{rep readonly Object[]}
says that the array object itself is owned by the receiver object,
but the elements are readonly (and hence may belong to an arbitrary
ownership context).
A @code{peer rep Object[]} type says that the array object has the same
owner as the receiver object and that the array elements are owned by the
receiver object.

For arrays of primitive types, the second ownership modifier is
omitted.
For example, the type @code{readonly int[]} says that the array object
can belong to any context, but cannot be modified through this reference.

All array objects in a multidimensional array are in the same context,
which is determined by the first ownership modifier.
For example, if an instance field, @code{m}, has type @code{rep int[][]},
then @code{m} and @code{m[3]} are both owned by the receiver.

Following the convention in Java, array types support covariant
subtyping that needs runtime checks on write accesses.


@node Default Ownership Modifiers, Ownership Type Rules, Ownership Modifiers for Array Types, Universe Type System
@c  node-name,  next,  previous,  up
@section Default Ownership Modifiers

@cindex default ownership modifiers for types
@cindex ownership modifiers for types, defaults
If the @var{ownership-modifiers} are omitted in a @var{type-spec},
then a default is used.  This default is normally @code{peer}, but
there are a few exceptions, described below.

@itemize @bullet

@item
The ownership modifier of immutable types defaults to @code{readonly}.
Currently, the set of immutable types only includes the Java wrapper
types for primitive types (e.g. @code{java.lang.Integer} and
@code{java.lang.Long}), @code{java.lang.String}, @code{java.lang.Class},
and @code{java.math.BigInteger}.

@item
The ownership modifiers of local variable declarations are propagated
from the initializer expression.
If no initializer is present, the other defaults are applied.

@item
The ownership modifiers of field declarations are propagated from the
initializer expression.
If no initializer is present, the other defaults are applied.
If a field type was already used to determine the ownership modifier of
some other field, i.e. it was used in the initializer expression of some
other field, then the type can not be changed any more and the normal
@code{peer} default is used.

@item
@cindex pure methods, default ownership modifiers for parameter types of
The default modifier for explicit formal parameters to a @code{pure}
method (but not for the receiver, @code{this}) is
@code{readonly}.
(Note that this is not the case for pure constructors, however.)

@item
The parameter and return types of overriding methods take the
ownership modifiers of the overridden method, if no ownership modifier
is specified.
If an incompatible ownership modifier is used in an overriding method,
an error is raised.

@c WMD removed this, would this default be more useful than 
@c the usual @peer?
@c @item
@c @cindex model fields, default ownership modifiers for types of
@c The default ownership modifier for the type of a model field is
@c @code{readonly}. 

@item
@cindex @code{instanceof}, default ownership modifiers for
The default ownership modifier for a type in the @code{throws} clause
of a method header, and in the declaration of a @code{catch} clause of
a @code{try} statement is @code{readonly} [Dietl-Mueller04].

@item
@cindex array types, default ownership modifiers for
If, for a type that is an array of references,
one of the two ownership modifiers is omitted,
then the element type is used to determine the meaning of the ownership
modifier.
If the element type is a mutable type, then
the specified modifier is taken to be the element modifier, and
the array's modifier defaults to @code{peer}.
If the element type is an immutable type, then
the specified modifier is taken to be the array modifier, and
the element modifier defaults to @code{readonly}.
For example, the type @code{readonly Object[]} is the same as
@code{peer readonly Object[]}.
A type @code{rep Integer[]} is the same as @code{rep readonly Integer[]}.
Note that if one wants to specify a @code{rep} or @code{readonly} array
of mutable references, one is thus forced to use two ownership modifiers;
for example, @code{rep readonly Object[]}.


@item
@cindex cast expressions, default ownership modifiers for types in
In a cast expression of the form @code{(}@i{T}@code{)}@i{E},
where @i{T} is a reference type that is not an array type,
the default ownership modifier of @i{T} is the ownership modifier of
the type of @i{E}; in this case, if the type of @i{E} is an array
type, this is the ownership modifier of the array object itself, not
the ownership modifier of the elements.

In a cast expression of the form @code{(}@i{T}@code{)}@i{E},
where @i{T} is an array type,
the default ownership modifiers of @i{T} are the same as the ownership
modifiers of the type of @i{E}.

In a cast expression of the form @code{(}@i{T}@code{)}@i{E},
where @i{T} is a primitive value type, there is no ownership
modifier attached to @i{T}.

@item
@cindex @code{instanceof}, default ownership modifiers for types in
In an @code{instanceof} expression of the form @i{E} @code{instanceof} @i{T},
where @i{T} is a reference type that is not an array type,
the default ownership modifier of @i{T} is the ownership modifier of
the type of @i{E}; in this case, if the type of @i{E} is an array
type, this is the ownership modifier of the array object itself, not
the ownership modifier of the elements.

In an @code{instanceof} expression of the form @i{E} @code{instanceof} @i{T},
where @i{T} is an array type,
the default ownership modifiers of @i{T} are the same as the ownership
modifiers of the type of @i{E}.
@end itemize

@cindex Dietl
@cindex M@"uller
The defaults for casts and instanceof expressions allow one to only
test for Java types, if the ownership modifiers are omitted
[Dietl-Mueller05].
@xref{Casts and Ownership Types}, for more details on these
expressions and their interaction with the Universe type system.

@c WMD would not say that @code{this} is defaulted, it's fixed.
@c An important example of the general default is that the ownership modifier of
@c @code{this} is always @code{peer}.


@node Ownership Type Rules, Casts and Ownership Types, Default Ownership Modifiers, Universe Type System
@c  node-name,  next,  previous,  up
@section Ownership Type Rules

This section explains details of how the Universe type system does
type checking.

@menu
* Ownership Subtyping::         
* Ownership Typing for Expressions::  
@end menu

@node Ownership Subtyping, Ownership Typing for Expressions, Ownership Type Rules, Ownership Type Rules
@c  node-name,  next,  previous,  up
@subsection Ownership Subtyping

@cindex ownership types, and subtyping
@cindex subtyping, for ownership types
@cindex Dietl
@cindex M@"uller
Type checking in the Universe type system uses a notion of subtyping
that extends Java's rules to take @var{ownership-modifiers} into
account (see Section 3 of [Dietl-Mueller05]).

If two types have the same ownership modifiers,
then they are subtypes if the underlying Java types are subtypes.
For example, @code{rep Stack} is a subtype of @code{rep Object},
because @code{Stack} is a subtype of @code{Object}.

If @i{S} is a reference type, then both @code{peer} @i{S} and @code{rep}
@i{S} are subtypes of the type @code{readonly} @i{S}. Moreover, both
@code{peer} @i{om} @i{S}@code{[]} and @code{rep} @i{om} @i{S}@code{[]}
are subtypes of the type @code{readonly} @i{om} @i{S}@code{[]}, where
@i{om} is any ownership modifier. For instance, @code{peer peer
Natural[]} is a subtype of @code{readonly peer Natural[]}.

The types @code{peer} @i{S} and @code{rep} @i{S} as well as the array
types @code{peer} @i{om} @i{S}@code{[]} and @code{rep} @i{om}
@i{S}@code{[]} are incomparable---neither is a subtype of the other. 

@cindex Dietl
@cindex M@"uller
@cindex subtyping, for arrays, with ownership types
Like Java, the Universe type system has covariant array subtyping:
``two array types
with the same ownership modifier are subtypes if their element types
are subtypes. @dots{}
For instance, @code{rep peer Object[]} is a subtype of
@code{rep readonly Object[]}
because the element type @code{peer Object} is a subtype of the element type
@code{readonly Object}'' (Section 3 of [Dietl-Mueller05]).

@node Ownership Typing for Expressions,  , Ownership Subtyping, Ownership Type Rules
@c  node-name,  next,  previous,  up
@subsection Ownership Typing for Expressions

@cindex type checking, with ownership types
@cindex ownership types and type checking
Most of the typing rules for the Universe type system are unchanged
from standard Java (and JML) rules.
For example, to type check an assignment expression, one checks that
the type of the right hand side expression is a subtype of the type of
the left hand side.

@kindex @code{new}
A small, but important change, is that
the type given in a @code{new} expression must be a @code{rep} or
@code{peer} type.  The result type of the @code{new} expression has
the given ownership modifier.

@cindex field access, and ownership typing rules
@cindex method calls, and ownership typing rules
@cindex formal parameters, and ownership typing rules
The main difference is that the type of field accesses, method
parameters, and method results is determined by combining the type of
the receiver, @i{R}, and the type of the field, the return type of the method, or the type of the formal parameter, @i{F}.
The Java type is taken from the type @i{F}, and the modifier is
determined by the following cases (see Section 3 of [Dietl-Mueller05]):
@enumerate
@item
If both @i{R} and @i{F} are @code{peer} types, then the combination is
also a @code{peer} type.
For example, if @code{myList} has type @code{peer List} and the field
@code{head} has type @code{peer Node}, then @code{myList.head} has
type @code{peer Node}.

@item
If the receiver is @code{this} and @i{F} is a @code{rep} type,
then the combination is a @code{rep} type.
For example, if a @code{Set} class has
an instance field @code{elems} of type @code{rep List},
then in its instance methods, @code{this.elems} has type @code{rep List}.

@item
If @i{R} is a @code{rep} type and @i{F} is a @code{peer} type,
then the combination is a @code{rep} type.
For example, @code{(this.elems).head} has type @code{rep Node},
because the receiver @code{this.elems} has type @code{rep List},
and the type of field @code{head} is @code{peer Node}.

@item
Otherwise, the combination is a @code{readonly} type.
For example, if @code{e} has type @code{readonly List}, then
@code{e.head} has type @code{readonly Node}.
@end enumerate

One can also illustrate these rules using method calls.
For example, consider a method @code{lastNode} with the following signature.
@example
   public peer Node lastNode()
@end example
In this example, if @code{elems} has type @code{rep List},
then a call such as @code{elems.lastNode()} has type @code{rep Node}
(by case 3).

As another example, consider a method @code{addNode} with the
following signature. 
@example
   public void addNode(peer Node n)
@end example
Still assuming that @code{elems} has type @code{rep List},
a call such as @code{elems.addNode(p)}, requires that @code{p} has
type @code{rep Node}
(also by case 3),
because the argument, @code{p}, has to have the same owner as the
receiver of call, @code{elems}, namely @code{this}.

The rules are analogous for arrays.
For example, suppose that an instance field @code{a} has type
@code{rep readonly Object[]}. 
Then the expression @code{this.a} has the same type,
@code{rep readonly Object[]} (by case 2).
Similarly, if @code{r} has a @code{readonly} type,
then @code{r.a} would have type 
@code{readonly readonly Object[]} (by case 4).

Finally, consider a static method that returns a @code{peer} object, such as
the following, in a class @code{Cache}.
@example
   public static peer int[] getInstance()
@end example
A call such as @code{peer Cache.getInstance()} has type
@code{peer int[]}
(by case 1).

@node Casts and Ownership Types,  , Ownership Type Rules, Universe Type System
@c  node-name,  next,  previous,  up
@section Casts and Ownership Types

@cindex casts, and ownership types
Since @code{readonly} types are supertypes of the corresponding
@code{rep} and @code{peer} types, it is possible to do a downcast.
Such a downcast will succeed when the object is in the context
specified by the peer or rep type.
For example, suppose @code{ro} has type @code{readonly List}.
Then the cast @code{(rep List) ro} will succeed only if the
object referenced by @code{ro} is owned by @code{this}.
The cast @code{(peer List) ro} will succeed only if the
object referenced by @code{ro} is owned by the owner of @code{this}.

@cindex @code{instanceof}, and ownership types
Instanceof expressions of the form @i{E} @code{instanceof} @i{T}
yield true when the value of @i{E} is not @code{null}
and the corresponding cast would succeed.
For example, suppose @code{ro} has type @code{readonly List}.
Then @code{ro instanceof rep List} yields true only if
@code{ro} references an object that is owned by @code{this}.

Both casts and instanceof expressions have runtime overhead, in
general.  (Furthermore, as in Java, array updates also generate
runtime checks.)

See [Dietl-Drossopoulou-Mueller07] [Dietl-Mueller-Schregenberger08] for
a complete list of the Universe type system rules and the different
supported compiler options.


@c ------- chapter Safe Math Extensions to JML ----------------
@node Safe Math Extensions, Deprecated and Replaced Syntax, Universe Type System, Top
@c  node-name,  next,  previous,  up
@chapter Safe Math Extensions

@menu
* Backslash bigint::            
* Backslash real::              
@end menu

@node Backslash bigint, Backslash real, Safe Math Extensions, Safe Math Extensions
@comment  node-name,  next,  previous,  up
@section \bigint
[[[ needs discussion ]]]

@node Backslash real,  , Backslash bigint, Safe Math Extensions
@comment  node-name,  next,  previous,  up
@section \real
[[[ needs discussion ]]]

@c --------- chapter Deprecated -----------
@node Deprecated and Replaced Syntax, Grammar Summary, Safe Math Extensions, Top
@comment  node-name,  next,  previous,  up
@chapter Deprecated and Replaced Syntax

@cindex deprecated syntax
@cindex syntax, deprecated
The subsections below briefly describe the
deprecated and replaced features of JML.
A feature is @dfn{deprecated} if it is supported in the current release,
but slated to be removed from a subsequent release.
Such features should not be used.

@cindex replaced syntax
@cindex syntax, replaced
A feature that was formerly deprecated is @dfn{replaced} if it has
been removed from JML in favor of some other feature or features.
While we do not describe all replaced syntax in this appendix, we do
mention a few of the more interesting or important features that were
replaced, especially those discussed in earlier papers on JML.

@menu
* Deprecated Syntax::           
* Replaced Syntax::             
@end menu

@node Deprecated Syntax, Replaced Syntax, Deprecated and Replaced Syntax, Deprecated and Replaced Syntax
@comment  node-name,  next,  previous,  up
@section Deprecated Syntax

The following syntax is deprecated.
@c (Note that incompatible changes and syntax that
@c is no longer supported is not included in this list.)

@c There is currently no deprecated syntax.

@node Replaced Syntax,  , Deprecated Syntax, Deprecated and Replaced Syntax
@comment  node-name,  next,  previous,  up
@section Replaced Syntax

@kindex @code{subclassing_contract}, replaced by @code{code_contract}
As a note for readers of older papers, 
the keyword @code{subclassing_contract} was replaced with
@code{code_contract}, which is now removed.
Instead, one should use
a heavyweight specification case with the keyword @code{code}
just before the behavior keyword, and a precondition of @code{\same}.

@kindex @code{depends}, replaced by @code{in} and @code{maps}
Similarly, the @code{depends} clause has been replaced by the
mechanism of data groups and the @code{in} and @code{maps} clauses of
variable declarations.

@c --------- chapter Grammar Summary -----------
@node Grammar Summary, Modifier Summary, Deprecated and Replaced Syntax, Top
@c  node-name,  next,  previous,  up
@appendix Grammar Summary

The following is a summary of the context-free grammar for JML.
@xref{Syntax Notation}, for the notation used.
In the first section below,
grammatical productions are to be understood lexically.
That is, no white space (@pxref{White Space}) may intervene between the
characters of a token.

@include collected-grammar.texinfo

@c --------- chapter Modifier Summary -----------
@node Modifier Summary, Type Checking Summary, Grammar Summary, Top
@c  node-name,  next,  previous,  up
@appendix Modifier Summary

@cindex modifiers, summary of
This table summarizes which Java and JML modifiers may be used in 
various grammatical contexts.

@multitable @columnfractions .33 .05 .29 .05 .30

@item Grammatical construct @tab @tab Java modifiers @tab @tab JML modifiers

@item All modifiers
@tab
@tab @code{public protected private abstract static final synchronized transient volatile native strictfp}
@tab
@tab @code{spec_public spec_protected model ghost pure instance helper non_null nullable nullable_by_default monitored uninitialized}

@item

@item Class declaration
@tab
@tab @code{public final abstract strictfp}
@tab
@tab @code{pure model nullable_by_default spec_public spec_protected}

@item

@item Interface declaration
@tab
@tab @code{public strictfp}
@tab
@tab @code{pure model nullable_by_default spec_public spec_protected}

@item

@item Nested Class declaration
@tab
@tab @code{public protected private static final abstract strictfp}
@tab
@tab @code{spec_public spec_protected model pure}

@item

@item Nested interface declaration
@tab
@tab @code{public protected private static strictfp}
@tab
@tab @code{spec_public spec_protected model pure}

@item

@item Local Class (and local model class) declaration
@tab
@tab @code{final abstract strictfp}
@tab
@tab @code{pure model}

@item

@item Type specification (e.g. invariant)
@tab
@tab @code{public protected private static}
@tab
@tab @code{instance}

@item

@item Field declaration
@tab
@tab @code{public protected private final volatile transient static}
@tab
@tab @code{spec_public spec_protected non_null nullable instance monitored}

@item

@item Ghost Field declaration
@tab
@tab @code{public protected private static final}
@tab
@tab @code{non_null nullable instance monitored}

@item

@item Model Field declaration
@tab
@tab @code{public protected private static}
@tab
@tab @code{non_null nullable instance}

@item

@item Method declaration in a class
@tab
@tab @code{public protected private abstract final static synchronized native strictfp}
@tab
@tab @code{spec_public spec_protected pure non_null nullable helper extract}

@item 

@item Method declaration in an interface
@tab
@tab @code{public abstract}
@tab
@tab @code{spec_public spec_protected pure non_null nullable helper}

@item

@item Constructor declaration
@tab
@tab @code{public protected private}
@tab
@tab @code{spec_public spec_protected helper pure extract}

@item

@item Model method (in a class or interface)
@tab
@tab @code{public protected private abstract static final synchronized strictfp}
@tab
@tab @code{pure non_null nullable helper extract}

@item

@item Model constructor
@tab
@tab @code{public protected private}
@tab
@tab @code{pure helper extract}

@item

@item Java initialization block 
@tab
@tab @code{static}
@tab
@tab -

@item JML initializer and static_initializer annotation 
@tab
@tab -
@tab
@tab -

@item

@item Formal parameter 
@tab
@tab @code{final}
@tab
@tab @code{non_null nullable}

@item

@item Local variable and local ghost variable declaration
@tab
@tab @code{final}
@tab
@tab @code{ghost non_null nullable uninitialized}

@end multitable

Note that within interfaces, fields are implicitly public, static and
final [Gosling-etal00].
In an interface, ghost and model fields are implicitly public and
static, though they may be declared as @code{instance} fields, which
makes them not static.

Also within an interface, methods may not be static and are implicitly
abstract.  Model methods in interfaces, however, are not implicitly 
abstract and may be declared static.

@c --------- chapter Type Checking Summary -----------
@node Type Checking Summary, Verification Logic Summary, Modifier Summary, Top
@c  node-name,  next,  previous,  up
@appendix Type Checking Summary

[[[Hope to generate this automatically]]]

@c --------- chapter Verification Logic Summary -----------
@node Verification Logic Summary, Differences, Type Checking Summary, Top
@c  node-name,  next,  previous,  up
@appendix Verification Logic Summary

[[[Hope to generate this automatically]]]


@c --------- chapter Differences -----------
@node Differences, Bibliography, Verification Logic Summary, Top
@comment  node-name,  next,  previous,  up
@appendix Differences

The subsections below detail the differences between the JML Common Tools
release of JML and other tools and between JML and Java itself.

@menu
* Differences Between JML and Other Tools::  
* Differences Between JML and Java::  
@end menu

@node Differences Between JML and Other Tools, Differences Between JML and Java, Differences, Differences
@comment  node-name,  next,  previous,  up
@appendixsec Differences Between JML and Other Tools

@cindex ESC/Java, differences from JML
@cindex ESC/Java2, differences from JML
@cindex Stata
@cindex Cok
@cindex Kiniry
@cindex Leino
@cindex Nelson
@cindex Saxe
ESC/Java [Leino-Nelson-Saxe00] and JML share a common syntax; this is
even more true of ESC/Java2 and JML.  The initial efforts to merge
syntaxes were due to the efforts of Raymie Stata.  After a long
process, the syntax of ESC/Java and JML were both changed and JML was
nearly a superset of ESC/Java when work on ESC/Java stopped with
ESC/Java 1.2.4. Following the open-source release of ESC/Java, Kiniry
and Cok began work on ESC/Java2, which is now very compatible with
JML's syntax [Kiniry-Cok04].  Users can thus use both tools with
little or no changes to their files.

@cindex Daikon
Similarly the Daikon tool [Ernst-etal01] also uses a variant of JML's
syntax, as do several other tools [Burdy-etal03].  While efforts are
ongoing to avoid differences, some differences are unavoidable, as
research is ongoing (and people have other things to do).

We discuss the differences between the JML language described in this
manual and the variants used in these other tools below.

@menu
* Differences Between JML and ESC/Java2::  
@end menu

@node Differences Between JML and ESC/Java2,  , Differences Between JML and Other Tools, Differences Between JML and Other Tools
@comment  node-name,  next,  previous,  up
@appendixsubsec Differences Between JML and ESC/Java2

This section discusses the current state of affairs of ESC/Java2
compatibility with JML's syntax.

The following differences remain between ESC/Java2 and JML.

@itemize @bullet

@item ESC/Java2 is tolerant (with a suppressible warning) of missing semicolons
at the ends of annotations, in many circumstances.

@item ESC/Java2 does not enforce the visibility modifiers.

@item ESC/Java2 strictly requires whole syntactic constructs within a single
annotation comment; JML tools are more lenient.

@item JML and ESC/Java2 differ in the search order for refinement files in 
the classpath.

@item JML and ESC/Java2 differ in where @code{helper} annotations are permitted.

@item JML does not support model classes (at least in runtime assertion checking).

@item ESC/Java2 reads but ignores model programs.

@end itemize

The following differences between ESC/Java2 and JML are designed to
remain differences.  While the plan is for ESC/Java2 to parse all of
JML's syntax, there are times when one needs to write annotations for
one of these tool that are not understood by the other.
Thus these differences are intended to allow users of both tools to write
such annotations. 

@itemize @bullet
@item
JML supports annotation forms @code{//+@@} and @code{/*+@@}
... @code{@@+*/}, so that annotations that JML understands but
ESC/Java doesn't can be written.

@item
ESC/Java2 supports annotation forms @code{//-@@} and @code{/*-@@}
... @code{@@-*/}, so that annotations that ESC/Java2 understands but
JML doesn't can be written.

@end itemize

@node Differences Between JML and Java,  , Differences Between JML and Other Tools, Differences
@comment  node-name,  next,  previous,  up
@appendixsec Differences Between JML and Java

This section describes differences between JML and Java without JML.
Currently the major differences are the way that JML treats
@code{null}.

@menu
* Non-null by Default::         
@end menu

@node Non-null by Default,  , Differences Between JML and Java, Differences Between JML and Java
@comment  node-name,  next,  previous,  up
@subsection Non-null by Default

@kindex @code{non_null}
@kindex @code{nullable}
@kindex @code{nullable_by_default}
As described earlier (@pxref{Null is Not the Default}),
JML does not, by default, allow @code{null} to be a value in a field,
formal parameter, method or a bound variable (@pxref{Modifiers for Bound Variables}).  
To allow @code{null} as
a value, one has to use the @code{nullable} modifier on the
declaration, or the @code{nullable_by_default} modifier on the type
where the declaration occurs
@xref{Nullity Modifiers}, for more details.

@c --------- chapter What's Missing -----------
@c  node-name,  next,  previous,  up
@appendix What's Missing

What is missing from this reference manual?

The following constructs are not discussed at all:
@itemize @bullet
@item @code{abrupt_behavior}
@item @code{breaks} and @code{breaks_redundantly}
@item @code{choose} and @code{choose_if}
@item @code{continues} and @code{continues_redundantly}
@item @code{example} and @code{exceptional_example}
@item @code{implies_that}
@item @code{hence_by} and @code{hence_by_redundantly}
@item @code{model_program}
@item @code{returns} and @code{returns_redundantly}
@item @code{weakly} xxx
@end itemize

Other stuff not to forget - DRCok
@itemize @bullet
@item \not_specified
@item \nothing
@item \everything
@item nowarn annotation
@item methods and constructors without bodies in java files
@item methods and constructors with bodies in specification files
@item methods and constructors in annotation expressions - purity - modifies clauses - various checking
@item anonymous and block-level classes
@item field, method, constructor keywords
@item exceptions in annotation expressions
@end itemize

@c Note that the bibliography has to be unnumbered, it can't be an
@c appendix section, if we are to have the proper cross refs in HTML format.
@c --------- chapter Bibliography -----------
@node Bibliography, Example Index, Differences, Top
@comment  node-name,  next,  previous,  up
@unnumbered Bibliography

@table @asis
@item [America87]
Pierre America.
Inheritance and Subtyping in a Parallel Object-Oriented Language.
In Jean Bezivin and others (eds.),
@cite{ECOOP '87, European Conference on Object-Oriented Programming,
Paris, France}.
Lecture Notes in Computer Science, Vol. 276
(Springer-Verlag, NY), pages 234-242.

@item [Arnold-Gosling-Holmes00]
Ken Arnold, James Gosling, and David Holmes.
@cite{The Java Programming Language Third Edition}.
The Java Series. Addison-Wesley, Reading, MA, 2000.

@item [ANSI95]
@cite{Working Paper for Draft Proposed International Standard
for Information Systems --- Programming Language C++}.
CBEMA, 1250 Eye Street NW, Suite 200, Washington DC 20005, April 28, 1995.
(Obtained by anonymous ftp to research.att.com, directory dist/c++std/WP.)

@item [Back88]
R. J. R. Back.
A calculus of refinements for program derivations.
@cite{Acta Informatica}, @b{25}(6):593-624, August 1988.

@item [Back-vonWright89a]
R. J. R. Back and J. von Wright.
Refinement Calculus, Part I: Sequential Nondeterministic Programs.
In J. W. de Bakker, et al, (eds.),
@cite{Stepwise Refinement of Distributed Systems,
Models, Formalisms, Correctness, REX Workshop}, Mook, The Netherlands,
May/June 1989, pages 42-66.
Volume 430 of @cite{Lecture Notes Computer Science},
Spring-Verlag, 1989.

@c @item [Back-Mikhajlova-vonWright98]
@c Ralph Back, Anna Mikhajlova, and Joakim von Wright.
@c Modeling component environments and interactive programs using
@c   iterative choice.
@c Technical Report 200, Turku Centre for Computer Science, September
@c   1998.@*
@c   @file{http://www.tucs.abo.fi/publications/techreports/TR200.html}.

@item [Back-vonWright98]
Ralph-Johan Back and Joakim von Wright.
@cite{Refinement Calculus: A Systematic Introduction}.
Springer-Verlag, 1998.

@item [Borgida-etal95]
Alex Borgida, John Mylopoulos, and Raymond Reiter.
On the Frame Problem in Procedure Specifications.
@cite{IEEE Transactions on Software Engineering},
@b{21}(10):785-798, October 1995.

@item [Boyland00]
John Boyland.
Alias burying: Unique variables without destructive reads.
@cite{Software---Practice and Experience},
@b{31}(6):533-553, May 2001.

@item [Buechi-Weck00]
Martin B@"uchi and Wolfgang Weck.
The Greybox Approach: When Blackbox Specifications Hide Too Much.
Technical Report 297, Turku Centre for Computer Science, August 1999.@*
  @file{http://www.tucs.abo.fi/publications/techreports/TR297.html}.

@item [Buechi00]
Martin B@"uchi.
Safe Language Mechanisms for Modularization and Concurrency.
Ph.D. Thesis, Turku Center for Computer Science, May 2000.
TUCS Dissertations No. 28.

@item [Burdy-etal03]
Lilian Burdy,  Yoonsik Cheon,  David Cok,  
Michael Ernst,  Joe Kiniry,  Gary T. Leavens,  
K. Rustan M. Leino, and Erik Poll.
An overview of JML tools and applications.
Dept. of Computer Science, University of Nijmegen, TR NIII-R0309, 2003.@*
  @file{http://www.eecs.ucf.edu/~leavens/JML/OldReleases/jml-white-paper.pdf}.

@c @item [Chalin95]
@c Patrice Chalin. On the Language Design and Semantic Foundation of LCL,
@c a Larch/C Interface Specification Language. PhD thesis, Computer
@c Science Department, Concordia University, October 1995.
@c Also Technical Report CU/DCS TR 95-12,
@c which can be obtained from the URL@*
@c @file{ftp://ftp.cs.concordia.ca/pub/chalin/tr.ps.Z}.

@item [Chalin07]
Patrice Chalin.
A Sound Assertion Semantics for the Dependable Systems Evolution Verifying Compiler.
@cite{Proceedings of the International Conference on Software Engineering (ICSE)}, 
Minneapolis, MN, USA, 2007.

@item [Chalin-Rioux05]
Patrice Chalin and Frederic Rioux.
Non-null References by Default in the Java Modeling Language.
In Proceedings of the Workshop on the Specification and Verification
of Component-Based Systems (SAVCBS'05), Lisbon, Portugal.
September, 2005.
An updated version is available as
Department of Computer Science, Concordia University,
ENCS-CSE TR 2005-004, December 2005,
which is available from the URL@*
@file{http://www.cs.concordia.ca/~chalin/papers/TR-2005-004-r3.2.pdf}.

@item [Cheon-Leavens02]
Yoonsik Cheon and Gary T. Leavens.
A Simple and Practical Approach to Unit Testing: The JML and JUnit Way.
In @cite{ECOOP 2002 -- Object-Oriented Programming,
16th European Conference, Malaga, Spain}, pages 231--255.
Springer-Verlag, June 2002.
Also
Department of Computer Science, Iowa State University,
TR #01-12a, November 2001, revised March 2002,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR01-12/TR.pdf}.

@item [Cheon-Leavens02b]
Yoonsik Cheon and Gary T. Leavens.
A Runtime Assertion Checker for the Java Modeling Language (JML).
In Hamid R. Arabnia and Youngsong Mun (eds.),
@cite{Proceedings of the International Conference on Software
Engineering Research and Practice (SERP '02), Las Vegas, Nevada, USA},
pages 322--328. 
CSREA Press, June 2002.
Also
Department of Computer Science, Iowa State University,
TR #02-05, March 2002,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR02-05/TR.pdf}.

@item [Cheon-etal05]
Yoonsik Cheon, Gary T. Leavens, Murali Sitaraman, and Stephen Edwards. 
Model Variables: Cleanly Supporting Abstraction in Design By Contract. 
@cite{Software---Practice and Experience},
@b{35}(6):583-599, May 2005.
Also Department of Computer Science, Iowa State University, TR
03-10, March 2003.@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR03-10/TR.pdf}.

@item [Cheon03]
Yoonsik Cheon.
A Runtime Assertion Checker for the Java Modeling Language.
Department of Computer Science, Iowa State University, TR 03-09, April, 2003.@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR03-09/TR.pdf}

@item [Clifton-etal00]
Curtis Clifton, Gary T. Leavens, Craig Chambers, and Todd Millstein.
MultiJava: Modular Open Classes and Symmetric Multiple Dispatch for Java.
In @cite{OOPSLA 2000 Conference on Object-Oriented Programming,
         Systems, Languages, and Applications, Minneapolis, Minnesota}
(@cite{ACM SIGPLAN Notices}, @b{35}(10):130-145, October 2000).

@item [Cohen90]
Edward Cohen.
@cite{Programming in the 1990s: An Introduction to the Calculation of Programs}.
Springer-Verlag, New York, N.Y., 1990.

@item [Corbett-etal00]
James C. Corbett, Matthew B. Dwyer, John Hatcliff, Shawn Laubach,
Corina S. Pasareanu, Robby, and Hongjun Zheng. 
Bandera: Extracting Finite-State Models from Java Source Code.
In S. Brookes and M. Main and A. Melton and M. Mislove (eds.),
@cite{Proceedings of the 22nd International Conference on
                 Software Engineering}, pp. 439-448,
ACM Press, 2000.

@item [Dhara-Leavens94b]
Krishna Kishore Dhara and Gary T. Leavens.
Weak Behavioral Subtyping for Types with Mutable Objects.
In S. Brookes and M. Main and A. Melton and M. Mislove (eds.),
@cite{Mathematical Foundations of Programming Semantics,
Eleventh Annual Conference},
Volume 1 of @cite{Electronic Notes in Computer Science},
Elsevier, 1995.
@file{http://www.sciencedirect.com/science/journal/15710661}.

@item [Dhara-Leavens96]
Krishna Kishore Dhara and Gary T. Leavens.
Forcing Behavioral Subtyping Through Specification Inheritance.
In @cite{Proceedings 18th International Conference on Software Engineering},
Berlin, Germany, pages 258-267.
IEEE 1996.
An extended version is
Department of Computer Science, Iowa State University,
TR #95-20b, December 1995,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR95-20/TR.ps.Z}.

@item [Dhara97]
Krishna Kishore Dhara.
Behavioral Subtyping in Object-Oriented Languages.
Ph.D. Thesis, Department of Computer Science, Iowa State University.
Also Technical Report TR #97-09, May 1997.
Available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR97-09/TR.ps.gz}.

@item [Dietl-Drossopoulou-Mueller07]
Werner Dietl, Sophia Drossopoulou and Peter M@"uller.
Generic Universe Types.
In E. Ernst, editor, @cite{European Conference on Object-Oriented Programming (ECOOP)}
pages 28--53, 2007.
Available from @*
@file{http://sct.inf.ethz.ch/publications/getpdf.php?bibname=Own&id=DietlDrossopoulouMueller07a.pdf}.

@item [Dietl-Mueller04]
Werner Dietl and Peter M@"uller.
Exceptions in ownership type systems.
In E. Poll, editor, @cite{Formal Techniques for Java-like Programs}
pages 49--54, 2004.
Available from @*
@file{http://sct.inf.ethz.ch/publications/getpdf.php?bibname=Own&id=DietlMueller04.pdf}.

@item [Dietl-Mueller05]
Werner Dietl and Peter M@"uller.
Universes: Lightweight Ownership for JML.
@cite{Journal of Object Technology}, @b{4}(8):5--32, October 2005.
Available from @*
@file{http://www.jot.fm/issues/issue_2005_10/article1.pdf}.

@item [Dietl-Mueller-Schregenberger08]
Werner Dietl, Peter M@"uller and Daniel Schregenberger.
Universe Type System --- Quick-Reference.
Available from @*
@file{http://sct.inf.ethz.ch/research/universes/tools/juts-quickref.pdf}.

@item [Dijkstra76]
Edsger W. Dijkstra.
@cite{A Discipline of Programming}
(Prentice-Hall, Englewood Cliffs, N.J., 1976).

@item [Edwards-etal94]
Stephen H. Edwards, Wayne D. Heym, Timothy J. Long, Murali Sitaraman,
and Bruce W. Weide.
Part II: Specifying Components in RESOLVE.
@cite{ACM SIGSOFT Software Engineering Notes},
@b{19}(4):29-39, October 1994.

@item [Ernst-etal01]
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin.
Dynamically discovering likely program invariants to support program evolution.
@cite{IEEE Transactions on Software Engineering}, @b{27}(2):1-25, February 2001.

@c @item [Ernst-etal91]
@c G. W. Ernst, R. J. Hookway, J. A. Menegay, and W. F. Ofgen.
@c Modular Verification of Ada Generics.
@c @cite{Computer Languages},
@c 16(3/4):259-280 (1991).

@item [Fitzgerald-Larsen98]
John Fitzgerald and Peter Gorm Larsen.
@cite{Modelling Systems: Practical Tools and Techniques in Software Development}.
Cambridge University Press, Cambridge, UK, 1998.

@c @item [Goguen84]
@c Joseph A. Goguen.
@c Parameterized Programming.
@c @cite{IEEE Transactions on Software Engineering},
@c 10(5):528-543 (Sept. 1984).

@item [Gosling-etal00]
James Gosling, Bill Joy, Guy Steele, and Gilad Bracha.
@cite{The Java Language Specification Second Edition}.
The Java Series. Addison-Wesley, Boston, MA, 2000.

@item [Gries-Schneider95]
David Gries and Fred B. Schneider.
Avoiding the Undefined by Underspecification.
In Jan van Leeuwen, editor,
@cite{Computer Science Today: Recent Trends and Developments},
volume 1000 of @cite{Lecture Notes in Computer Science}, pages 366--373.
Springer-Verlag, New York, N.Y., 1995.

@c @item [Guaspari-Marceau-Polak90]
@c David Guaspari, Carla Marceau, and Wolfgang Polak.
@c Formal Verification of Ada Programs.
@c @cite{IEEE Transactions on Software Engineering},
@c @b{16}(9):1058-1075, September 1990.

@item [Guttag-Horning-Wing85b]
John V. Guttag and James J. Horning and Jeannette M. Wing.
The Larch Family of Specification Languages.
@cite{IEEE Software}, @b{2}(5):24-36, September 1985.

@item [Guttag-Horning93]
John V. Guttag and James J. Horning with S.J. Garland,
K.D. Jones, A. Modet and J.M. Wing.
@cite{Larch: Languages and Tools for Formal Specification}
(Springer-Verlag, NY, 1993).

@item [Hall90]
Anthony Hall.
Seven Myths of Formal Methods.
@cite{IEEE Software}, @b{7}(5):11-19, September 1990.

@item [Hayes93]
I. Hayes (ed.),
@cite{Specification Case Studies}, second edition
(Prentice-Hall, Englewood Cliffs, N.J., 1990).

@item [Hesselink92]
Wim H. Hesselink.
@cite{Programs, Recursion, and Unbounded Choice}
(Cambridge University Press, Cambridge, UK, 1992).

@item [Hoare69]
C. A. R. Hoare.
An Axiomatic Basis for Computer Programming.
@cite{Comm. ACM}, @b{12}(10):576-583, October 1969.

@item [Hoare72a]
C. A. R. Hoare.
Proof of correctness of data representations.
@cite{Acta Informatica}, @b{1}(4):271-281, 1972.

@item [Huisman01]
Marieke Huisman. 
Reasoning about JAVA programs in higher order logic with PVS and Isabelle.
IPA dissertation series, 2001-03.
Ph.D. dissertation, University of Nijmegen, 2001.

@item [ISO96]
International Standards Organization.
@cite{Information Technology - Programming Languages, Their
Environments and System Software Interfaces - 
Vienna Development Method - Specification Language - Part 1: Base language}.
International Standard ISO/IEC 13817-1, December, 1996.

@item [Khurshid-Marinov-Jackson02]
Sarfraz Khurshid and Darko Marinov and Daniel Jackson.
An Analyzable Annotation Language.
In @cite{Proceedings of OOPSLA '02 Conference on Object-Oriented
Programming, Languages, Systems, and Applications}.
(@cite{ACM SIGPLAN Notices}, @b{37}(11):231--245, October 2002).

@item [Jacobs-etal98]
Bart Jacobs, Joachim van den Berg, Marieke Huisman, Martijn van
Berkum, Ulrich Hensel, and Hendrik Tews.
Reasoning about Java Classes (Preliminary Report)
In @cite{OOPSLA '98 Proceedings}
(@cite{ACM SIGPLAN Notices}, @b{33}(10):329-490, October 1998).

@item [Jones90]
Cliff B. Jones.
@cite{Systematic Software Development Using VDM}.
International Series in Computer Science. Prentice Hall, Englewood
  Cliffs, N.J., second edition, 1990.

@item [Jones95e]
C.B. Jones,
Partial functions and logics: A warning.
@cite{Information Processing Letters}, @b{54}(2):65-67, 1995.

@c @item [Jonkers91]
@c H. B. M. Jonkers.
@c Upgrading the pre- and postcondition technique.
@c In S. Prehn and W. J. Toetenel (eds.),
@c @cite{VDM '91 Formal Software Development Methods 4th
@c International Symposium of VDM Europe
@c Noordwijkerhout, The Netherlands, Volume 1:
@c Conference Contributions},
@c volume 551 of Lecture Notes in Computer Science,
@c pages 428-456.
@c Springer-Verlag, NY, 1991.

@item [Kiczales-Lamping92]
Gregor Kiczales and John Lamping.
Issues in the Design and Documentation of Class Libraries.
In Andreas Paepcke (ed.), @cite{OOPSLA '92 Proceedings}
(@cite{ACM SIGPLAN Notices}, @b{27}(10):435-451, October 1992).

@item [Kiniry-Cok04]
Joseph R. Kiniry and David R. Cok.
ESC/Java2: Uniting ESC/Java and JML: Progress and issues in building
and using ESC/Java2 and a report on a case study involving the use of
ESC/Java2 to verify portions of an Internet voting tally system.
In Marieke Huisman (ed.), @cite{CASSIS 2004 - Construction and
Analysis of Safe, Secure and Interoperable Smart devices, Marseille,
France, 2004, Proceedings}, volume 3362 of @cite{Lecture Notes in
Computer Science}, pages 108-128.  Springer-Verlag, 2004.

@item [Krone-Ogden-Sitaraman03]
Joan Krone, William F. Ogden, Murali Sitaraman.
Modular Verification of Performance Constraints.
Technical Report RSRG-03-04,
Department of Computer Science, Clemson University,
May, 2003.  Available from
  @file{http://www.cs.clemson.edu/~resolve/reports/RSRG-03-04.pdf}

@item [Lamport89]
Leslie Lamport.
A Simple Approach to Specifying Concurrent Systems.
@cite{CACM}, @b{32}(1):32-45, January 1989.

@item [LeavensLarchFAQ]
Gary T. Leavens.
Larch frequently asked questions.
Version 1.110. Available in
  @file{http://www.eecs.ucf.edu/~leavens/larch-faq.html}, May 2000.

@item [Leavens-Baker99]
Gary T. Leavens and Albert L. Baker.
Enhancing the pre- and postcondition technique for more expressive
  specifications.
In Jeannette M. Wing, Jim Woodcock, and Jim Davies, editors, @cite{
  FM'99 --- Formal Methods: World Congress on Formal Methods in the
  Development of Computing Systems, Toulouse, France, September 1999,
  Proceedings}, volume 1709 of @cite{Lecture Notes in Computer Science}, pages
  1087--1106. Springer-Verlag, 1999.

@item [Leavens-Baker-Ruby99]
Gary T. Leavens, Albert L. Baker, and Clyde Ruby.
JML: a Notation for Detailed Design.
In Haim Kilov, Bernhard Rumpe, and Ian Simmonds (editors),
@cite{Behavioral Specifications for Businesses and Systems},
chapter 12, pages 175-188.

@item [Leavens-Baker-Ruby06]
Gary T. Leavens, Albert L. Baker, and Clyde Ruby.
Preliminary Design of JML:
  A Behavioral Interface Specification Language for Java.
@cite{ACM SIGSOFT Software Engineering Notes}, @b{31}(3):1-38, March 2006.@*
@file{http://doi.acm.org/10.1145/1127878.1127884}.
Also Iowa State University, Department of Computer Science, TR #98-06-rev29,
January 2006,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR98-06/TR.pdf}.

@item [Leavens-Cheon06]
Gary T. Leavens and Yoonsik Cheon.
Design by Contract with JML.
December, 2006,
which is available from the URL@*
@file{http://www.jmlspecs.org/jmldbc.pdf}.

@item [Leavens-Dhara00]
Gary T. Leavens and Krishna Kishore Dhara.
Concepts of Behavioral Subtyping and a Sketch of Their
Extension to Component-Based Systems.
In Gary T. Leavens and Murali Sitaraman (eds.),
@cite{Foundations of Component-Based Systems},
Cambridge University Press, 2000, pp. 113-135.@*
@file{http://www.eecs.ucf.edu/~leavens/FoCBS-book/06-leavens-dhara.pdf}

@item [Leavens-etal05]
G. T. Leavens, Y. Cheon, C. Clifton, C. Ruby, and D. R. Cok.
How the design of JML accommodates both runtime assertion checking and formal verification
@cite{Science of Computer Programming}, @b{55}(1-3):185-208, 2005.

@item [Leavens-Mueller07]
Gary T. Leavens and Peter M@"uller.
Information Hiding and Visibility in Interface Specifications.
In @cite{International Conference on Software Engineering (ICSE)},
pages 385-395, IEEE, 2007.

@item [Leavens-Naumann06]
Gary T. Leavens and David A. Naumann.
Behavioral Subtyping, Specification Inheritance, and Modular Reasoning.
Department of Computer Science, TR \#06-20b, July 2006, revised
August, September 2006.
Available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR90-09/TR.pdf}.

@item [Leavens-Weihl90]
Gary T. Leavens and William E. Weihl.
Reasoning about Object-oriented Programs that use Subtypes
(extended abstract).
In N. Meyrowitz (ed.), @cite{OOPSLA ECOOP '90 Proceedings}
(@cite{ACM SIGPLAN Notices}, @b{25}(10):212-223, October 1990).

@item [Leavens-Weihl95]
Gary T. Leavens and William E. Weihl.
Specification and Verification of Object-Oriented
Programs Using Supertype Abstraction.
@cite{Acta Informatica}, @b{32}(8):705-778, November 1995.

@item [Leavens-Wing98]
Gary T. Leavens and Jeannette M. Wing.
Protective interface specifications.
@cite{Formal Aspects of Computing}, @b{10}(1):590-75, January 1998.

@item [Leavens90]
Gary T. Leavens.
Modular Verification of Object-Oriented Programs with Subtypes.
Department of Computer Science, Iowa State University (Ames, Iowa, 50011),
TR 90-09, July 1990.
Available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR90-09/TR.ps.Z}.

@item [Leavens91]
Gary T. Leavens.
Modular Specification and Verification of Object-Oriented Programs.
@cite{IEEE Software}, @b{8}(4):72-80, July 1991.

@item [Leavens96b]
Gary T. Leavens.
An Overview of Larch/C++: Behavioral Specifications for C++ Modules.
In Haim Kilov and William Harvey (editors),
@cite{Specification of Behavioral Semantics in Object-Oriented Information
Modeling} (Kluwer Academic Publishers, 1996), Chapter 8, pages 121-142.
An extended version is
Department of Computer Science, Iowa State University,
TR #96-01c, July 1996,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR96-01/TR.ps.Z}.

@item [Leavens97c]
Gary T. Leavens.
@cite{Larch/C++ Reference Manual}.
Version 5.14. Available in@*
@file{http://www.eecs.ucf.edu/~leavens/larchc++.html}, October 1997.

@item [Leavens06b]
Gary T. Leavens.
JML's Rich, Inherited Specifications for Behavioral Subtypes.
In Zhiming Liu and He Jifeng (eds), 
@cite{Proceedings, International Conference on Formal Engineering Methods (ICFEM'06), Macao, China}, pages 2-36.
Volume 4260 of @cite{Lecture Notes in Computer Science},
Springer-Verlag, 2006.
Also Department of Computer Science, Iowa State University,
TR \#06-22, August 2006.@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR06-22/TR.pdf}

@item [Ledgard80]
Henry. F. Ledgard.
A Human Engineered Variant of BNF.
@cite{ACM SIGPLAN Notices}, @b{15}(10):57-62, October 1980.

@item [Leino-Nelson-Saxe00]
K. Rustan M. Leino, Greg Nelson, and James B. Saxe.
ESC/Java User's Manual. Technical Note 2000-02, Systems Research Center,
October, 2000.

@item [Leino-etal00]
K. Rustan M. Leino, Mark Lillibridge, Greg Nelson,
James B. Saxe, and Raymie Stata.
Extended Static Checking. Web page at@*
  @file{http://research.compaq.com/SRC/esc/Esc.html}.

@item [Leino95]
K. Rustan M. Leino.
Towards Reliable Modular Programs.
PhD thesis, California Institute of Technology, January 1995.
Available from the URL@*
@file{ftp://ftp.cs.caltech.edu/tr/cs-tr-95-03.ps.Z}.

@item [Leino95b]
K. Rustan M. Leino.
A myth in the modular specification of programs.
KRML 63, November 1995.
Obtained from the author (rustan@@pa.dec.com).

@item [Leino98]
K. Rustan M. Leino.
Data groups: Specifying the modification of extended state.
@cite{OOPSLA '98 Conference Proceedings}.
(@cite{ACM SIGPLAN Notices}, @b{33}(10):144-153, October 1998).

@item [Lerner91]
Richard Allen Lerner.
Specifying Objects of Concurrent Systems.
School of Computer Science, Carnegie Mellon University,
CMU-CS-91-131, May 1991.
Available from the URL@*
@file{ftp://ftp.cs.cmu.edu/afs/cs.cmu.edu/project/larch/ftp/thesis.ps.Z}.

@item [Liskov-Guttag86]
Barbara Liskov and John Guttag.
@cite{Abstraction and Specification in Program Development}
(MIT Press, Cambridge, Mass., 1986).

@c @item [Liskov-Wing93]
@c Barbara Liskov and Jeannette M. Wing.
@c A new definition of the subtype relation.
@c In Oscar M. Nierstrasz, editor, @cite{ECOOP '93 --- Object-Oriented
@c Programming, 7th European Conference, Kaiserslautern, Germany},
@c volume 707 of @cite{Lecture Notes in Computer Science},
@c pages 118-141. Springer-Verlag, New York, N.Y., July 1993.

@item [Liskov-Wing93b]
Barbara Liskov and Jeannette M. Wing.
Specifications and their use in defining subtypes.
In Andreas Paepcke, editor, @cite{OOPSLA '93 Proceedings}.
(@cite{ACM SIGPLAN Notices} @b{28}(10):16-28, October, 1993.)

@item [Liskov-Wing94]
Barbara Liskov and Jeannette M. Wing.
A Behavioral Notion of Subtyping.
@cite{ACM Transactions on Programming Languages and Systems},
@b{16}(6):1811-1841, November 1994.

@item [Meyer92a]
Bertrand Meyer.
Applying ``design by contract''.
@cite{Computer}, @b{25}(10):40--51, October 1992.

@item [Meyer92b]
Bertrand Meyer.
@cite{Eiffel: The Language}.
Object-Oriented Series. Prentice Hall, New York, N.Y., 1992.

@item [Meyer97]
Bertrand Meyer.
@cite{Object-oriented Software Construction}.
Prentice Hall, New York, N.Y., second edition, 1997.

@item [Morgan-Vickers94]
Carroll Morgan and Trevor Vickers.
@cite{On the refinement calculus}.
Springer-Verlag, New York, N.Y., 1994.

@item [Morgan94]
Carroll Morgan.
@cite{Programming from Specifications}, second edition
(Prentice-Hall, 1994).

@item [Morris87]
Joseph~M. Morris.
A theoretical basis for stepwise refinement and the programming
  calculus.
@cite{Science of Computer Programming}, @b{9}(3):287-306, December 1987.

@item [Mueller-Poetzsch-Heffter00]
Peter M@"uller and Arnd Poetzsch-Heffter.
Modular Specification and Verification Techniques for
Object-Oriented Software Components.
In Gary T. Leavens and Murali Sitaraman (eds.),
@cite{Foundations of Component-Based Systems},
pages 137-159. Cambridge University Press, 2000.

@item [Mueller-Poetzsch-Heffter00a]
Peter M@"uller and Arnd Poetzsch-Heffter.
A Type System for Controlling Representation Exposure in Java.
In S. Drossopoulou, et al. (eds.),
@cite{Formal Techniques for Java Programs}, 2000.
Technical Report 269, Fernuniversit@"at Hagen,
Available from @*
@file{http://www.informatik.fernuni-hagen.de/pi5/publications.html}

@item [Mueller-Poetzsch-Heffter01a]
Peter M@"uller and Arnd Poetzsch-Heffter.
Universes: A Type System for Alias and Dependency Control.
Technical Report 279, Fernuniversit@"at Hagen, 2001.
Available from @*
@file{http://www.informatik.fernuni-hagen.de/pi5/publications.html}

@item [Mueller-Poetzsch-Heffter-Leavens03]
Peter M@"uller, Arnd Poetzsch-Heffter, and Gary T. Leavens.
Modular Specification of Frame Properties in JML.
@cite{Concurrency and Computation: Practice and Experience},
@b{15}(2):117-154, February 2003.
Also Technical Report TR #02-02, Department of Computer Science, Iowa
State University, Ames, Iowa, 50011, February 2002.
Available from @*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR02-02/TR.pdf}

@item [Mueller-Poetzsch-Heffter-Leavens06]
Peter M@"uller, Arnd Poetzsch-Heffter, and Gary T. Leavens.
Modular Invariants for Layered Object Structures.
@cite{Science of Computer Programming}, @b{62}(3):253-286, October 2006.@*
@file{http://dx.doi.org/10.1016/j.scico.2006.03.001}
Also Technical Report 424, ETH Z@"urich, October 2003, revised March 2004,
March 2005. 
Available from @*
@file{ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/4xx/424.pdf}

@item [Mueller02]
Peter M@"uller.
Modular Specification and Verification of Object-Oriented Programs.
Volume 2262 of @cite{Lecture Notes in Computer Science},
Springer-Verlag, 2002.

@item [Nelson89]
Greg Nelson.
A Generalization of Dijkstra's Calculus.
@cite{ACM Transactions on Programming Languages and Systems},
@b{11}(4):517-561, October 1989.

@item [Noble-Vitek-Potter98]
James Noble, Jan Vitek, and John Potter.
Flexible Alias Protection.
In Eric Jul (ed.), @cite{ECOOP '98 -- Object-Oriented Programming, 12th
European Conference, Brussels, Belgium}, pages 
volume 1445 of @cite{Lecture Notes in Computer Science},
pages 158-185. Springer-Verlag, New York, N.Y., 1998.

@c @item [Owre-etal95]
@c Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke.
@c Formal verification for fault-tolerant architectures: Prolegomena to
@c   the design of PVS.
@c @cite{IEEE Transactions on Software Engineering}, 21(2):107--125,
@c   February 1995.

@item [Parnas72]
D. L. Parnas.
On the Criteria to be Used in Decomposing Systems into Modules.
@cite{Comm. ACM}, @b{15}(12):1053-1058, December 1972.

@item [Poetzsch-Heffter97]
Arnd Poetzsch-Heffter.
Specification and Verification of Object-Oriented Programs.
Habilitationsschrift, Technische Universitaet Muenchen, 1997.
Available from the URL@*
@file{http://wwweickel.informatik.tu-muenchen.de/persons/poetzsch/habil.ps.gz}.

@item [Jacobs-Poll01]
Bart Jacobs and Eric Poll.
A Logic for the Java Modeling Language JML.
In @cite{Fundamental Approaches to Software Engineering (FASE'2001),
Genova, Italy, 2001}.
Volume 2029 of @cite{Lecture Notes in Computer Science},
Springer-Verlag, 2001.
@file{http://www.cs.kun.nl/~erikpoll/publications/jmllogic.html}

@item [Raghavan-Leavens05]
Arun D. Raghavan and Gary T. Leavens.
Desugaring JML Method Specifications.
Technical Report #00-03a, Department of Computer Science, Iowa State
  University, Ames, Iowa, 50011, April, 2000, revised May 2005.
Available in@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR00-03/TR.ps.gz}.

@item [Rioux-Chalin07]
F. Rioux and P. Chalin.
Effective and Efficient Runtime Assertion Checking for JML Through Strong Validity.
@cite{Proceedings of the 9th Workshop on Formal Techniques for Java-like Programs (FTfJP'07)},
Berlin, Germany, 2007.

@item [Rodriguez-etal05]
Edwin Rodriguez, Matthew B. Dwyer, Cormac Flanagan, John Hatcliff,
Gary T. Leavens, Robby.
Extending JML for Modular Specification and
Verification of Multi-Threaded Programs.
In Andrew P. Black (ed.),
@cite{ECOOP 2005 -- Object-Oriented Programming 19th European Conference},
Glasgow, UK, pages 551-576. Volume 3586 of 
@cite{Lecture Notes in Computer Science}, Springer Verlag, July 2005.

@item [Rosenblum95]
David S. Rosenblum.
A practical approach to programming with assertions.
@cite{IEEE Transactions on Software Engineering}, 
@b{21}(1):19--31, January 1995. 

@item [Ruby-Leavens00]
Clyde Ruby and Gary T. Leavens.
Safely Creating Correct Subclasses without Seeing Superclass Code.
In @cite{OOPSLA 2000 Conference on Object-Oriented Programming,
  Systems, Languages, and Applications, Minneapolis, Minnesota}.
(@cite{ACM SIGPLAN Notices}, @b{35}(10):208-228, October, 2000.)
Also Technical Report #00-05d, Department of Computer Science, Iowa State
  University, Ames, Iowa, 50011. April 2000, revised April, June, July 2000.
Available in@*
  @file{ftp://ftp.cs.iastate.edu/pub/techreports/TR00-05/TR.ps.gz}.

@item [Ruby06]
Clyde Dwain Ruby.
Modular subclass verification: safely creating correct subclasses without superclass code.
Ph.D. Thesis, Department of Computer Science, Iowa State University.
Also Technical Report #06-34, December 2006.
Available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR06-34/TR.pdf}.

@item [Salcianu-Rinard05]
Alexandru Salcianu and Martin Rinard.
Purity and Side Effect Analysis for Java Programs.
In Proceedings of the 6th International Conference on Verification,
Model Checking and Abstract Interpretation. Paris, France January 2005.
Available in@*
  @file{http://www.mit.edu/~salcianu/publications/vmcai05-purity.pdf}

@c @item [Schmidt86]
@c David A. Schmidt.
@c @cite{Denotational Semantics:  A Methodology for Language Development}
@c (Allyn and Bacon, Inc., Boston, Mass., 1986).

@item [Shaner-Leavens-Naumann07]
Steve M. Shaner, Gary T. Leavens, and David A. Naumann.
Modular Verification of Higher-Order Methods with Mandatory Calls Specified by Model Programs
Department of Computer Science, Iowa State University,
TR #07-04a, March 2007, revised April 2007,
which is available from the URL@*
@file{ftp://ftp.cs.iastate.edu/pub/techreports/TR07-04/TR.pdf}.

@c (Allyn and Bacon, Inc., Boston, Mass., 1986).

@item [Spivey92]
J. Michael Spivey.
@cite{The Z Notation: A Reference Manual}, second edition,
(Prentice-Hall, Englewood Cliffs, N.J., 1992).

@item [Steyaert-etal96]
Patrick Steyaert, Carine Lucas, Kim Mens, and Theo D'Hondt.
Issues in the Design and Documentation of Class Libraries.
In @cite{OOPSLA '96 Proceedings}.
(@cite{ACM SIGPLAN Notices}, @b{31}(10):268-285, October, 1996.)

@item [Tan95]
Yang Meng Tan.
@cite{Formal Specification Techniques for Engineering Modular C Programs}.
International Series in Software Engineering
(Kluwer Academic Publishers, Boston, 1995).
Also published as 
Formal Specification Techniques for Promoting Software Modularity,
Enhancing Documentation, and Testing Specifications.
Technical Report TR-619, MIT Lab. for Comp. Sci., June 1994.

@item [Watt91]
David A. Watt.
@cite{Programming Language Syntax and Semantics}.
Prentice Hall, International Series in Computer Science,
New York, 1991.

@item [Wills92b]
Alan Wills.
Specification in Fresco.
In Susan Stepney and Rosalind Barden and David Cooper (eds.),
@cite{Object Orientation in Z}, chapter 11, pages 127-135.
Springer-Verlag, Workshops in Computing Series, Cambridge CB2 1LQ, UK,
1992.

@item [Wing83]
Jeannette Marie Wing.
@cite{A Two-Tiered Approach to Specifying Programs}
Technical Report TR-299, Mass. Institute of Technology,
Laboratory for Computer Science, 1983.

@item [Wing87]
Jeannette M. Wing.
Writing Larch Interface Language Specifications.
@cite{ACM Transactions on Programming Languages and Systems},
@b{9}(1):1-24, January 1987.

@item [Wing90a]
Jeannette M. Wing.
A Specifier's Introduction to Formal Methods.
@cite{Computer}, @b{23}(9):8-24, September 1990.
@end table

@c --------- chapter Example Index -----------
@node Example Index, Concept Index, Bibliography, Top
@c node-name, next, previous, up
@unnumbered Example Index

@printindex pg

@c --------- chapter Concept Index -----------
@node Concept Index,  , Example Index, Top
@c node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye
