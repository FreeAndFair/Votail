This is jmlrefman.info, produced by makeinfo version 4.8 from
jmlrefman.texinfo.

INFO-DIR-SECTION Programming & development tools
START-INFO-DIR-ENTRY
* JML Reference Manual: (jmlrefman).  Reference for the Java Modeling Language.
END-INFO-DIR-ENTRY

   Copyright (C) 2002-2007 by the authors

   Permission is granted for you to make copies of this manual for
educational and scholarly purposes, and for commercial use in
specifying software, but the copies may not be sold or otherwise used
for direct commercial advantage; this permission is granted provided
that this copyright and permission notice is preserved on all copies.
All other rights reserved.

   Version Information:  @(#) $Id: jmlrefman.texinfo,v 1.231 2008/05/13
20:54:59 leavens Exp $


File: jmlrefman.info,  Node: Universal and Existential Quantifiers,  Next: Generalized Quantifiers,  Prev: Quantified Expressions,  Up: Quantified Expressions

11.4.24.1 Universal and Existential Quantifiers
...............................................

The quantifiers `\forall' and `\exists', are universal and existential
quantifiers (respectively).  For example,

       (\forall int i,j; 0 <= i && i < j && j < 10; a[i] < a[j])

says that the values `a[0]' ... `a[9]' are sorted.

   The body of a universal or existential quantifier must be of type
`boolean'. The type of a universal or existential quantified expression
as a whole is `boolean'. When the range predicate is not satisfiable,
the value of a `\forall' expression is `true' and the value of an
`\exists' expression is `false'. For example: 
       (\forall int i; 0 < i && i < 0; 0 < i) == true
       (\exists int i; 0 < i && i < 0; 0 < i) == false


File: jmlrefman.info,  Node: Generalized Quantifiers,  Next: Numerical Quantifier,  Prev: Universal and Existential Quantifiers,  Up: Quantified Expressions

11.4.24.2 Generalized Quantifiers
.................................

The quantifiers `\max', `\min', `\product', and `\sum', are generalized
quantifiers that return the maximum, minimum, product, or sum of the
values of the expressions given, where the variables satisfy the given
range. The expression in the body must be of a built-in numeric type,
such as `int' or `double'; the type of the quantified expression as a
whole is the type of its body.  For example, the following equations
are all true (see chapter 3 of [Cohen90]):
       (\sum int i; 0 <= i && i < 5; i) == 0 + 1 + 2 + 3 + 4
       (\product int i; 0 < i && i < 5; i) == 1 * 2 * 3 * 4
       (\max int i; 0 <= i && i < 5; i) == 4
       (\min int i; 0 <= i && i < 5; i-1) == -1

   For computing the value of a sum or product, Java's arithmetic is
used.  [[[ This would depend on the arithmetic mode in force -
DRC]]]The meaning thus depends on the type of the expression.  For
example, in Java, floating point numbers use the IEEE 754 standard, and
thus when an overflow occurs, the appropriate positive or negative
infinity is returned.  However, Java integers wrap on overflow.
Consider the following examples.
       (\product float f; 1.0e30f < f && f < 1.0e38f; f)
         == Float.POSITIVE_INFINITY

       (\sum int i; i == Integer.MAX_VALUE || i == 1; i)
         == Integer.MAX_VALUE + 1
         == Integer.MIN_VALUE

   When the range predicate is not satisfiable, the sum is 0 and the
product is 1; for example:
       (\sum int i; false; i) == 0
       (\product double d; false; d*d) == 1.0

   When the range predicate is not satisfiable for `\max' the result is
the smallest number with the type of the expression in the body; for
floating point numbers, negative infinity is used.  Similarly, when the
range predicate is not satisfiable for `\min', the result is the
largest number with the type of the expression in the body.  [[[ Or
should this be undefined - DRC]]]


File: jmlrefman.info,  Node: Numerical Quantifier,  Next: Executability of Quantified Expressions,  Prev: Generalized Quantifiers,  Up: Quantified Expressions

11.4.24.3 Numerical Quantifier
..............................

The numerical quantifier, `\num_of', returns the number of values for
its variables for which the range and the expression in its body are
true.  The body must have type `boolean', and the entire quantified
expression has type `long'.  The meaning of this quantifier is defined
by the following equation (see p. 57 of [Cohen90]).

       (\num_of T x; R(x); P(x)) == (\sum T x; R(x) && P(x); 1L)


File: jmlrefman.info,  Node: Executability of Quantified Expressions,  Next: Modifiers for Bound Variables,  Prev: Numerical Quantifier,  Up: Quantified Expressions

11.4.24.4 Executability of Quantified Expressions
.................................................

When are universal or existential quantifiers executable for purposes
of runtime assertion checking?  If the type of the quantified variable
is `boolean', then it is always executable.  Otherwise a
SPEC-QUANTIFIED-EXPR is only executable if the form of the expression
matches a pattern that the runtime assertion checker understands.  This
varies by tool implementation, but you can expect that the runtime
assertion checker understands patterns where the range predicate gives
a finite range for an ordinal primitive value type (such as `int') or
where the range predicate requires the quantified variable to be drawn
from some set.  Examples include the following.  [[[Make these examples
be real examples in the samples directory]]]

          (\forall int x; 0 <= x && x < somelimit; ...)
          (\forall Object x; someSet.has(x); ...)

   You should get warnings from the `jmlc' tool when assertions are not
executable, but you have to use the `-w2' flag to see them.

   If a SPEC-QUANTIFIED-EXPR, QE, is executable, then a tool executing
it should only evaluate any range expression in QE once per execution
of QE.  Since the value of such a range expression cannot change, this
evaluation strategy will not change the value of QE, but it will save
time to only evaluate the range expression once for each evaluation of
QE.


File: jmlrefman.info,  Node: Modifiers for Bound Variables,  Next: Quantifying over Reference Types,  Prev: Executability of Quantified Expressions,  Up: Quantified Expressions

11.4.24.5 Modifiers for Bound Variables
.......................................

     BOUND-VAR-MODIFIERS ::= `non_null' | `nullable'

   Logical variables can be bound in

   * quantified expressions (*note Quantified Expressions::),

   * set comprehension expressions (*note Set Comprehensions::),

   * forall clauses of method contracts (*note Forall Variable
     Declarations::), or

   * old clauses of method contracts (*note Old Variable
     Declarations::).

   Note that in JML, `non_null' and `nullable' are not reserved words,
hence such identifiers can be used as type names. In order to quantify
over the elements of a type named `non_null' or `nullable' is necessary
to provide an explicit nullity modifier.  For example,
       (\forall non_null non_null nn; ...)
   where the first `non_null' is one of the BOUND-VAR-MODIFIERS and the
second is the type `non_null'.


File: jmlrefman.info,  Node: Quantifying over Reference Types,  Prev: Modifiers for Bound Variables,  Up: Quantified Expressions

11.4.24.6 Quantifying over Reference Types
..........................................

The range of values for a quantified variable that is declared to be of
a reference type:
   * Does not include `null' unless the bound variable is declared
     `nullable' (*note Non-null by Default::).  

   * May include references to objects that are not constructed by the
     program; one should use a range predicate to eliminate such cases
     if they are not desired.


File: jmlrefman.info,  Node: Set Comprehensions,  Next: JML Operators,  Prev: JML Primary Expressions,  Up: Predicates and Specification Expressions

11.5 Set Comprehensions
=======================

The syntax of a SET-COMPREHENSION expression is as follows.

     SET-COMPREHENSION ::= `{' [ BOUND-VAR-MODIFIERS ] TYPE-SPEC
                 QUANTIFIED-VAR-DECLARATOR ``|''
                 POSTFIX-EXPR `&&' PREDICATE `}'

   The set comprehension notation can be used to succinctly define sets.
For example, the following is the `JMLObjectSet' that is the subset of
non-`null' `Integer' objects found in the set `myIntSet' whose values
are between 0 and 10, inclusive.

       new JMLObjectSet {Integer i | myIntSet.has(i) &&
           i != null && 0 <= i.intValue() && i.intValue() <= 10 }

   The syntax of JML limits set comprehensions so that the POSTFIX-EXPR
following the vertical bar (`|') is always a method invocation with the
bound variable declared in the QUANTIFIED-VAR-DECLARATOR as its
parameter; the method may be either the `has' method of an
`org.jmlspecs.models.JMLObjectSet' or
`org.jmlspecs.models.JMLValueSet', or the `contains' method of a
`java.util.Collection'. This restriction is used to avoid Russell's
paradox [Whitehead-Russell25]. The bound variable, whose scope is the
SET-COMPREHENSION, may not conflict with existing local variables, but
may hide static and instance fields. The bound variable type is used to
restrict the objects that become part of the resulting set; if the set
called in the POSTFIX-EXPR contains objects that are not assignable to
the bound variable, they are not contained in the resulting set
comprehension. Thus, the following two set comprehension expressions
result in identical sets:

       new JMLObjectSet {Integer i | s.has(i) && 0 < i.intValue() }
       new JMLObjectSet {Object i | s.has(i) && i instanceof Integer &&
           0 < ((Integer) i).intValue() }

   In practice, one starts either from some relevant set at hand or
from the sets found in `JMLObjectSet' and `JMLValueSet' containing the
objects of primitive types. The type of a set comprehension is the type
named following `new', which must be `JMLObjectSet' or `JMLValueSet'.
The bound variable type must be compatible with the set comprehension
type; in particular, the bound variable type must be a subtype of
`org.jmlspecs.models.JMLType' if the set comprehension type is
`JMLValueSet'.


File: jmlrefman.info,  Node: JML Operators,  Next: Store Refs,  Prev: Set Comprehensions,  Up: Predicates and Specification Expressions

11.6 JML Operators
==================

In this section we describe the various new operators that JML adds to
Java expressions.  The following can all be used in SPEC-EXPRESSIONs.

* Menu:

* Subtype operator::
* Equivalence and Inequivalence Operators::
* Forward and Reverse Implication Operators::
* Lockset Ordering::


File: jmlrefman.info,  Node: Subtype operator,  Next: Equivalence and Inequivalence Operators,  Prev: JML Operators,  Up: JML Operators

11.6.1 Subtype operator
-----------------------

The relational operator `<:' compares two reference types and returns
true when the type on the left is a subtype of the type on the right
[Leino-Nelson-Saxe00].  Although the notation might suggest otherwise,
this operator is also reflexive; a type will compare as `<:' with
itself.  In an expression of the form E1 `<:' E2, both E1 and E2 must
have type `\TYPE'; since in JML `\TYPE' is the same as
`java.lang.Class' the expression E1 `<:' E2 means the same thing as the
expression E2`.isAssignableFrom('E1`)'.  As a result, primitive types
are not subtypes of `java.lang.Object', nor of each other, though they
are of themselves; so, for example, `Integer.TYPE <: Integer.TYPE' is
true.


File: jmlrefman.info,  Node: Equivalence and Inequivalence Operators,  Next: Forward and Reverse Implication Operators,  Prev: Subtype operator,  Up: JML Operators

11.6.2 Equivalence and Inequivalence Operators
----------------------------------------------

The operators `<==>' and `<=!=>' work only on boolean-subexpressions
and have the same meaning as `==' and `!=', respectively.  However,
they have very low precedence, and so are useful at the top-level of a
SPEC-EXPRESSION.  Unlike `==' and `!=', the operators `<==>' and
`<=!=>' are also associative and symmetric.

   The notation `<==>' can be read "if and only if".  It has the same
meaning for Boolean  values as `==', but has a lower precedence.
Therefore, the expression "`\result <==> size == 0'" means the same
thing as "`\result == (size == 0)'".

   The notation `<=!=>' can be read "is not equivalent to".  It has the
same meaning for Boolean  values as `!=', but has a lower precedence.
Therefore, the expression "`\result <=!=> size == 0'" means the same
thing as "`\result != (size == 0)'".

   The expressions on either side of these operators must be of type
`boolean', and the type of the result is also `boolean'.


File: jmlrefman.info,  Node: Forward and Reverse Implication Operators,  Next: Lockset Ordering,  Prev: Equivalence and Inequivalence Operators,  Up: JML Operators

11.6.3 Forward and Reverse Implication Operators
------------------------------------------------

The operators `==>' and `<==' work only on boolean-subexpressions.
They compute forward and reverse implications, respectively.

   For example, the formula `raining ==> getsWet' is true if either
`raining' is false or `getsWet' is true.  The formula `getsWet <==
raining' means the same thing.  The `==>' operator associates to the
right, but the `<==' operator associates to the left.  The expressions
on either side of these operators must be of type `boolean', and the
type of the result is also `boolean'.

   These two operators are evaluated in short-circuit fashion, left to
right.  Thus, in `a ==> b', if `a' is false, then the expression is true
and `b' is not evaluated.  Similarly, in `a <== b', if `a' is true, the
expression is true and `b' is not evaluated.  In other words, `a ==> b'
is equivalent to `!a || b' and `a <== b' is equivalent to ` a || !b'.

   Because of this short-circuit evaluation, `a ==> b' is not quite
equivalent to `b <== a'.  For example, `x != null ==> x.a > 0' will be
true if `x' is `null', but `x.a>0 <== x != null' would be undefined (or
throw a NullPointerException) if `x' is `null'.


File: jmlrefman.info,  Node: Lockset Ordering,  Prev: Forward and Reverse Implication Operators,  Up: JML Operators

11.6.4 Lockset Ordering
-----------------------

JML uses `<' and `<=' to test order of locks.  JML extends these two
operators, but not `>' and `>=', as comparisons on Objects.  Using
`synchronized' statements, Java programs can establish monitor locks to
permit only one thread at a time to execute given sections of code. Any
object can be used as a lock. In order for ESC/Java
[Leino-Nelson-Saxe00] to reason about the possibility of deadlocks
among threads, a partial order must be statically declared on lock
objects, with "larger" objects being objects whose locks should be
acquired later.  ESC/Java suggests the use of AXIOM-CLAUSEs to declare
this partial order.

   The `<' and `<=' operators test this partial order in assertions.
When used in this way, the subexpressions to either side of `<' or `<='
must be reference types, and the result is of type boolean.


File: jmlrefman.info,  Node: Store Refs,  Prev: JML Operators,  Up: Predicates and Specification Expressions

11.7 Store Refs
===============

The syntax related to the STORE-REF production is used in several
places.

     STORE-REF-LIST ::= STORE-REF-KEYWORD | STORE-REF [ `,' STORE-REF ] ...
     STORE-REF ::= STORE-REF-EXPRESSION
             | INFORMAL-DESCRIPTION
     STORE-REF-EXPRESSION ::= STORE-REF-NAME [ STORE-REF-NAME-SUFFIX ] ...
     STORE-REF-NAME ::= IDENT | `super' | `this'
     STORE-REF-NAME-SUFFIX ::= `.' IDENT | `.' `this' | ``['' SPEC-ARRAY-REF-EXPR ``]'' | `.' `*'
     SPEC-ARRAY-REF-EXPR ::= SPEC-EXPRESSION
             | SPEC-EXPRESSION `..' SPEC-EXPRESSION
             | `*'
     STORE-REF-KEYWORD ::= `\nothing' | `\everything' | `\not_specified'

   A STORE-REF denotes a set of locations in general.

   The form `\nothing' denotes the empty set of locations.  The form
`\everything' denotes the set of all locations in the program.  The
form `\not_specified' denotes a unspecified set of locations, whose
usage is determined by the tool.

   The form SR`.*' refers to all fields of the object denoted by SR.
Similarly, the form A`[*]' refers to all locations of elements in the
array A.  [[[ And their datagroups? - DRC]]]

   Otherwise if a STORE-REF refers to a field, it denotes that field's
data group (*note Data Groups::).  If a STORE-REF refers to an element
or a range of elements, it refers to all of the named locations in that
array.


File: jmlrefman.info,  Node: Statements and Annotation Statements,  Next: Redundancy,  Prev: Predicates and Specification Expressions,  Up: Top

12 Statements and Annotation Statements
***************************************

JML also defines a number of annotation statements that may be
interspersed with Java statements in the body of a method, constructor,
or initialization block.

   The following gives the syntax of statements.  These are the
standard Java statements, with the addition of annotations, the
HENCE-BY-STATEMENT, ASSERT-REDUNDANTLY-STATEMENT, ASSUME-STATEMENT,
SET-STATEMENT, UNREACHABLE-STATEMENT, DEBUG-STATEMENT, and the various
forms of MODEL-PROG-STATEMENT.  *Note Model Programs::, for the syntax
of MODEL-PROG-STATEMENT, which is only allowed in model programs.  [[[
Does this include local class declarations?]]]

     COMPOUND-STATEMENT ::= `{' STATEMENT [ STATEMENT ] ... `}'
     STATEMENT ::= COMPOUND-STATEMENT
             | LOCAL-DECLARATION `;'
             | IDENT `:' STATEMENT
             | EXPRESSION `;'
             | `if' `(' EXPRESSION `)'
               STATEMENT [ `else' STATEMENT ]
             | POSSIBLY-ANNOTATED-LOOP
             | `break' [ IDENT ] `;'
             | `continue' [ IDENT ] `;'
             | `return' [ EXPRESSION ] `;'
             | SWITCH-STATEMENT
             | TRY-BLOCK
             | `throw' EXPRESSION `;'
             | `synchronized' `(' EXPRESSION `)' STATEMENT
             | `;'
             | JML-ANNOTATION-STATEMENT
             | ASSERT-STATEMENT
             | JML-ANNOTATION-STATEMENT
             | MODEL-PROG-STATEMENT // only allowed in model programs
     SWITCH-STATEMENT ::= `switch' `(' EXPRESSION `)' `{'
                          [ SWITCH-BODY ] ... `}'
     SWITCH-BODY ::= SWITCH-LABEL-SEQ [ STATEMENT ] ...
     SWITCH-LABEL-SEQ ::= SWITCH-LABEL [ SWITCH-LABEL ] ...
     SWITCH-LABEL ::= `case' EXPRESSION `:' | `default' `:'
     TRY-BLOCK ::= `try' COMPOUND-STATEMENT
                   [ HANDLER ] ...
                   [ `finally' COMPOUND-STATEMENT ]
     HANDLER ::= `catch' `(' PARAM-DECLARATION `)' COMPOUND-STATEMENT

   The semantics of the Java statements are as in Java
[Arnold-Gosling-Holmes00] [Gosling-etal00].  More details on the
JML-specific features related to statements are described below.

* Menu:

* Local Declaration Statements::
* Loop Statements::
* Assert Statements::
* JML Annotation Statements::


File: jmlrefman.info,  Node: Local Declaration Statements,  Next: Loop Statements,  Prev: Statements and Annotation Statements,  Up: Statements and Annotation Statements

12.1 Local Declaration Statements
=================================

The following is the syntax of local declaration statements.  *Note
Field and Variable Declarations::, for the syntax of VARIABLE-DECLS.

     LOCAL-DECLARATION ::= LOCAL-MODIFIERS VARIABLE-DECLS

* Menu:

* Modifiers for Local Declarations::


File: jmlrefman.info,  Node: Modifiers for Local Declarations,  Prev: Local Declaration Statements,  Up: Local Declaration Statements

12.1.1 Modifiers for Local Declarations
---------------------------------------

JML allows the modifiers `ghost', `uninitialized', `non_null' and
`nullable' in addition to Java's `final' modifier on local variable
declarations.  *Note Universe Type System::, for the grammar of
OWNERSHIP-MODIFIER.

     LOCAL-MODIFIERS ::= [ LOCAL-MODIFIER ] ...
     LOCAL-MODIFIER ::= `ghost' | `final'  `uninitialized' | `non_null' | `nullable'
              | OWNERSHIP-MODIFIER  // when the Universe type system is on

   The JML modifiers are discussed to some extent below.  *Note JML
Modifiers for Fields::, for more about these modifiers.

   When used as a local variable modifier, `uninitialized' means that
the variable should be considered by the tools to be uninitialized, even
if it has an initialization.  This allows the tools to check for uses
before a "real" initialization.

   A "local ghost declaration" is a variable declaration with a `ghost'
modifier, entirely contained in an annotation.  It introduces a new
variable that may be used in subsequent annotations within the
remainder of the block in which the declaration appears.  A ghost
variable is not used in program execution as Java variables are, but is
used by runtime assertion checkers or a static checker to reason about
the execution of the routine body in which the ghost variable is used.
   * The variable name may not be already declared as a local variable
     or local ghost variable or as a formal parameter of the routine in
     which the declaration appears.

   * Each variable declared may have an initializer; the initializer is
     in the scope of the newly declared variable.

   * The modifiers `final', `uninitialized', `non_null' and `nullable'
     may be used on the ghost declaration.

   In the following, the body of the method `ghostLocalExample'
contains several examples of local ghost declarations.  
     package org.jmlspecs.samples.jmlrefman;

     public abstract class GhostLocals {
         void ghostLocalExample() {
             //@ ghost int i = 0;
             //@ ghost int zero = 0, j, k = i+3;
             //@ ghost float[] a = {1, 2, 3};
             //@ ghost Object o;
             //@ final ghost non_null Object nno = new Object();
         }
     }


File: jmlrefman.info,  Node: Loop Statements,  Next: Assert Statements,  Prev: Local Declaration Statements,  Up: Statements and Annotation Statements

12.2 Loop Statements
====================

The following is the syntax of loop statements.

     POSSIBLY-ANNOTATED-LOOP ::=
               [ LOOP-INVARIANT ] ...
               [ VARIANT-FUNCTION ] ...
               [ IDENT `:' ] LOOP-STMT
     LOOP-STMT ::= `while' `(' EXPRESSION `)' STATEMENT
             | `do' STATEMENT `while' `(' EXPRESSION `)' `;'
             | `for' `(' [ FOR-INIT ] `;' [ EXPRESSION ] `;' [ EXPRESSION-LIST ] `)'
                  STATEMENT
     FOR-INIT ::= LOCAL-DECLARATION | EXPRESSION-LIST

   In JML a loop statement can be annotated with one or more loop
invariants, and one or more variant functions.  The following class
contains an example in the middle of the method `sumArray'.  This
example has a `while' loop with two loop invariants, which follow the
keyword `maintaining', and a single variant function, which follows the
keyword `decreasing'.  The invariants and variant function are written
above the loop itself.  The first loop invariant describes the range
that the variable `i' can take, and the second relates `i' and the
value in `sum'.

     package org.jmlspecs.samples.jmlrefman;

     /** An example of some simple loops with loop invariants
      *  and variant functions specified.
      */
     public abstract class SumArrayLoop {

         /** Return the sum of the argument array. */
         /*@   old \bigint sum =
           @		(\sum int j; 0 <= j && j < a.length; (\bigint)a[j]);
           @   requires Long.MIN_VALUE <= sum && sum <= Long.MAX_VALUE;
           @   assignable \nothing;
           @   ensures \result == sum;
           @*/
         public static long sumArray(int [] a) {
             long sum = 0;
             int i = a.length;

             /*@ maintaining -1 <= i && i <= a.length;
               @ maintaining sum
               @            == (\sum int j;
               @                   i <= j && 0 <= j && j < a.length;
               @                   (\bigint)a[j]);
               @ decreasing i; @*/
             while (--i >= 0) {
                 sum += a[i];
             }

             //@ assert i < 0 && -1 <= i && i <= a.length;
             //@ hence_by (i < 0 && -1 <= i) ==> i == -1;
             //@ assert i == -1 && i <= a.length;
             //@ assert sum == (\sum int j; 0 <= j && j < a.length; (\bigint)a[j]);
             return sum;
         }

     }

   At the end of the loop, the negation of the loop's test expression
and the loop invariants hold.  This is shown by the assertions after
the loop.

   Loop invariants and variant functions are discussed in more detail
below.  (Thanks to K. Rustan M. Leino, Claude Marche, and Steve M.
Shaner for discussions on this topic, including details of the
semantics.)

* Menu:

* Loop Invariants::
* Loop Variant Functions::


File: jmlrefman.info,  Node: Loop Invariants,  Next: Loop Variant Functions,  Prev: Loop Statements,  Up: Loop Statements

12.2.1 Loop Invariants
----------------------

A loop can specify one or more loop invariants, using the following
syntax.

     LOOP-INVARIANT ::= MAINTAINING-KEYWORD PREDICATE `;'
     MAINTAINING-KEYWORD ::= `maintaining' | `maintaining_redundantly'
             | `loop_invariant' | `loop_invariant_redundantly'

   A LOOP-INVARIANT is used to help prove partial correctness of a loop
statement.

   The meaning of a loop, which does not contain a use of `break' that
exits the loop itself (as opposed to some inner loop), such as
       //@ maintaining J;
       while (B) { S }
   is as follows.
       while (true) {
         //@ assert J;
         if (!(B)) { break; }
         S
       }
   So that the loop invariant holds at the beginning of each iteration
of the loop.

   The rule for deducing what is true after the loop can be stated
simply if the loop does not contain any `break' statements that exit
the loop, and if the loop test, `B', is both a Java EXPRESSION and a JML
SPECIFICATION-EXPRESSION (*note Specification Expressions::).  (This
means that `B' is side-effect free.)  For such loops, the rule is that,
after a loop with condition `B' and invariant `J' the negation of the
condition, `(!B)', conjoined with the invariant, `J', holds.  This is
summarized in the following program schema.

        //@ maintaining J;
        while (B) {  // assuming B has no side effects
          S
        }
        // assert !(B) && J;

   If the loop contains a `break' statement that exits the loop itself,
then more detailed reasoning is necessary to establish what will be
true after the loop.  The intended condition that should be true after
the loop when it is exited via a `break' statement can be recorded in
the code using an `assert' statement.  For example, if the loop has the
form:
      //@ maintaining J;
      while (true) {
        S1
        if (C) {
           S2
           //@ assert Q;
           break;
        }
        S3
      }
   then after the loop the asserted condition, `Q', should hold,
assuming there are no other `break' statements that exit the loop.


File: jmlrefman.info,  Node: Loop Variant Functions,  Prev: Loop Invariants,  Up: Loop Statements

12.2.2 Loop Variant Functions
-----------------------------

A loop can also specify one or more variant functions, using the
following syntax.

     VARIANT-FUNCTION ::= DECREASING-KEYWORD SPEC-EXPRESSION `;'
     DECREASING-KEYWORD ::= `decreasing' | `decreasing_redundantly'
             | `decreases' | `decreases_redundantly'

   A VARIANT-FUNCTION is used to help prove termination of a loop
statement.  It specifies an expression of type `long' or `int' that must
be no less than 0 when the loop is executing, and must decrease by at
least one (1) each time around the loop.

   The meaning of a loop such as
      //@ decreasing E;
      while (B) { S }
   in which S does not use `continue', is as follows.
       while (true) {
         long vf = E;      // assuming vf is a fresh variable name
         if (!(B)) { break; }
         S
         //@ assert 0 <= vf;
         //@ assert E < vf;
       }

   If the loop contains a `continue' statement, then the loop variant
is checked just before each use of `continue'.  For example, if the
loop has the form:
      //@ decreasing E;
      while (B) { S1 if (C) { S2 continue; } S3 }
   then the meaning is as follows.
       while (true) {
         long vf = E;      // assuming vf is a fresh variable name
         if (!(B)) { break; }
         S1
         if (C) {
            S2
            //@ assert 0 <= vf;
            //@ assert E < vf;
            continue;
         }
         S3
         //@ assert 0 <= vf;
         //@ assert E < vf;
       }


File: jmlrefman.info,  Node: Assert Statements,  Next: JML Annotation Statements,  Prev: Loop Statements,  Up: Statements and Annotation Statements

12.3 Assert Statements
======================

The syntax of assert and redundant assert statements is as follows.

     ASSERT-STATEMENT ::= `assert' EXPRESSION [ `:' EXPRESSION ] `;'
             | `assert' PREDICATE [ `:' EXPRESSION ] `;'
     ASSERT-REDUNDANTLY-STATEMENT ::= `assert_redundantly' PREDICATE
                                      [ `:' EXPRESSION ] `;'

   Note that Java (as of J2SDK 1.4) also has its own `assert'
statement.  For this reason JML distinguishes between assert statements
that occur inside and outside annotations.

   Outside an annotation, an assert statement is a Java assert
statement, whose syntax follows the first ASSERT-STATEMENT production
above.  Thus in such an assert statement, the first EXPRESSION can have
side effects (potentially, although it shouldn't).  The second
expression is supposed to have type `String', and will be used in a
message should the assertion fail.

   Inside an annotation, an assert statement is a JML assert statement,
and the second syntax is used for ASSERT-STATEMENT.  Thus instead of an
EXPRESSION before the optional colon, there is a JML PREDICATE.  This
predicate cannot have side effects, but can use the various JML
extensions to the Java expression syntax (*note Specification
Expressions::, for details.)  As in a Java assert statement, the
optional expression that follows the colon must be a `String', which is
printed if the assertion fails.

   An assert statements tells JML to check that the specified PREDICATE
is true at the given point in the program.  The runtime assertion
checker checks such assertions during execution of the program, when
control reaches the assert statement.  Other tools, such as
verification tools, will try to prove that the assertion always holds
at that program point, for every possible execution.

   The ASSERT-REDUNDANTLY-STATEMENT must appear in an annotation.  It
has the same semantics as the JML form of an assert statement, but is
marked as redundant.  Thus it would be used to call attention to some
property, but need not be checked.


File: jmlrefman.info,  Node: JML Annotation Statements,  Prev: Assert Statements,  Up: Statements and Annotation Statements

12.4 JML Annotation Statements
==============================

The following gives the syntax of JML annotation statements.  These can
appear anywhere in normal Java code, but must be enclosed in
annotations.  *Note Assert Statements::, for the syntax of the
ASSERT-REDUNDANTLY-STATEMENT.  *Note Model Programs::, for the syntax
of additional statements that can only be used in model programs.

     JML-ANNOTATION-STATEMENT ::= ASSERT-REDUNDANTLY-STATEMENT
             | ASSUME-STATEMENT
             | HENCE-BY-STATEMENT
             | SET-STATEMENT
             | REFINING-STATEMENT
             | UNREACHABLE-STATEMENT
             | DEBUG-STATEMENT

* Menu:

* Assume Statements::
* Set Statements::
* Refining Statements::
* Unreachable Statements::
* Debug Statements::
* Hence By Statements::


File: jmlrefman.info,  Node: Assume Statements,  Next: Set Statements,  Prev: JML Annotation Statements,  Up: JML Annotation Statements

12.4.1 Assume Statements
------------------------

The syntax of an assume statement is as follows.  As in a Java assert
statement, the optional expression that follows the colon must be a
`String', which is printed if the assumption fails.

     ASSUME-STATEMENT ::= ASSUME-KEYWORD PREDICATE
                          [ `:' EXPRESSION ] `;'
     ASSUME-KEYWORD ::= `assume' | `assume_redundantly'

   In runtime assertion checking, assumptions are checked in the same
way that assert statements are checked (*note Assert Statements::).

   However, in static analysis tools, the assume statement is used to
tell the tool that the given predicate is assumed to be true, and thus
need not be checked.


File: jmlrefman.info,  Node: Set Statements,  Next: Refining Statements,  Prev: Assume Statements,  Up: JML Annotation Statements

12.4.2 Set Statements
---------------------

The syntax of a set statement is as follows.  *Note Expressions::, for
the syntax of ASSIGNMENT-EXPR.

     SET-STATEMENT ::= `set' ASSIGNMENT-EXPR `;'

   A set statement is the equivalent of an assignment statement but is
within an annotation.  It is used to assign a value to a ghost variable
or to a ghost field.  A set statement serves to assist the static
checker in reasoning about the execution of the routine body in which
it appears.
   * the target of the set statement must be a ghost variable or a
     ghost field

   * the right-hand-side of the set statement must be pure (not have
     side effects)

*Examples:*
             //@ set i = 0;
             //@ set collection.elementType = \type(int);

   [[[ Questions: must the rhs be pure?  Should we allow an arbitrary
statement, not just an assignment? such as set ++i; or set i += 5; ]]]


File: jmlrefman.info,  Node: Refining Statements,  Next: Unreachable Statements,  Prev: Set Statements,  Up: JML Annotation Statements

12.4.3 Refining Statements
--------------------------

The syntax of a refining statement is as follows.  *Note Specification
Statements::, for the syntax of SPEC-STATEMENT and
GENERIC-SPEC-STATEMENT-CASE.  *Note Statements and Annotation
Statements::, for the syntax of STATEMENT.

     REFINING-STATEMENT ::= `refining' SPEC-STATEMENT STATEMENT
             | `refining' GENERIC-SPEC-STATEMENT-CASE STATEMENT

   A refining statement allows one to annotate a specification with a
specification.  It has two parts, a "specification" and a "body".  The
specification part can be either a SPEC-STATEMENT (*note Specification
Statements::), which includes the grammar for a heavyweight
specification case, or a GENERIC-SPEC-STATEMENT-CASE (*note
Specification Statements::), which includes the grammar for a
lightweight specification case.  The body is simply a statement.  In
particular, the body can be a COMPOUND-STATEMENT or a
JML-ANNOTATION-STATEMENT, including a nested REFINING-STATEMENT.

   Annotating the body with a specification is a way of collecting all
the specification information about the statement in one place.  Giving
such an annotation is especially useful for framing, e.g., writing
ASSIGNABLE-CLAUSEs.  For example, by using a refining statement, one can
write an assignable clause for a loop statement or for the statement in
the body of a loop.

   Refining statements are also used in connection with model program
specification cases (*note Model Programs::).  Within the
implementation of a method with such a model program specification, a
refining statement indicates exactly what SPEC-STATEMENT is implemented
by its body, since its specification part would be exactly that
SPEC-STATEMENT.  This is helpful for "matching" the implementation
against the model program specification [Shaner-Leavens-Naumann07].

   Note that the scope of any declarations made in the specification
part of a refining statement are limited to the specification part, and
do not extend into the body.  Thus a refining statement is type correct
if each of its subparts is type correct, using the surrounding context
for separately type checking the specification and body.

   The meaning of a refining statement of the form `refining' S B is
that the body B must refine the specification given in S.  This means
that B has to obey all the specifications given in S.  For example, B
may not assume a stronger precondition than that given by S.  (Standard
defaults are used for omitted clauses in the specification part of a
refining statement; thus, if there is no requires clause in a
SPEC-STATEMENT, then the precondition defaults to true.)  Similarly, B
may not assign to locations that are not permitted to be assigned to by
S, and, assuming S's precondition held, then when B terminates normally
it must establish S's normal postcondition.  *Note Method
Specifications::, for more about what it means to satisfy such a
specification.

   When `\old()' or `\pre()' are used in the specification part of a
refining statement, they have the same meaning as in a specification
statement (*note Specification Statements::).

   In execution, a refining statement of the form `refining' S B just
executes its body B.  For this reason, typically the `refining' keyword
and the specification S would be in JML annotations, but the body B
would be normal Java code (outside of any annotation).

   *Note Model Programs::, for more examples.


File: jmlrefman.info,  Node: Unreachable Statements,  Next: Debug Statements,  Prev: Refining Statements,  Up: JML Annotation Statements

12.4.4 Unreachable Statements
-----------------------------

The syntax of the `unreachable' statement is as follows.

     UNREACHABLE-STATEMENT ::= `unreachable' `;'

   The `unreachable' statement is an annotation that asserts that the
control flow of a routine will never reach that point in the program.
It is equivalent to the annotation `assert false'.  If control flow
does reach an `unreachable' statement, a tool that checks (by reasoning
or at runtime) the behavior of the routine should issue an error of
some kind.  The following is an example:
             if (true) {
                     ...
             } else {
                     //@ unreachable;
             }


File: jmlrefman.info,  Node: Debug Statements,  Next: Hence By Statements,  Prev: Unreachable Statements,  Up: JML Annotation Statements

12.4.5 Debug Statements
-----------------------

The syntax of the `debug' statement is as follows.  *Note
Expressions::, for the syntax of EXPRESSION.

     DEBUG-STATEMENT ::= `debug' EXPRESSION `;'

   A `debug' statement is the equivalent of an expression statement but
is within an annotation. Thus, features visible only in the JML scope
can also appear in the `debug' statement. Examples of such features
include ghost variables, model methods, `spec_public' fields, and
JML-specific expression constructs, to name a few.

   The main use of the `debug' statement is to help debugging
specifications, e.g., by printing the value of a JML expression, as
shown below.

             //@ debug System.err.println(x);

   In the above example, the variable `x' may be a ghost variable.
Note that using `System.err' automatically flushes output, unlike
`System.out'.  This flushing of output is helpful for debugging.

   As shown in the above example, expressions with side-effects are
allowed in the `debug' statement. These include not only methods with
side-effects but also increment (`++') and decrement (`--') operators
and various forms of assignment expressions (e.g., `=', `+=', etc.).
Thus, the `debug' statement can also be used to assign a value to a
variable, or mutate the state of an object.

             //@ debug x = x + 1;
             //@ debug aList.add(y);

   However, a model variable cannot be assigned to, nor can its state be
mutated by using the `debug' statement, as its value is given by a
`represents' clause (*note Represents Clauses::).

   There is no restriction on the type of expression allowed in the
`debug' statement.

   Tools should allow debug statements to be turned on or off easily.
Thus programmers should not count on debug statements being executed.
For example, if one needs to assign to a ghost variable, the proper way
to do it is to use a SET-STATEMENT (*note Set Statements::), which
would execute even if debug statements are not being executed.


File: jmlrefman.info,  Node: Hence By Statements,  Prev: Debug Statements,  Up: JML Annotation Statements

12.4.6 Hence By Statements
--------------------------

The syntax of the `hence_by' statement is as follows.

     HENCE-BY-STATEMENT ::= HENCE-BY-KEYWORD PREDICATE `;'
     HENCE-BY-KEYWORD ::= `hence_by' | `hence_by_redundantly'

   The `hence_by' statement is used to record reasoning when writing a
proof by intermittent assertions.  It would normally be used between
two assert statements (*note Assert Statements::) or between two assume
statements (*note Assume Statements::).

   [[[Needs example.]]]


File: jmlrefman.info,  Node: Redundancy,  Next: Model Programs,  Prev: Statements and Annotation Statements,  Up: Top

13 Redundancy
*************

JML has several features that allow the specification of implications
[Tan95] and examples [Leavens97c] [Leavens-Baker99].  They are
redundant in the sense that they do not constrain an implementation
directly.  Instead, they are useful for pointing out consequences to
the specification's readers, for example to draw attention to some
consequences of the specification of a method, or to illustrate it by
an example.

   In addition to clauses of the form X`_redundantly', such as
`requires_redundantly', `ensures_redundantly', etc., there are two
sections of a method specification that are devoted to such redundant
specifications.  These sections of a method specification are described
by the following grammar.

     REDUNDANT-SPEC ::= IMPLICATIONS [ EXAMPLES ] | EXAMPLES

   The two subsections below explain these features.  The description of
clauses of the form X`_redundantly' is contained in the first section.

* Menu:

* Redundant Implications and Redundantly Clauses::
* Redundant Examples::


File: jmlrefman.info,  Node: Redundant Implications and Redundantly Clauses,  Next: Redundant Examples,  Prev: Redundancy,  Up: Redundancy

13.1 Redundant Implications and Redundantly Clauses
===================================================

A "redudant implication" is a way of stating a claim about a
specification.  By itself it does not constrain an implication, but can
be thought of a stating a theorem to be proven about a specification.
Such redundant implications are useful for drawing the reader's
attention to some point that might otherwise be overlooked, or that is
important for rhetorical purposes [Leavens-Baker99].

   Redundant implications can be specified in two ways in JML.  The
first is by using clauses of the form X`_redundantly'.  The second is
by use of the IMPLICATIONS section of a method specification, which
starts with the keyword `implies_that'.  (*Note Organization of Method
Specifications::, for the syntax of SPEC-CASE-SEQ.)

     IMPLICATIONS ::= `implies_that' SPEC-CASE-SEQ

   The IMPLICATIONS section of a method specification says that for
each visibility level V, and for each SPEC-CASE of visibility V in its
SPEC-CASE-SEQ, that SPEC-CASE is refined by the entire non-redundant
specification of the method that applies at visibility level V.  Thus
every correct implementation of the non-redundant specification must
satisfy each of the SPEC-CASEs in the IMPLICATIONS section.

   For example, suppose that the (desugared) meaning of the
non-redundant part of a method's specification has the form:

     V behavior        // non-redundant
        requires Pre;
        assignable x1, x2;
        ensures NormPost;
        signals_only Ex1;
        signals (Exception e) ExPost;

   and suppose that one of the SPEC-CASEs in its IMPLICATIONS section
has the following (desugared) meaning:

     V behavior        // redundant
        requires RedPre;
        assignable x1, x2;
        ensures RedNormPost;
        signals_only Ex1;
        signals (Exception e) RedExPost;

   Then it must be the case that (by definition of refinement for
method specifications [Leavens-Naumann06]) the following implications
hold:

   * `\old(RedPre) ==> Pre',

   * `(\old(RedPre) && NormPost) ==> RedNormPost', and

   * `(\old(RedPre) && ExPost) ==> RedExPost'.

   These implications are only sensible if the specifications have the
same visibility (`V'), the same `assignable' clauses, and the same
`signals_only' clauses.  If the `assignable' clauses differ, one can
adjust by adding elements to the non-redundant parts of the assignable
clause, to widen it, but preserve its meaning by adding restrictions
(e.g., using the `\only_assigned' predicate), to the postconditions.
Similar adjustments can be made to the non-redundant `signals_only'
clause, by adding exceptions (or supertypes of exceptions) to the
non-redundant `signals_only', preserving its meaning by adding
restrictions in the `signals' clause.

   Redundant clauses are a syntactic variant of Tan's procedure claims
[Tan95].  The meaning of a redundant clause, of the form
X`_redundantly' is also defined as making a claim about implications,
but in this case only one simple implication.  The claim is that the
predicate in the redundant clause follows from the meaning of the
non-redundant X clauses.

   As an example, consider the following requires clauses.

        requires Pre;
        requires_redundantly RedPre;

   These state the claim that `Pre ==> RedPre'.  That is, in all
pre-states, whenever `Pre' is true, then `RedPre' must be true.  The
same pattern holds for all other clauses and their redundant
counterparts, including ensures clauses, signals clauses (which must
first be standardized to have the same exception [Raghavan-Leavens05]),
invariants, etc.

   For example, recall that multiple clauses are conjoined, and thus

        ensures Q1;
        ensures Q2;
        ensures_redundantly RedQ1;
        ensures_redundantly RedQ2;

is equivalent to

        ensures Q1 && Q2;
        ensures_redundantly RedQ1 && RedQ2;

   In this example, the claim stated is that:
       (Q1 && Q2) ==> (RedQ1 && RedQ2).

   If one is using a theorem prover, then these implications can be
thought of as theorems to prove (in the context of the overall class or
interface specification).

   A runtime assertion checker is free to check the specifications in
the IMPLICATIONS section, since they must all hold, as they should be
refined by the non-redundant specification.  If a redundant
specification case in a method's IMPLICATIONS section is violated, this
could indicate that either: (a) the implications described above do not
hold, or that (b) there is a violation of the specification by the
caller (e.g., if the precondition does not hold) or by the
implementation of the method (e.g., if the normal postcondition does
not hold).

   [[[Needs concrete examples.]]]


File: jmlrefman.info,  Node: Redundant Examples,  Prev: Redundant Implications and Redundantly Clauses,  Up: Redundancy

13.2 Redundant Examples
=======================

Examples are, used to point out, to readers or testing tools,
particular cases of a method specification [Leavens97c]
[Leavens-Baker99] [Leavens-Baker-Ruby06].  The following gives the
syntax of the EXAMPLES section of a method specification.  This section
starts with the `for_example' keyword, and includes one or more
EXAMPLEs.  Each EXAMPLE is much like a SPEC-CASE (*note Organization of
Method Specifications::), but uses various `example' keywords instead
of `behavior' keywords, and does not permit MODEL-PROGRAM cases.

     EXAMPLES ::= `for_example' EXAMPLE [ `also' EXAMPLE ] ...
     EXAMPLE ::= [ [ PRIVACY ] `example' ]
                 [ SPEC-VAR-DECLS ]
                 [ SPEC-HEADER ]
                 SIMPLE-SPEC-BODY
             | [ PRIVACY ] `exceptional_example'
               [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ EXCEPTIONAL-EXAMPLE-BODY ]
             | [ PRIVACY ] `exceptional_example'
               [ SPEC-VAR-DECLS ]
               EXCEPTIONAL-EXAMPLE-BODY
             | [ PRIVACY ] `normal_example'
               [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ NORMAL-EXAMPLE-BODY ]
             | [ PRIVACY ] `normal_example'
               [ SPEC-VAR-DECLS ]
               NORMAL-EXAMPLE-BODY
     EXCEPTIONAL-EXAMPLE-BODY ::= EXCEPTIONAL-SPEC-CLAUSE
                                  [ EXCEPTIONAL-SPEC-CLAUSE ] ...
     NORMAL-EXAMPLE-BODY ::= NORMAL-SPEC-CLAUSE
                             [ NORMAL-SPEC-CLAUSE ] ...

   As in method SPEC-CASEs (*note Organization of Method
Specifications::) there are both heavyweight and lightweight examples.  A
"lightweight" example does not use one of the `example' keywords.  A
"heavyweight" example uses one of the example keywords.  As with
SPEC-CASEs, only heavyweight examples can have a specified visibility;
lightweight examples all have the same visibility as the method (or
constructor) being specified.

   The defaults for omitted clauses in lightweight EXAMPLEs are the
same as those for omitted clauses in lightweight SPEC-CASEs.
Similarly, heavyweight EXAMPLEs have the same defaults as heavyweight
SPEC-CASEs.  (*Note Semantics of flat behavior specification cases::,
for the defaults for a lightweight and heavyweight specification cases.)

   As described in the "Preliminary Design of JML"
[Leavens-Baker-Ruby06] (section 2.3.2.1) "the specification in each
example should be such that:
   * the example's precondition implies the precondition of the
     expanded meaning of the specified behaviors,

   * the example's assignable clause specifies a subset of the
     locations that are assignable according to the expanded meaning of
     the specified behaviors, and

   * assuming the example's assignable clause, the conjunction of:
        * the example's precondition (wrapped by `\old()'),

        * the precondition of the expanded meaning of the specified
          behaviors (also wrapped by `\old()'), and

        * the postcondition of the expanded meaning of the specified
          behaviors
     should be equivalent to the example's postcondition.
   Requiring equivalence to the example's postcondition means that it
can serve as a test oracle for the inputs described by the example's
precondition.  If there is only one specified `public normal_behavior'"
specification case "and if there are no preconditions and assignable
clauses, then the example's postcondition should the equivalent to the
conjunction of the example's precondition and the postcondition of the
`public normal_behavior' specification."

   [[[(Needs concrete examples :-)]]]


File: jmlrefman.info,  Node: Model Programs,  Next: Specification for Subtypes,  Prev: Redundancy,  Up: Top

14 Model Programs
*****************

This chapter discusses JML's model programs, which are adapted from the
refinement calculus [Back88] [Back-vonWright89a] [Buechi-Weck00]
[Morgan94] [Morris87].  Details of JML's design and semantics for model
program specifications are described in a recent paper
[Shaner-Leavens-Naumann07].

* Menu:

* Ideas Behind Model Programs::
* Extracting Model Program Specifications::
* Details of Model Programs::
* Nondeterministic Choice Statement::
* Nondeterministic If Statement::
* Specification Statements::


File: jmlrefman.info,  Node: Ideas Behind Model Programs,  Next: Extracting Model Program Specifications,  Prev: Model Programs,  Up: Model Programs

14.1 Ideas Behind Model Programs
================================

The basic idea of a model program is that it is a specification that is
written as an abstract algorithm.  Such an abstract algorithm specifies
a method in the sense that the method's execution should be a
refinement of the model program.

   JML adopts ideas from Bu"chi and Weck's "grey-box approach" to
specification [Buechi-Weck00] [Buechi00].  However, JML structurally
restricts the notion of refinement by not permitting all
implementations with behavior that refines the model program, but only
allowing implementations that syntactically match the model program [Shaner-Leavens-Naumann07].
The current JML notion of matching uses REFINING-STATEMENTs (*note
Refining Statements::), as explained below.  This turns out to be a
simple and easy to understand technique for specifying and verifying
both higher-order features and callbacks.

   Consider the following example (from a survey on behavioral
subtyping by Leavens and Dhara [Leavens-Dhara00]).  In this example,
both the methods are specified using model programs, which are
explained below.

     package org.jmlspecs.samples.dirobserver;

     //@ model import org.jmlspecs.models.JMLString;
     //@ model import org.jmlspecs.models.JMLObjectSetEnumerator;

     /** Directories that can be both read and written. */
     public interface Directory extends RODirectory {

       /** Add a mapping from the given string
        *  to the given file to this directory.
        */
       /*@ public model_program {
         @   normal_behavior
         @     requires !in_notifier && n != null && n != "" && f != null;
         @     assignable entries;
         @     ensures entries != null
         @        && entries.equals(\old(entries.extend(
         @                                        new JMLString(n), f)));
         @
         @   maintaining !in_notifier && n != null && n != "" && f != null
         @               && e != null;
         @   decreasing e.uniteratedElems.size();
         @   for (JMLObjectSetEnumerator e = listeners.elements();
         @        e.hasMoreElements(); ) {
         @     set in_notifier = true;
         @     ((DirObserver)e.nextElement()).addNotification(this, n);
         @     set in_notifier = false;
         @   }
         @ }
         @*/
       public void addEntry(String n, File f);

       /** Remove the entry with the given name from this directory. */
       /*@ public model_program {
         @   normal_behavior
         @     requires !in_notifier && n != null && n != "";
         @     assignable entries;
         @     ensures entries != null
         @        && entries.equals
         @               (\old(entries.removeDomainElement(
         @                                             new JMLString(n))));
         @
         @   maintaining !in_notifier && n != null && n != "" && e != null;
         @   decreasing e.uniteratedElems.size();
         @   for (JMLObjectSetEnumerator e = listeners.elements();
         @        e.hasMoreElements(); ) {
         @     set in_notifier = true;
         @     ((DirObserver)e.nextElement()).removeNotification(this, n);
         @     set in_notifier = false;
         @   }
         @ }
         @*/
       public void removeEntry(String n);
     }

   Both model programs in the above example are formed from a
specification statement, which begins with the keyword
`normal_behavior' in these examples, and a for-loop.  The key event in
the for loop bodies is a method call to a method (`addNotification' or
`removeNotification').  These calls must occur in a state equivalent to
the one reached in the model program for the implementation to be legal.

   The specification statements abstract away part of a correct
implementation.  The `normal_behavior' statements in these examples
both have a precondition, a frame axiom, and a postcondition.  These
mean that the statements that they abstract away from must be able to,
in any state satisfying the precondition, finish in a state satisfying
the postcondition, while only assigning to the locations (and their
dependees) named in the frame axiom.  For example, the first
specification statement says that whenever `in_notifier' is false, `n'
is not null and not empty, and `f' is not null, then this part of the
method can assign to `entries' something that isn't null and that is
equal to the old value of `entries' extended with a pair consisting of
the string `n' and the file `f'.

   The model field `entries', of type `JMLValueToObjectMap', is
declared in the supertype `RODirectory' [Leavens-Dhara00].

   Implementations of model programs must match each specification
statement in a model program with a corresponding refining statement.
In the matching refining statement, the specification part must be
textually equal to the specification statement.  The body of the
refining statement must thus implement the given specification for that
statement (*note Refining Statements::).


File: jmlrefman.info,  Node: Extracting Model Program Specifications,  Next: Details of Model Programs,  Prev: Ideas Behind Model Programs,  Up: Model Programs

14.2 Extracting Model Program Specifications
============================================

Since refining statements contain both specifications and
implementations, it is possible to extract a model program
specification from an implementation with (zero or more) refining
statements. This is done by using the modifier `extract' on the method
[Shaner-Leavens-Naumann07].  [[[Give example.]]]


File: jmlrefman.info,  Node: Details of Model Programs,  Next: Nondeterministic Choice Statement,  Prev: Extracting Model Program Specifications,  Up: Model Programs

14.3 Details of Model Programs
==============================

The following gives the syntax of model programs.  *Note Statements and
Annotation Statements::, for the parts of the syntax of statements that
are unchanged from Java.  The JML-COMPOUND-STATEMENT and JML-STATEMENT
syntax is the same as the COMPOUND-STATEMENT and STATEMENT syntax,
except that MODEL-PROG-STATEMENTs are not flagged as errors within the
JML-COMPOUND-STATEMENT and JML-STATEMENTs.

     MODEL-PROGRAM ::= [ PRIVACY ] [ `code' ] `model_program'
                       JML-COMPOUND-STATEMENT
     JML-COMPOUND-STATEMENT ::= COMPOUND-STATEMENT
     JML-STATEMENT ::= STATEMENT
     MODEL-PROG-STATEMENT ::= NONDETERMINISTIC-CHOICE
             | NONDETERMINISTIC-IF
             | SPEC-STATEMENT
             | INVARIANT


File: jmlrefman.info,  Node: Nondeterministic Choice Statement,  Next: Nondeterministic If Statement,  Prev: Details of Model Programs,  Up: Model Programs

14.4 Nondeterministic Choice Statement
======================================

The syntax of the NONDETERMINISTIC-CHOICE statement is as follows.

     NONDETERMINISTIC-CHOICE ::= `choose' ALTERNATIVE-STATEMENTS
     ALTERNATIVE-STATEMENTS ::= JML-COMPOUND-STATEMENT
                  [ `or' JML-COMPOUND-STATEMENT ] ...

   The meaning is that a correct implementation can dynamically execute
(e.g., with an `if' or `switch' statement), one of the alternatives.
Code may also make a static choice of one of the alternatives.


File: jmlrefman.info,  Node: Nondeterministic If Statement,  Next: Specification Statements,  Prev: Nondeterministic Choice Statement,  Up: Model Programs

14.5 Nondeterministic If Statement
==================================

     NONDETERMINISTIC-IF ::= `choose_if' GUARDED-STATEMENTS
                  [ `else' JML-COMPOUND-STATEMENT ]
     GUARDED-STATEMENTS ::= GUARDED-STATEMENT
                  [ `or' GUARDED-STATEMENT ] ...
     GUARDED-STATEMENT ::= `{'
                  ASSUME-STATEMENT
                  JML-STATEMENT [ JML-STATEMENT] ... `}'

   The meaning of a nondeterministic if statement is that a correct
implementation may dynamically choose any of the guarded-statements for
which the guard (the first ASSUME-STATEMENT in the GUARDED-STATEMENT)
is true.  If none of these are true, then it must execute the
JML-COMPOUND-STATEMENT given following `else', but it may not do that
if one of the guards in the guarded statements is true.


File: jmlrefman.info,  Node: Specification Statements,  Prev: Nondeterministic If Statement,  Up: Model Programs

14.6 Specification Statements
=============================

The grammar for specification statements appears below.  It is unusual,
compared to specification statements in refinement calculus, in that it
allows one to specify statements that can signal exceptions, or
terminate abruptly.  The reasons for this are based on verification
logics for Java [Huisman01] [Jacobs-Poll01] [Ruby06], which have these
possibilities.  The meaning of an ABRUPT-SPEC-CASE is that the normal
termination and signaling an exception are forbidden; that is, the
equivalent SPEC-STATEMENT using `behavior' would have `ensures false;'
and `signals (Exception) false;' clauses.  Hence in an
ABRUPT-SPEC-CASE, JML does not allow use of an ENSURES-CLAUSE,
SIGNALS-ONLY-CLAUSE, or SIGNALS-CLAUSE.

     SPEC-STATEMENT ::= [ PRIVACY ] BEHAVIOR-KEYWORD
                        GENERIC-SPEC-STATEMENT-CASE
             | [ PRIVACY ] EXCEPTIONAL-BEHAVIOR-KEYWORD
               EXCEPTIONAL-SPEC-CASE
             | [ PRIVACY ] NORMAL-BEHAVIOR-KEYWORD
               NORMAL-SPEC-CASE
             | [ PRIVACY ] ABRUPT-BEHAVIOR-KEYWORD
               ABRUPT-SPEC-CASE
     GENERIC-SPEC-STATEMENT-CASE ::= [ SPEC-VAR-DECLS ]
                                     GENERIC-SPEC-STATEMENT-BODY
             | [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ GENERIC-SPEC-STATEMENT-BODY ]
     GENERIC-SPEC-STATEMENT-BODY ::= SIMPLE-SPEC-STATEMENT-BODY
             | `{|' GENERIC-SPEC-STATEMENT-CASE-SEQ `|}'
     GENERIC-SPEC-STATEMENT-BODY-SEQ ::= GENERIC-SPEC-STATEMENT-CASE
                  [ `also' GENERIC-SPEC-STATEMENT-CASE ] ...
     SIMPLE-SPEC-STATEMENT-BODY ::= SIMPLE-SPEC-STATEMENT-CLAUSE
                                    [ SIMPLE-SPEC-STATEMENT-CLAUSE ] ...
     SIMPLE-SPEC-STATEMENT-CLAUSE ::= DIVERGES-CLAUSE
             | ASSIGNABLE-CLAUSE
             | WHEN-CLAUSE | WORKING-SPACE-CLAUSE | DURATION-CLAUSE
             | ENSURES-CLAUSE | SIGNALS-ONLY-CLAUSE | SIGNALS-CLAUSE
             | CONTINUES-CLAUSE | BREAKS-CLAUSE | RETURNS-CLAUSE
     ABRUPT-BEHAVIOR-KEYWORD ::= `abrupt_behavior' | `abrupt_behaviour'
     ABRUPT-SPEC-CASE ::= GENERIC-SPEC-STATEMENT-CASE

   The meaning of a SPEC-STATEMENT is that the code in a correct
implementation must refine the given specification.  One way to ensure
this is to use a REFINING-STATEMENT in the implementation that contains
the SPEC-STATEMENT in its specification part (*note Refining
Statements::).

   The following subsections describe details of each of the new clauses
that may appear in an ABRUPT-SPEC-CASE or a GENERIC-SPEC-STATEMENT-CASE.

* Menu:

* Continues Clause::
* Breaks Clause::
* Returns Clause::


File: jmlrefman.info,  Node: Continues Clause,  Next: Breaks Clause,  Prev: Specification Statements,  Up: Specification Statements

14.6.1 Continues Clause
-----------------------

     CONTINUES-CLAUSE ::= CONTINUES-KEYWORD [ TARGET-LABEL ]
                          [ PRED-OR-NOT ] `;'
     CONTINUES-KEYWORD ::= `continues' | `continues_redundantly'
     TARGET-LABEL ::= `->' `(' IDENT `)'

   The meaning of the CONTINUES-CLAUSE is that if the statement that
implements the specification statement executes a `continue', then it
must continue to the given TARGET-LABEL (if any), and the given
predicate (if any) must hold in the state just before the `continue' is
executed.


File: jmlrefman.info,  Node: Breaks Clause,  Next: Returns Clause,  Prev: Continues Clause,  Up: Specification Statements

14.6.2 Breaks Clause
--------------------

     BREAKS-CLAUSE ::= BREAKS-KEYWORD [ TARGET-LABEL ]
                       [ PRED-OR-NOT ] `;'
     BREAKS-KEYWORD ::= `breaks' | `breaks_redundantly'

   The meaning of the BREAKS-CLAUSE is that if the statement that
implements the specification statement executes a `break', then it must
break to the given TARGET-LABEL (if any), and the given predicate (if
any) must hold in the state just before the `break' is executed.


File: jmlrefman.info,  Node: Returns Clause,  Prev: Breaks Clause,  Up: Specification Statements

14.6.3 Returns Clause
---------------------

     RETURNS-CLAUSE ::= RETURNS-KEYWORD [ PRED-OR-NOT ] `;'
     RETURNS-KEYWORD ::= `returns' | `returns_redundantly'

   The meaning of the RETURNS-CLAUSE is that if the statement that
implements the specification statement executes a `return', then the
given predicate (if any) must hold in the state following evaluation of
the return value, but just before the `return' is executed.  The
predicate (if any) in a returns clause may use `\result' to name the
computed return value.


File: jmlrefman.info,  Node: Specification for Subtypes,  Next: Refinement,  Prev: Model Programs,  Up: Top

15 Specification for Subtypes
*****************************

This chapter describes how JML specifies a type so that one can program
subtypes from the specification, without the need to see the code of
the supertypes that have been specified.

   The problem of specifying enough about superclasses has been
discussed by Kiczales and Lamping [Kiczales-Lamping92] and by Steyaert,
et al. [Steyaert-etal96].  This problem is difficult because of the
many ways that subclasses can depend on coding details of a superclass.
For example, a subclass can depend on the calling pattern among a
superclass's method and the fields that a superclass can access
[Kiczales-Lamping92] [Steyaert-etal96].

   JML builds on the work of Ruby and Leavens to solve this problem
[Ruby-Leavens00] [Ruby06], which builds on the earlier works described
above.  The idea is to write specifications for subclasses in three
parts.  The first is the usual, public specification, which is
primarily for clients but also useful to subclasses, who need to know
what public interface they must meet.  The second is a protected
specification, which specifies fields and methods that are usable by
the subclass.  The third is the code contract.  The code contract has a
different syntax in JML than it did in [Ruby-Leavens00].  In the
current JML a "code contract" is a heavyweight behavior specification
case (*note Heavyweight Specification Cases::) or as a model program
(*note Model Programs::) that uses the keyword "`code'."  The `code'
keyword is used just before one of the behavior keywords or just before
the keyword `model_program'.

   While code contracts can be generated automatically by a tool, as
imagined by Ruby and Leavens [Ruby-Leavens00] [Ruby06], they can also be
written by users directly.  This is sometimes useful for documenting
the implementation of a method. The code contract is intended to be
created automatically, by a tool (which does not, as of this writing,
exist).  It has the following syntax.

   In code contracts as described in the work of Ruby and Leavens, the
main clauses used are the ACCESSIBLE-CLAUSE and the CALLABLE-CLAUSE.
*Note Accessible Clauses::, for the syntax and semantics of the
ACCESSIBLE-CLAUSE.  *Note Callable Clauses::, for the syntax and
semantics of the CALLABLE-CLAUSE.

* Menu:

* Method of Specifying for Subclasses::
* Code Contracts::


File: jmlrefman.info,  Node: Method of Specifying for Subclasses,  Next: Code Contracts,  Prev: Specification for Subtypes,  Up: Specification for Subtypes

15.1 Method of Specifying for Subclasses
========================================

[[[This should be a synopsis of Clyde Ruby's dissertation, with an
example.]]]


File: jmlrefman.info,  Node: Code Contracts,  Prev: Method of Specifying for Subclasses,  Up: Specification for Subtypes

15.2 Code Contracts
===================

This section discusses the semantics of "code contracts," which are
specification cases that use the "`code'" keyword.  (*Note Behavior
Specification Cases::, for the detailed syntax of such specification
cases.)

   This feature was inspired by "does" clause of the Alloy Annotation
Language [Khurshid-Marinov-Jackson02].

   The modifier `code' may not be used on an abstract method.  It
follows that the `code' modifier cannot be used to document normal Java
methods in interfaces.  (In an interface, `code' could only be used in
the specification of a model method that has a body.)

   Tools for JML should warn the user if `code' is used in a
specification case for a constructor, or for a final, static, or
private method.  It does no harm there, but is not needed.

   The meaning of the `code' modifier is just that specification cases
or model programs containing them are not inherited.  That is, whenever
the method is overridden, it does not inherit code contracts from its
supertypes.

   In verification of a method call, you can use all non-code
specification cases, that are visible at a call site, for the
statically-determined method being called.  Such specifications are
inherited by each subtype's method overrides to preserve behavioral
subtyping [Dhara-Leavens96] [Leavens-Naumann06] [Leavens06b].

   In verification of a method call, you can use a code specification
case for a method m given in a class C only if you can prove that the
method being called is method m in class C.  This applies in particular
to super calls, which is the main use for such code contracts.  (It
would also apply to calls to final methods, calls to methods in final
classes, and calls to private or static methods.)


File: jmlrefman.info,  Node: Refinement,  Next: MultiJava Extensions to JML,  Prev: Specification for Subtypes,  Up: Top

16 Refinement
*************

This chapter explains JML's notion of refinement files, which uses the
following syntax.

     REFINE-PREFIX ::= REFINE-KEYWORD STRING-LITERAL `;'
     REFINE-KEYWORD ::= `refine' | `refines'

   The REFINE-PREFIX in a compilation unit says that the declarations
in this compilation unit refine the corresponding declarations in the
file named by the STRING-LITERAL.  The STRING-LITERAL should name a
file, complete with a suffix, for example, `"MyType.java-refined"'.
The suffix of such a file is used by JML tools to find the file that is
the base of a refinement chain, and all other files in the chain are
found using the files named in the REFINE-PREFIX of a previous file in
the chain.

   One can use either keyword, `refine' or `refines' in a
REFINE-PREFIX, although for historical reasons most examples use
`refine'.

   The following gives more details about the checks and meaning of this
feature of JML.

* Menu:

* File Name Suffixes::
* Using Separate Files::
* Refinement Chains::
* Type Checking Refinements::
* Refinement Viewpoints::


File: jmlrefman.info,  Node: File Name Suffixes,  Next: Using Separate Files,  Prev: Refinement,  Up: Refinement

16.1 File Name Suffixes
=======================

The JML tools recognize several filename suffixes.  The following are
considered to be "active" suffixes: `.refines-java', `.refines-spec',
`.refines-jml', `.java', `.spec', and `.jml'; There are also three
"passive" suffixes: `.java-refined', `.spec-refined', and
`.jml-refined'.  Files with passive suffixes can be used in refinements
but should not normally be passed explicitly to the tools directly.
These filename suffixes are ordered from most active to least active,
in the order given above.  Graphical user interface tools for JML
should, by default, only present the active suffixes for selection.
Among files in a directory with the same prefix, but with different
active suffixes, the one whose suffix appears first in the list of
active suffixes above should be considered primary by such a tool.

   *Note Using Separate Files::, for guidelines on how to use these
suffixes.  *Note Refinement Chains::, for details on the semantics of
specifications written using separate files.


File: jmlrefman.info,  Node: Using Separate Files,  Next: Refinement Chains,  Prev: File Name Suffixes,  Up: Refinement

16.2 Using Separate Files
=========================

Typically, JML specifications are written into annotation comments in
`.java' files, and this is certainly the simplest way to use JML and
its tools.

   However, there are some circumstances in which one may wish to
separate the specification from the Java code.  An important example of
this is when you do not own the sources for the Java code, but wish to
specify it.  This might happen if you are specifying a class library or
framework that you are using. When you do not have control of the code,
it is best to put the specification in a different file.

   To add specifications to such a library or framework, one would use
a filename with an active suffix, such as `.refines-java' (or
`.refines-spec' or `.refines-jml'). The file with such a name would hold
the specifications of the corresponding Java compilation unit.  For
example, if one wants to specify the type `LibraryType', without
touching the file `LibraryType.java' then one could write
specifications in the file `LibraryType.refines-java', and include in
that file the following REFINE-PREFIX.

       refine "LibraryType.java";

   If you are specifying code for which no sources are available (a
class library in binary form), then you should use the `.spec' or
`.jml' suffixes to write the specification.  Such specifications act
much like those written in `.refines-spec' or `.refines-jml' files, but
would not include a REFINE-PREFIX.  They allow specifications to be
written without having to write Java code for the bodies of methods (as
do all non-`.java') files.

   Another reason for writing specifications in different files is to
prevent the specifications from "cluttering up" the code (making it
hard to see all of the code at once). This is also possible by using
separate files for the specification and the code.  In such a case one
has a choice of suffixes, depending on whether one considers the code
to be primary or the specification.  If the code is primary, or has
been written already, then one can treat the code as if it were written
in an extra library, using the `.refines-java' (or `.refines-spec' or
`.refines-jml') suffixes to specify the Java files as above.

   On the other hand, if the specification is primary, or is to be
written first, one could instead use the `.java-refined' (or
`.spec-refined' or `.jml-refined') suffixes, and then write a
REFINE-PREFIX in the `.java' file.  For example, one might specify the
class `MyType' in a file named `MyType.java-refined'.  Then one could
write the implementation of `MyType' in a file called `MyType.java'.
The file `MyType.java' would include the following REFINE-PREFIX:

       refine "MyType.java-refined";

In this case, the specification found in `MyType.java-refined' "is a
refinement" of the implementation found in `MyType.java'.

   Combinations of these techniques can also be used, by using several
files instead of just a code file and a specification file.  *Note
Refinement Chains::, for the meaning of JML specifications in this
general case.

   To summarize, aside from the standard `.java' suffix, one would use
file name suffixes as follows.
   * If you are specifying before coding, but want to keep the
     specifications in a different file, but you want to have the
     `.java' file refer directly to the specification, then use one of
     the suffixes: `.java-refined', `.spec-refined', or
     `.jml-refined').  The `.java' file would name the file it refines
     (as would other files in the chain) in a REFINE-PREFIX.

   * If you have a `.java' file, but the REFINE-PREFIX cannot or should
     not appear in that `.java' file, then use one of the suffixes:
     `.refines-java', `.refines-spec', or `.refines-jml'.

   * If there is no `.java' source file that will be available to the
     tools, the specify the type using a `.spec' or `.jml' file,
     without using a REFINE-PREFIX.


File: jmlrefman.info,  Node: Refinement Chains,  Next: Type Checking Refinements,  Prev: Using Separate Files,  Up: Refinement

16.3 Refinement Chains
======================

Compilation Units that jointly give the specifications of a type form a
refinement chain.  It begins at a base (or most-refined) compilation
unit, proceeding by means of the `refine' annotation links, until a file
is found that has no `refine' statement.  That file is the end of the
refinement chain and is the least-refined compilation unit.

   For a given type in a given package, the base of the refinement
chain is found as follows.  Each entry of the classpath is searched in
order for a directory whose name matches the package of the type and
that contains a file whose name has a prefix matching the type name and
a suffix that is an active suffix as defined above.  The first such
file found is the base of the refinement chain.  If the first classpath
entry to contain a candidate file contains more than one candidate
file, then the file with the most active suffix is the base of the
chain.

   The subsequent elements of the refinement chain are given by the
filenames provided in the `refine' statements.  Each element of the
chain is in the same package.  Thus the file corresponding to the
`refine' statement is the first file found by searching the classpath
entries in order and that is in the directory corresponding to the
package of the type and has the filename and suffix given in the
`refine' statement.

   To help ensure that the base is correctly selected, the file with the
most active suffix must be the base of a refinement sequence, otherwise
the JML typechecker issues an error message.  Also, the prefix of the
base file must be the same as the public type declared in that
compilation unit or an error message is issued.  However, it is not
necessary that the file being refined have the same prefix as the file
at the base of the refinement chain (except that the .java file, if it
is in the refinement sequence, must have a name given by the Java rules
for naming compilation units).  Furthermore, a file with the same
prefix as the base file may not be in a different refinement sequence.
For example, `SomeName.java-refined' can be refined by `MyType.java' as
long as there is no refinement sequence with `SomeName' as the prefix
of the base of another refinement.

   The JML tools deal with all files in a refinement chain whenever one
of them is selected for processing by the tool.  This allows all of the
specifications that apply to be consistently dealt with at all times.
For example, suppose that there are files named `Foo.refines-java' and
`Foo.java', then if a tool selects the `Foo.java', e.g., with the
command:

        jmlc *.java

then it will see both the `Foo.refines-java' and the `Foo.java' file
(as long as `Foo.refines-java' appears in a specification path
directory before or with `Foo.java').

   A given .java file (that is, compilation unit) may have more than
one top-level class declaration within it.  Only one may be public, and
Java requires that the name of that type match the name of the file, so
that the definition of the type can be found in the file system.  The
non-public types within that compilation unit may be referred to only
within that compilation unit.  Consequently, all specifications of
those non-public types must occur along with the specifications of the
public type in that compilation unit.  For example, suppose a file
`A.java' contains the Java declaration of types `A' and `B'.  Then if
the specifications of type `A' are in `A.refines-java', the
specifications of type `B' must also be in `A.refines-java'.  For
simple one-file programs, the one compilation unit may contain only
non-public types.  Then the specifications for those types are found in
specification files with the same prefix as the filename of the Java
file containing the type declarations.


File: jmlrefman.info,  Node: Type Checking Refinements,  Next: Refinement Viewpoints,  Prev: Refinement Chains,  Up: Refinement

16.4 Type Checking Refinements
==============================

There are some restrictions on what can appear in the different files
involved in a particular refinement.  Since the Java compilers only see
the `.java' files, executable code (that is not just for use in
specifications) should only be placed in the `.java' files.  In
particular the following restrictions are enforced by JML.
   * When the same method is declared in more than one file in a
     refinement sequence, most parts of the method declaration must be
     identical in all the files.  (Two method declarations are
     considered to be declaring the "same method" if they have the same
     signature, i.e., same name, same generic type parameters, and
     static formal parameter types.)  However, in addition to the
     signature of such a method, the return type, the names of the
     formal parameters, the declared exceptions the method may throw,
     and the non-JML modifiers `public', `protected', `private',
     `static', and `final', must all match exactly in each such
     declaration in a refinement chain.

   * The `model' modifier must appear in all declarations of a given
     method or it must appear in none of them.  It is not permitted to
     implement a model method with a non-model method or to refine a
     non-model method with a model method.  Use a `spec_public' or
     `spec_protected' method if you want to use a non-model method in a
     specification.  Also, there may be no nesting of model
     declarations: model classes and model methods may not contain
     model or ghost declarations.

   * Some of the JML method modifiers do not always have to match in all
     declarations of the same method in a refinement chain.  One may add
     `pure', `non_null', `nullable', `spec_public', or `spec_protected'
     to any of the declarations for a method in any file.  However, if
     `pure' is added to a method specification, then all subsequent
     declarations of that method in a refinement sequence must also be
     declared `pure'.  Also, it is, of course, not permitted to add
     `spec_protected' to a method that has been declared `public' or
     `spec_public' in other declarations.  One can add `non_null' or
     `nullable' to any formal parameter in any file, although good
     style suggests that all of these annotations appear on one
     declaration of that method.

   * The specification of a refining method declaration must start with
     the JML keyword `also'; if it does not an error message is issued.
     A "refining method declaration" is a declaration that overrides a
     superclass method or refines the specification of the same method
     in a refinement chain.  In JML, method specifications are
     inherited by subclasses and in refinement chains.  The `also'
     keyword indicates that the current specification is refining the
     specification inherited either from the superclass or from the
     previous declaration of the method in a refinement sequence.
     Therefore, it is an error if the specification of a non-refining
     method begins with `also' (unless it overrides an inherited
     method).

   * If a non-model method has a body, then the body can only appear in
     a `.java' file; an error message is issued if the body of a
     non-model method appears in a file with any other suffix.
     Furthermore, the body of a model method may only appear in one
     file of a refinement sequence.  This means that each method of
     each class can have at most one method body.

   * When the same field is declared in more than one file in a
     refinement sequence, then the signature of each such declaration
     must be identical in all the files.  (Two field declarations are
     considered to be declaring the "same field" if they have the same
     name.)  The signature of such a field, including its type, the
     non-JML modifiers `public', `protected', `private', `static', and
     `final', must all match exactly in each such declaration.

   * All declarations of a given field must either use the modifier
     `model' or not.  It is not permitted to implement a model field
     with a non-model field or vice versa.  Use a `spec_public' or
     `spec_protected' field if you want to use the same name.  The same
     comment holds for `ghost' fields as well.

   * Some of the JML field modifiers do not always have to match in all
     declarations of the same field in a refinement chain.  One may add
     `non_null', `nullable', `spec_public', or `spec_protected' to any
     of the declarations for a field in any file.  However, it is of
     course not permitted to add `spec_protected' to a field that has
     been declared public in other declarations.

   * Initializers are not allowed in all field declarations.  A
     non-model field can have an initializer expression but it can only
     appear in a `.java' file because this is where a compiler expects
     to find it.

     Fields declared using the `ghost' modifier can have an initializer
     expression in any file, but they may have at most one initializer
     expression in all the files.

     Model fields cannot have an initializer expression because there
     is no storage associated with such fields.  Use the `initially'
     clause to specify the initial state of model fields (although the
     initial state is usually determined from the represents clause).

   * Any number of JML-VAR-ASSERTION's [[[ what is this? the name must
     have changed - DRC]]] can be declared for any field declaration
     and these are all conjoined.  For example, if a variable `int
     count' is declared and there are two `initially' clauses, in the
     same or different files, then these initially clause predicates
     are conjoined; that is, both must be satisfied initially.

   * An initializer block or a static initializer block (with code) may
     only appear in a `.java' file.  One can write annotations to
     specify the effects of such initializers in JML annotations in
     other files, using the keywords `initializer' and
     `static_initializer'.

   JML uses specification inheritance to impose the specifications of
supertypes on their subtypes [Dhara-Leavens96] [Leavens-Naumann06]
[Leavens06b] to support the concept of behavioral subtyping [America87]
[Leavens90] [Leavens91] [Leavens-Weihl90] [Leavens-Weihl95]
[Liskov-Wing94].  JML also supports a notion of weak behavioral
subtyping [Dhara-Leavens94b] [Dhara97].


File: jmlrefman.info,  Node: Refinement Viewpoints,  Prev: Type Checking Refinements,  Up: Refinement

16.5 Refinement Viewpoints
==========================

In refinements, specification inheritance allows the specifier to
separate the public, protected, and private specifications into
different files.  Public specifications give the public behavior and are
meant for clients of the class.  Protected specifications are meant for
programmers creating subclasses and give the protected behavior of the
type; they give the behavior of protected methods and fields that are
not visible to clients.  Similarly, private specifications are meant for
implementors of the class and provide the behavior related to private
methods and fields of the class; implementors must satisfy the combined
public, protected, and private specifications of a method.

   [[[Needs work]]]

* Menu:

* Default Constructor Refinement::


File: jmlrefman.info,  Node: Default Constructor Refinement,  Prev: Refinement Viewpoints,  Up: Refinement Viewpoints

16.5.1 Default Constructor Refinement
-------------------------------------

In Java, a default constructor is automatically generated for a class
when no constructors are declared in a class.  However, in JML, a
default constructor is not generated for a class unless the file suffix
is `.java' (the same constructor is generated as in the Java language).
Consider, for example, the refinement sequence defined by the following
three files, `RefineDemo.jml-refined', `RefineDemo.jml', and
`RefineDemo.java'.

     // ---- file RefineDemo.jml-refined ---
     package org.jmlspecs.samples.jmlrefman;

     public class RefineDemo {
        //@ public model int x;

        /*@ public normal_behavior
          @    assignable x;
          @    ensures x == 0; @*/
        public RefineDemo();
     }

     // ---- file RefineDemo.jml -----------
     package org.jmlspecs.samples.jmlrefman;

     //@ refine "RefineDemo.jml-refined";

     public class RefineDemo {
        protected int x_;
        //@           in x;

        //@ protected represents x <- x_;
     }

     // ---- file RefineDemo.java ---------
     package org.jmlspecs.samples.jmlrefman;

     //@ refine "RefineDemo.jml";

     public class RefineDemo {
        protected int x_;
        public RefineDemo() { x_ = 0; }
     }

   In the protected specification declared in `RefineDemo.jml', no
constructor is defined.  If JML were to generate a default constructor
for this class declaration, then the `public' constructor defined
earlier in the refinement chain, in `RefineDemo.jml-refined', could
have a visibility modifier that conflicts with the one automatically
generated for the protected specification. (The visibility modifier of
an automatically generated default constructor depends on other factors
including the visibility of the class.  *Note Lightweight Specification
Cases::, for more details.)  Recall that the signature, including the
visibility modifier, must match for every method and constructor
declared in a refinement chain.  To avoid such conflicts, JML does not
generate a default constructor unless the file suffix is `.java' (as
part of the standard compilation process).

   A similar problem can occur when the only constructor is protected or
private as in the refinement sequence defined by the following three
files, `RefineDemo2.jml-refined', `RefineDemo2.jml', and
`RefineDemo2.java'.

     // ---- file RefineDemo2.jml-refined --
     package org.jmlspecs.samples.jmlrefman;

     public class RefineDemo2 {
        //@ public model int x;
        //@ public initially x == 0;
     }

     // ---- file RefineDemo2.jml ----------
     package org.jmlspecs.samples.jmlrefman;

     //@ refine "RefineDemo2.jml-refined";
     public class RefineDemo2 {
        protected int x_;
        //@           in x;

        //@ protected represents x <- x_;

        /*@ protected normal_behavior
          @    assignable x;
          @    ensures x == 0; @*/
        protected RefineDemo2();
     }

     // ---- file RefineDemo2.java ---------
     package org.jmlspecs.samples.jmlrefman;

     //@ refine "RefineDemo2.jml";
     public class RefineDemo2 {
        protected int x_;
        protected RefineDemo2() { x_ = 0; }
     }

   In this example, notice that no constructor is defined for the
public specification in `RefineDemo2.jml-refined'.  If a default
constructor were generated for this class declaration, then the
`protected' constructor defined later in the refinement chain, in
`RefineDemo2.jml', would have a visibility modifier that conflicts with
the one automatically generated and JML would emit an error.  Thus JML
only generates the default constructor for the executable declaration
of a class in the `.java' file and only when required by the Java
language.


File: jmlrefman.info,  Node: MultiJava Extensions to JML,  Next: Universe Type System,  Prev: Refinement,  Up: Top

17 MultiJava Extensions to JML
******************************

This section describes extensions to JML to support the MultiJava
[Clifton-etal00] language.  All of these extensions are optional and
are only used when an option (or special tool) is used to parse this
syntax.

   The sections below explain the extensions that MultiJava makes to
JML.

* Menu:

* Augmenting Method Declarations::
* MultiMethods::


File: jmlrefman.info,  Node: Augmenting Method Declarations,  Next: MultiMethods,  Prev: MultiJava Extensions to JML,  Up: MultiJava Extensions to JML

17.1 Augmenting Method Declarations
===================================

MultiJava has a feature, called "open classes" [Clifton-etal00] or
"augmenting methods" that allows methods to be added to an existing
class.  It has the following syntax, which, in JML, permits method
specifications.

     MULTIJAVA-TOP-LEVEL-DECLARATION ::= MULTIJAVA-TOP-LEVEL-METHOD
     MULTIJAVA-TOP-LEVEL-METHOD ::= [ METHOD-SPECIFICATION ]
                   MODIFIERS [ `method' ]
                   [ TYPE-SPEC ] EXTENDING-METHOD-HEAD METHOD-BODY
     EXTENDING-METHOD-HEAD ::= NAME `.' `ident' FORMALS [DIMS ]
                               [ THROWS-CLAUSE ]

   This syntax adds a method to the class named by the NAME in the
EXTENDING-METHOD-HEAD.

   The method must satisfy the given METHOD-SPECIFICATION, if there is
one.


File: jmlrefman.info,  Node: MultiMethods,  Prev: Augmenting Method Declarations,  Up: MultiJava Extensions to JML

17.2 MultiMethods
=================

The other feature in MultiJava is multiple dispatch, which is used to
define multimethods.  Multiple dispatch is defined using the following
syntax.

     MULTIJAVA-PARAM-DECLARATION ::= [ PARAM-MODIFIER ] ...
                      TYPE-SPEC SPECIALIZER IDENT [ DIMS ]
     SPECIALIZER ::= `@' TYPE-SPEC
             | `@@' VALUE-SPECIALIZER
     VALUE-SPECIALIZER ::= EXPRESSION

   See the MultiJava paper [Clifton-etal00] for how the use of a
SPECIALIZER affects the meaning of method calls.


File: jmlrefman.info,  Node: Universe Type System,  Next: Safe Math Extensions,  Prev: MultiJava Extensions to JML,  Up: Top

18 Universe Type System
***********************

This section describes how the Universe type system
[Dietl-Drossopoulou-Mueller07] [Dietl-Mueller05]
[Dietl-Mueller-Schregenberger-08] [Mueller-Poetzsch-Heffter01a] is
realized in JML and the impact it has on JML specifications.  The
Universe type system is a lightweight ownership type system that
hierarchically structures the object store and confines the possible
effects of expressions.

   The syntax for the Universe type system consists of three ownership
modifiers.

     OWNERSHIP-MODIFIERS ::= OWNERSHIP-MODIFIER [ OWNERSHIP-MODIFIER ]
     OWNERSHIP-MODIFIER ::= `\rep' | `\peer' | `\readonly'
              | RESERVED-OWNERSHIP-MODIFIER // with -universesx parse or -universesx full
     RESERVED-OWNERSHIP-MODIFIER ::= `rep' | `peer' | `readonly'

   Depending on the options selected, one can use either form of the
modifiers, with or without the backslash, in annotations.  The forms
without the backslashes are the only ones that can be used in Java
code, and when they are enabled, they are treated as new reserved words
in both JML annotations and in Java code.

   Currently the Universe type checking and the
RESERVED-OWNERSHIP-MODIFIER syntax are not enabled by default in JML,
but is only available when various options are used in the tools.  It
can also be used with different levels of checking.  If the
`--universesx no' option is used, only the OWNERSHIP-MODIFIERs `\rep',
`\peer', and `\readonly' are available.

   To enable just parsing of the full syntax, one can use the
`--universesx parse' option; in this case, all of the syntax is parsed,
and `rep', `peer', and `readonly' are treated as reserved words.
However, with this option, none of the checking described below is done.

   To enable checking, but without reserving the keywords `rep',
`peer', and `readonly', one uses the `--universesx check' option.  With
this option, only the OWNERSHIP-MODIFIERs `\rep', `\peer', and
`\readonly' are available.  This allows the use of universe annotations
in specifications, but not in Java code.

   One can also enable both checking and all of the syntax by using the
`--universesx full' option.  An equivalent option is `--universes'
(synonym `-e'). This parses and type checks all the
OWNERSHIP-MODIFIERs, not only in specifications, but also in Java code.

   For a simple reference type, one can use only one OWNERSHIP-MODIFIER
where OWNERSHIP-MODIFIERS appears in the grammar.  The only case where
two OWNERSHIP-MODIFIERs can be used is for array types as described
below.

   Note that in [Dietl-Drossopoulou-Mueller07] the Universe type system
is extended to type genericity as found in Java 5. The JML tools support
Generic Universe Types and also recognize the `any' modifier as synonym
for `readonly'.  As the rest of this report is about non-generic Java,
we refer to [Dietl-Drossopoulou-Mueller07]
[Dietl-Mueller-Schregenberger08] for details.

   In the sections below we just use the forms without the backslashes
when discussing the semantics of each form.

* Menu:

* Basic Concepts of Universes::
* Rep and Peer::
* Readonly::
* Ownership Modifiers for Array Types::
* Default Ownership Modifiers::
* Ownership Type Rules::
* Casts and Ownership Types::


File: jmlrefman.info,  Node: Basic Concepts of Universes,  Next: Rep and Peer,  Prev: Universe Type System,  Up: Universe Type System

18.1 Basic Concepts of Universes
================================

The Universe type system organizes objects into ownership contexts
[Dietl-Mueller05] [Mueller-Poetzsch-Heffter01a].  Each object has 0 or
1 "owner" objects.  The owner of an object (or the absence of an owner)
is determined by the `new' expression that creates the object.  Once
determined, the owner of an object cannot be changed.

   An "ownership context" is a set of objects with the same owner.
There is also a "root ownership context", which is the set of all
objects that have no owner.  Each object thus belongs to exactly one
ownership context.  The contexts form a hierarchy, with the root
ownership context at the top.  The owner of an ownership context is not
considered to be part of the context it owns, but rather part of that
context's parent context.

   The Universe type system enforces the "owner-as-modifier" property
(see section 1 of [Dietl-Mueller05]).  This property says "an object X
can be referenced by any other object, but reference chains that do not
pass through Xs owner must not be used to modify X" (section 1 of
[Dietl-Mueller05]).  Thus, if one looks at all the references from
outside an ownership context into objects within the context, all of
these references must be readonly references, with the exception of any
references from the context's owner.


File: jmlrefman.info,  Node: Rep and Peer,  Next: Readonly,  Prev: Basic Concepts of Universes,  Up: Universe Type System

18.2 Rep and Peer
=================

The `rep' and `peer' annotations are type modifiers (*note
Type-Specs::) that specify ownership relative to a receiver object.
The "receiver" object is defined as follows:
   * For a field access of the form E.f, the receiver object is the
     result of the expression E.

   * For a call to an instance method of the form E.m(...), the
     receiver object is the result of the expression E.

   * For all other expressions occurring in the declaration of an
     instance method or constructor (including the specification), or
     in an instance invariant or instance history constraint, the
     receiver object is `this'.

   * For all other expressions in the declaration of a static method,
     there is no receiver object.  In this case, the ownership modifier
     specifies ownership relative to the current ownership context, as
     explained below.

   A `rep' modifier says that the referenced object is owned by the
receiver object.  Thus if `myList' has a field `head' of type `rep
Node', then `myList.head' is owned by `myList', because `myList' is the
receiver.  If `n' is a local variable of type `rep Node' in an instance
method, then `n' is owned by `this'.  (Formal parameters are treated in
exactly the same way as local variables.)

   Since the meaning of the `rep' modifier depends on the existence of
a receiver object, it cannot be used in static declarations where there
is no receiver object.  Hence, a `rep' modifier cannot be used in a
static field declaration.  It also cannot be used in the declaration of
a static method or in its specification.  Furthermore, it cannot be
used in static invariants or static history constraints.

   A `peer' modifier says that the referenced object has the same owner
as the receiver object.  Thus if `myNode' has a field `next' of type
`peer Node', then `myNode.next' is owned by the owner of `myNode',
because `myNode' is the receiver.  If `n' is a local variable of type
`peer Node' in an instance method, then `n' is owned by the owner of
`this'.

   The `peer' modifier can be used in all declarations, even in static
declarations.  Currently, a `peer' modifier in a static field
declaration leads to type unsafety and should therefore not be used.
(The tools give a warning in this situation, and a safe semantics is a
subject of current research.)  The same remark applies to static
invariants and static history constraints.

   When used in a static method or its specification, `peer' refers to
the current ownership context.  The "current ownership context" for a
method execution is defined as follows.  For executions of instance
methods the current ownership context is the one containing the `this'
object.  For executions of static methods, the current ownership
context is determined by the current ownership context of the caller
and the ownership modifier (`rep' or `peer') used in the call as
follows:
   * If the call has the form `peer' T`.'m`(...)', then m executes in
     the same ownership context as the code making the call (and hence
     in the current ownership context of the caller).

   * If the call has the form `rep' T`.'m`(...)', then m executes in
     the ownership context owned by the caller's `this' object; hence
     this form of static method call cannot be used in static
     declarations.

   For example, if `p' is a local variable of type `peer Node' in a
static method, then `p' is in the current ownership context, because
there is no receiver object.

   *Note Ownership Modifiers for Array Types::, for the usage of these
modifiers with array types.


File: jmlrefman.info,  Node: Readonly,  Next: Ownership Modifiers for Array Types,  Prev: Rep and Peer,  Up: Universe Type System

18.3 Readonly
=============

The `readonly' (or `\readonly') modifier does not specify an ownership
context.  Therefore, following the owner-as-modifier property,
references specified with the `readonly' modifier cannot be used to
modify the referenced object.  (Note that this does not guarantee that
the object referenced cannot change, only that it cannot be changed
using this reference.)

   A readonly type thus cannot be used as the type of the receiver
expression of: a field update, or a call to a non-`pure' method.
(*Note Pure Methods and Constructors::, for more about pure methods.)


File: jmlrefman.info,  Node: Ownership Modifiers for Array Types,  Next: Default Ownership Modifiers,  Prev: Readonly,  Up: Universe Type System

18.4 Ownership Modifiers for Array Types
========================================

An array of reference types always has two ownership modifiers, the
first for the array object itself and the second for the elements.
Both modifiers express ownership relative to the receiver object and
both modifiers can be any of the OWNERSHIP-MODIFIERs.  For example, the
type `rep readonly Object[]' says that the array object itself is owned
by the receiver object, but the elements are readonly (and hence may
belong to an arbitrary ownership context).  A `peer rep Object[]' type
says that the array object has the same owner as the receiver object
and that the array elements are owned by the receiver object.

   For arrays of primitive types, the second ownership modifier is
omitted.  For example, the type `readonly int[]' says that the array
object can belong to any context, but cannot be modified through this
reference.

   All array objects in a multidimensional array are in the same
context, which is determined by the first ownership modifier.  For
example, if an instance field, `m', has type `rep int[][]', then `m'
and `m[3]' are both owned by the receiver.

   Following the convention in Java, array types support covariant
subtyping that needs runtime checks on write accesses.


File: jmlrefman.info,  Node: Default Ownership Modifiers,  Next: Ownership Type Rules,  Prev: Ownership Modifiers for Array Types,  Up: Universe Type System

18.5 Default Ownership Modifiers
================================

If the OWNERSHIP-MODIFIERS are omitted in a TYPE-SPEC, then a default
is used.  This default is normally `peer', but there are a few
exceptions, described below.

   * The ownership modifier of immutable types defaults to `readonly'.
     Currently, the set of immutable types only includes the Java
     wrapper types for primitive types (e.g. `java.lang.Integer' and
     `java.lang.Long'), `java.lang.String', `java.lang.Class', and
     `java.math.BigInteger'.

   * The ownership modifiers of local variable declarations are
     propagated from the initializer expression.  If no initializer is
     present, the other defaults are applied.

   * The ownership modifiers of field declarations are propagated from
     the initializer expression.  If no initializer is present, the
     other defaults are applied.  If a field type was already used to
     determine the ownership modifier of some other field, i.e. it was
     used in the initializer expression of some other field, then the
     type can not be changed any more and the normal `peer' default is
     used.

   * The default modifier for explicit formal parameters to a `pure'
     method (but not for the receiver, `this') is `readonly'.  (Note
     that this is not the case for pure constructors, however.)

   * The parameter and return types of overriding methods take the
     ownership modifiers of the overridden method, if no ownership
     modifier is specified.  If an incompatible ownership modifier is
     used in an overriding method, an error is raised.

   * The default ownership modifier for a type in the `throws' clause
     of a method header, and in the declaration of a `catch' clause of
     a `try' statement is `readonly' [Dietl-Mueller04].

   * If, for a type that is an array of references, one of the two
     ownership modifiers is omitted, then the element type is used to
     determine the meaning of the ownership modifier.  If the element
     type is a mutable type, then the specified modifier is taken to be
     the element modifier, and the array's modifier defaults to `peer'.
     If the element type is an immutable type, then the specified
     modifier is taken to be the array modifier, and the element
     modifier defaults to `readonly'.  For example, the type `readonly
     Object[]' is the same as `peer readonly Object[]'.  A type `rep
     Integer[]' is the same as `rep readonly Integer[]'.  Note that if
     one wants to specify a `rep' or `readonly' array of mutable
     references, one is thus forced to use two ownership modifiers; for
     example, `rep readonly Object[]'.

   * In a cast expression of the form `('T`)'E, where T is a reference
     type that is not an array type, the default ownership modifier of
     T is the ownership modifier of the type of E; in this case, if the
     type of E is an array type, this is the ownership modifier of the
     array object itself, not the ownership modifier of the elements.

     In a cast expression of the form `('T`)'E, where T is an array
     type, the default ownership modifiers of T are the same as the
     ownership modifiers of the type of E.

     In a cast expression of the form `('T`)'E, where T is a primitive
     value type, there is no ownership modifier attached to T.

   * In an `instanceof' expression of the form E `instanceof' T, where
     T is a reference type that is not an array type, the default
     ownership modifier of T is the ownership modifier of the type of
     E; in this case, if the type of E is an array type, this is the
     ownership modifier of the array object itself, not the ownership
     modifier of the elements.

     In an `instanceof' expression of the form E `instanceof' T, where
     T is an array type, the default ownership modifiers of T are the
     same as the ownership modifiers of the type of E.

   The defaults for casts and instanceof expressions allow one to only
test for Java types, if the ownership modifiers are omitted
[Dietl-Mueller05].  *Note Casts and Ownership Types::, for more details
on these expressions and their interaction with the Universe type
system.


File: jmlrefman.info,  Node: Ownership Type Rules,  Next: Casts and Ownership Types,  Prev: Default Ownership Modifiers,  Up: Universe Type System

18.6 Ownership Type Rules
=========================

This section explains details of how the Universe type system does type
checking.

* Menu:

* Ownership Subtyping::
* Ownership Typing for Expressions::


File: jmlrefman.info,  Node: Ownership Subtyping,  Next: Ownership Typing for Expressions,  Prev: Ownership Type Rules,  Up: Ownership Type Rules

18.6.1 Ownership Subtyping
--------------------------

Type checking in the Universe type system uses a notion of subtyping
that extends Java's rules to take OWNERSHIP-MODIFIERS into account (see
Section 3 of [Dietl-Mueller05]).

   If two types have the same ownership modifiers, then they are
subtypes if the underlying Java types are subtypes.  For example, `rep
Stack' is a subtype of `rep Object', because `Stack' is a subtype of
`Object'.

   If S is a reference type, then both `peer' S and `rep' S are
subtypes of the type `readonly' S. Moreover, both `peer' om S`[]' and
`rep' om S`[]' are subtypes of the type `readonly' om S`[]', where om
is any ownership modifier. For instance, `peer peer Natural[]' is a
subtype of `readonly peer Natural[]'.

   The types `peer' S and `rep' S as well as the array types `peer' om
S`[]' and `rep' om S`[]' are incomparable--neither is a subtype of the
other.

   Like Java, the Universe type system has covariant array subtyping:
"two array types with the same ownership modifier are subtypes if their
element types are subtypes. ...  For instance, `rep peer Object[]' is a
subtype of `rep readonly Object[]' because the element type `peer
Object' is a subtype of the element type `readonly Object'" (Section 3
of [Dietl-Mueller05]).


File: jmlrefman.info,  Node: Ownership Typing for Expressions,  Prev: Ownership Subtyping,  Up: Ownership Type Rules

18.6.2 Ownership Typing for Expressions
---------------------------------------

Most of the typing rules for the Universe type system are unchanged
from standard Java (and JML) rules.  For example, to type check an
assignment expression, one checks that the type of the right hand side
expression is a subtype of the type of the left hand side.

   A small, but important change, is that the type given in a `new'
expression must be a `rep' or `peer' type.  The result type of the
`new' expression has the given ownership modifier.

   The main difference is that the type of field accesses, method
parameters, and method results is determined by combining the type of
the receiver, R, and the type of the field, the return type of the
method, or the type of the formal parameter, F.  The Java type is taken
from the type F, and the modifier is determined by the following cases
(see Section 3 of [Dietl-Mueller05]):
  1. If both R and F are `peer' types, then the combination is also a
     `peer' type.  For example, if `myList' has type `peer List' and
     the field `head' has type `peer Node', then `myList.head' has type
     `peer Node'.

  2. If the receiver is `this' and F is a `rep' type, then the
     combination is a `rep' type.  For example, if a `Set' class has an
     instance field `elems' of type `rep List', then in its instance
     methods, `this.elems' has type `rep List'.

  3. If R is a `rep' type and F is a `peer' type, then the combination
     is a `rep' type.  For example, `(this.elems).head' has type `rep
     Node', because the receiver `this.elems' has type `rep List', and
     the type of field `head' is `peer Node'.

  4. Otherwise, the combination is a `readonly' type.  For example, if
     `e' has type `readonly List', then `e.head' has type `readonly
     Node'.

   One can also illustrate these rules using method calls.  For
example, consider a method `lastNode' with the following signature.
        public peer Node lastNode()
   In this example, if `elems' has type `rep List', then a call such as
`elems.lastNode()' has type `rep Node' (by case 3).

   As another example, consider a method `addNode' with the following
signature.
        public void addNode(peer Node n)
   Still assuming that `elems' has type `rep List', a call such as
`elems.addNode(p)', requires that `p' has type `rep Node' (also by case
3), because the argument, `p', has to have the same owner as the
receiver of call, `elems', namely `this'.

   The rules are analogous for arrays.  For example, suppose that an
instance field `a' has type `rep readonly Object[]'.  Then the
expression `this.a' has the same type, `rep readonly Object[]' (by case
2).  Similarly, if `r' has a `readonly' type, then `r.a' would have type
`readonly readonly Object[]' (by case 4).

   Finally, consider a static method that returns a `peer' object, such
as the following, in a class `Cache'.
        public static peer int[] getInstance()
   A call such as `peer Cache.getInstance()' has type `peer int[]' (by
case 1).


File: jmlrefman.info,  Node: Casts and Ownership Types,  Prev: Ownership Type Rules,  Up: Universe Type System

18.7 Casts and Ownership Types
==============================

Since `readonly' types are supertypes of the corresponding `rep' and
`peer' types, it is possible to do a downcast.  Such a downcast will
succeed when the object is in the context specified by the peer or rep
type.  For example, suppose `ro' has type `readonly List'.  Then the
cast `(rep List) ro' will succeed only if the object referenced by `ro'
is owned by `this'.  The cast `(peer List) ro' will succeed only if the
object referenced by `ro' is owned by the owner of `this'.

   Instanceof expressions of the form E `instanceof' T yield true when
the value of E is not `null' and the corresponding cast would succeed.
For example, suppose `ro' has type `readonly List'.  Then `ro
instanceof rep List' yields true only if `ro' references an object that
is owned by `this'.

   Both casts and instanceof expressions have runtime overhead, in
general.  (Furthermore, as in Java, array updates also generate runtime
checks.)

   See [Dietl-Drossopoulou-Mueller07] [Dietl-Mueller-Schregenberger08]
for a complete list of the Universe type system rules and the different
supported compiler options.


File: jmlrefman.info,  Node: Safe Math Extensions,  Next: Deprecated and Replaced Syntax,  Prev: Universe Type System,  Up: Top

19 Safe Math Extensions
***********************

* Menu:

* Backslash bigint::
* Backslash real::


File: jmlrefman.info,  Node: Backslash bigint,  Next: Backslash real,  Prev: Safe Math Extensions,  Up: Safe Math Extensions

19.1 \bigint
============

[[[ needs discussion ]]]


File: jmlrefman.info,  Node: Backslash real,  Prev: Backslash bigint,  Up: Safe Math Extensions

19.2 \real
==========

[[[ needs discussion ]]]


File: jmlrefman.info,  Node: Deprecated and Replaced Syntax,  Next: Grammar Summary,  Prev: Safe Math Extensions,  Up: Top

20 Deprecated and Replaced Syntax
*********************************

The subsections below briefly describe the deprecated and replaced
features of JML.  A feature is "deprecated" if it is supported in the
current release, but slated to be removed from a subsequent release.
Such features should not be used.

   A feature that was formerly deprecated is "replaced" if it has been
removed from JML in favor of some other feature or features.  While we
do not describe all replaced syntax in this appendix, we do mention a
few of the more interesting or important features that were replaced,
especially those discussed in earlier papers on JML.

* Menu:

* Deprecated Syntax::
* Replaced Syntax::


File: jmlrefman.info,  Node: Deprecated Syntax,  Next: Replaced Syntax,  Prev: Deprecated and Replaced Syntax,  Up: Deprecated and Replaced Syntax

20.1 Deprecated Syntax
======================

The following syntax is deprecated.


File: jmlrefman.info,  Node: Replaced Syntax,  Prev: Deprecated Syntax,  Up: Deprecated and Replaced Syntax

20.2 Replaced Syntax
====================

As a note for readers of older papers, the keyword
`subclassing_contract' was replaced with `code_contract', which is now
removed.  Instead, one should use a heavyweight specification case with
the keyword `code' just before the behavior keyword, and a precondition
of `\same'.

   Similarly, the `depends' clause has been replaced by the mechanism
of data groups and the `in' and `maps' clauses of variable declarations.


File: jmlrefman.info,  Node: Grammar Summary,  Next: Modifier Summary,  Prev: Deprecated and Replaced Syntax,  Up: Top

Appendix A Grammar Summary
**************************

The following is a summary of the context-free grammar for JML.  *Note
Syntax Notation::, for the notation used.  In the first section below,
grammatical productions are to be understood lexically.  That is, no
white space (*note White Space::) may intervene between the characters
of a token.

A.1 Lexical Conventions
=======================


     MICROSYNTAX ::= LEXEME [ LEXEME ] ...
     LEXEME ::= WHITE-SPACE | LEXICAL-PRAGMA | COMMENT
             | ANNOTATION-MARKER | DOC-COMMENT | TOKEN
     TOKEN ::= IDENT | KEYWORD | SPECIAL-SYMBOL
             | JAVA-LITERAL | INFORMAL-DESCRIPTION
     WHITE-SPACE ::= NON-NL-WHITE-SPACE | END-OF-LINE
     NON-NL-WHITE-SPACE ::= a blank, tab, or formfeed character
     END-OF-LINE ::= NEWLINE | CARRIAGE-RETURN
             | CARRIAGE-RETURN NEWLINE
     NEWLINE ::= a newline character
     CARRIAGE-RETURN ::= a carriage return character
     LEXICAL-PRAGMA ::= NOWARN-PRAGMA
     NOWARN-PRAGMA ::= `nowarn' [ SPACES ] [ NOWARN-LABEL-LIST ] `;'
     SPACES ::= NON-NL-WHITE-SPACE [ NON-NL-WHITE-SPACE ] ...
     NOWARN-LABEL-LIST ::= NOWARN-LABEL [ SPACES ]
                  [ `,' [ SPACES ] NOWARN-LABEL [ SPACES ] ] ...
     NOWARN-LABEL ::= LETTER [ LETTER ] ...
     COMMENT ::= C-STYLE-COMMENT | C++-STYLE-COMMENT
     C-STYLE-COMMENT ::= `/*' [ C-STYLE-BODY ] C-STYLE-END
     C-STYLE-BODY ::= NON-AT-PLUS-STAR [ NON-STARS-SLASH ] ...
             | `+' NON-AT [ NON-STARS-SLASH ] ...
             | STARS-NON-SLASH [ NON-STARS-SLASH ] ...
     NON-STARS-SLASH ::= NON-STAR
             | STARS-NON-SLASH
     STARS-NON-SLASH ::= `*' [ `*' ] ... NON-STAR-SLASH
     NON-AT-PLUS-STAR ::= any character except `@', `+', or `*'
     NON-AT ::= any character except `@'
     NON-STAR ::= any character except `*'
     NON-SLASH ::= any character except `/'
     NON-STAR-SLASH ::= any character except `*' or `/'
     C-STYLE-END ::= [ `*' ] ... `*/'
     C++-STYLE-COMMENT ::= `//' [ `+' ] END-OF-LINE
             | `//' NON-AT-PLUS-END-OF-LINE [ NON-END-OF-LINE ] ... END-OF-LINE
             | `//+' NON-AT-END-OF-LINE [ NON-END-OF-LINE ] ... END-OF-LINE
     NON-END-OF-LINE ::= any character except a newline or carriage return
     NON-AT-PLUS-END-OF-LINE ::= any character except `@', `+', newline, or carriage return
     NON-AT-END-OF-LINE ::= any character except `@', newline, or carriage return
     ANNOTATION-MARKER ::= `//@' [ `@' ] ... | `//+@' [ `@' ] ...
             | `/*@' [ `@' ] ... | `/*+@' [ `@' ] ... | [ `@' ] ... `@+*/' | [ `@' ] ... `*/'
     IGNORED-AT-IN-ANNOTATION ::= `@'
     DOC-COMMENT ::= `/**' [ `*' ] ... DOC-COMMENT-BODY `*/'
     DOC-COMMENT-IGNORED ::= DOC-COMMENT
     DOC-COMMENT-BODY ::= [ DESCRIPTION ] ...
                          [ TAGGED-PARAGRAPH ] ...
                          [ JML-SPECS ]
     DESCRIPTION ::= DOC-NON-EMPTY-TEXTLINE
     TAGGED-PARAGRAPH ::= PARAGRAPH-TAG [ DOC-NON-NL-WS ] ...
                  [ DOC-ATSIGN ] ... [ DESCRIPTION ] ...
     JML-SPECS ::= JML-TAG [ METHOD-SPECIFICATION ] END-JML-TAG
                  [ JML-TAG [ METHOD-SPECIFICATION ] END-JML-TAG ] ...
     PARAGRAPH-TAG ::= `@author' | `@deprecated' | `@exception'
             | `@param' | `@return' | `@see'
             | `@serial' | `@serialdata' | `@serialfield'
             | `@since' | `@throws' | `@version'
             | `@' LETTER [ LETTER ] ...
     DOC-ATSIGN ::= `@'
     DOC-NL-WS ::= END-OF-LINE
               [ DOC-NON-NL-WS ] ... [ `*' [ `*' ] ... [ DOC-NON-NL-WS ] ... ]
     DOC-NON-NL-WS ::= NON-NL-WHITE-SPACE
     DOC-NON-EMPTY-TEXTLINE ::= NON-AT-END-OF-LINE [ NON-END-OF-LINE ] ...
     JML-TAG ::= `<jml>' | `<JML>' | `<esc>' | `<ESC>'
     END-JML-TAG ::= `</jml>' | `</JML>' | `</esc>' | `</ESC>'
     IDENT ::= LETTER [ LETTER-OR-DIGIT ] ...
     LETTER ::= `_', `$', `a' through `z', or `A' through `Z'
     DIGIT ::= `0' | `1' | `2' | `3' | `4' | `5' | `6' | `7' | `8' | `9'
     LETTER-OR-DIGIT ::= LETTER | DIGIT
     KEYWORD ::= JAVA-RESERVED-WORD
             | JML-PREDICATE-KEYWORD | JML-KEYWORD
     JAVA-RESERVED-WORD ::= `abstract' | `assert'
             | `boolean' | `break' | `byte'
             | `case' | `catch' | `char'
             | `class' | `const' | `continue'
             | `default' | `do' | `double'
             | `else' | `extends' | `false'
             | `final' | `finally' | `float'
             | `for' | `goto' | `if'
             | `implements' | `import' | `instanceof'
             | `int' | `interface' | `long'
             | `native' | `new' | `null'
             | `package' | `private' | `protected'
             | `public' | `return' | `short'
             | `static' | `strictfp' | `super'
             | `switch' | `synchronized' | `this'
             | `throw' | `throws' | `transient'
             | `true' | `try' | `void'
             | `volatile' | `while'
             | MULTIJAVA-RESERVED      // When the MultiJava option is on
             | JAVA-UNIVERSE-RESERVED  // When the Universe option is on
     MULTIJAVA-RESERVED ::= `resend'
     JAVA-UNIVERSE-RESERVED ::= `peer' | `pure'
             | `readonly' | `rep'
     JML-PREDICATE-KEYWORD ::= `\TYPE'
             | `\bigint' | `\bigint_math' | `\duration'
             | `\elemtype' | `\everything' | `\exists'
             | `\forall' | `\fresh'
             | `\into' | `\invariant_for' | `\is_initialized'
             | `\java_math' | `\lblneg' | `\lblpos'
             | `\lockset' | `\max' | `\min'
             | `\nonnullelements' | `\not_assigned'
             | `\not_modified' | `\not_specified'
             | `\nothing' | `\nowarn' | `\nowarn_op'
             | `\num_of' | `\old' | `\only_accessed'
             | `\only_assigned' | `\only_called'
             | `\only_captured' | `\pre'
             | `\product' | `\reach' | `\real'
             | `\result' | `\same' | `\safe_math'
             | `\space' | `\such_that' | `\sum'
             | `\typeof' | `\type' | `\warn_op'
             | `\warn' | `\working_space'
             | JML-UNIVERSE-PKEYWORD
     JML-UNIVERSE-PKEYWORD ::= `\peer' | `\readonly' | `\rep'
     JML-KEYWORD ::= `abrupt_behavior' | `abrupt_behaviour'
             | `accessible' | `accessible_redundantly'
             | `also' | `assert_redundantly'
             | `assignable' | `assignable_redundantly'
             | `assume' | `assume_redundantly' | `axiom'
             | `behavior' | `behaviour'
             | `breaks' | `breaks_redundantly'
             | `callable' | `callable_redundantly'
             | `captures' | `captures_redundantly'
             | `choose' | `choose_if'
             | `code' | `code_bigint_math' |
             | `code_java_math' | `code_safe_math'
             | `constraint' | `constraint_redundantly'
             | `constructor' | `continues' | `continues_redundantly'
             | `decreases' | `decreases_redundantly'
             | `decreasing' | `decreasing_redundantly'
             | `diverges' | `diverges_redundantly'
             | `duration' | `duration_redundantly'
             | `ensures' | `ensures_redundantly' | `example'
             | `exceptional_behavior' | `exceptional_behaviour'
             | `exceptional_example'
             | `exsures' | `exsures_redundantly' | `extract'
             | `field' | `forall'
             | `for_example' | `ghost'
             | `helper' | `hence_by' | `hence_by_redundantly'
             | `implies_that' | `in' | `in_redundantly'
             | `initializer' | `initially' | `instance'
             | `invariant' | `invariant_redundantly'
             | `loop_invariant' | `loop_invariant_redundantly'
             | `maintaining' | `maintaining_redundantly'
             | `maps' | `maps_redundantly'
             | `measured_by' | `measured_by_redundantly'
             | `method' | `model' | `model_program'
             | `modifiable' | `modifiable_redundantly'
             | `modifies' | `modifies_redundantly'
             | `monitored' | `monitors_for' | `non_null'
             | `normal_behavior' | `normal_behaviour'
             | `normal_example' | `nowarn'
             | `nullable' | `nullable_by_default'
             | `old' | `or'
             | `post' | `post_redundantly'
             | `pre' | `pre_redundantly'
             | `pure' | `readable'
             | `refine' | `refines' | `refining'
             | `represents' | `represents_redundantly'
             | `requires' | `requires_redundantly'
             | `returns' | `returns_redundantly'
             | `set' | `signals' | `signals_only'
             | `signals_only_redundantly' | `signals_redundantly'
             | `spec_bigint_math' | `spec_java_math'
             | `spec_protected' | `spec_public' | `spec_safe_math'
             | `static_initializer' | `uninitialized'
             | `unreachable' | `weakly'
             | `when' | `when_redundantly'
             | `working_space' | `working_space_redundantly'
             | `writable'
             | JML-UNIVERSE-KEYWORD
     JML-UNIVERSE-KEYWORD ::= `peer' | `readonly' | `rep'
     SPECIAL-SYMBOL ::= JAVA-SPECIAL-SYMBOL | JML-SPECIAL-SYMBOL
     JAVA-SPECIAL-SYMBOL ::= JAVA-SEPARATOR | JAVA-OPERATOR
     JAVA-SEPARATOR ::= `(' | `)' | `{' | `}' | ``['' | ``]'' | `;' | `,' | `.'
             | MULTIJAVA-SEPARATOR   // When the MultiJava option is on
     MULTIJAVA-SEPARATOR ::= `@' | `@@'
     JAVA-OPERATOR ::= `=' | `<' | `>' | `!' | `~' | `?' | `:'
             | `==' | `<=' | `>=' | `!=' | `&&' | ``||'' | `++' | `--'
             | `+' | `-' | `*' | `/' | `&' | ``|'' | `^' | `%' | `<<' | `>>' | `>>>'
             | `+=' | `-=' | `*=' | `/=' | `&=' | ``|='' | `^=' | `%='
             | `<<=' | `>>=' | `>>>='
     JML-SPECIAL-SYMBOL ::= `==>' | `<==' | `<==>' | `<=!=>'
             | `->' | `<-' | `<:' | `..' | ``{|'' | ``|}''
     JAVA-LITERAL ::= INTEGER-LITERAL
             | FLOATING-POINT-LITERAL | BOOLEAN-LITERAL
             | CHARACTER-LITERAL | STRING-LITERAL | NULL-LITERAL
     INTEGER-LITERAL ::= DECIMAL-INTEGER-LITERAL
             | HEX-INTEGER-LITERAL | OCTAL-INTEGER-LITERAL
     DECIMAL-INTEGER-LITERAL ::= DECIMAL-NUMERAL [ INTEGER-TYPE-SUFFIX ]
     DECIMAL-NUMERAL ::= `0' | NON-ZERO-DIGIT [ DIGITS ]
     DIGITS ::= DIGIT [ DIGIT ] ...
     DIGIT ::= `0' | NON-ZERO-DIGIT
     NON-ZERO-DIGIT ::= `1' | `2' | `3' | `4' | `5' | `6' | `7' | `8' | `9'
     INTEGER-TYPE-SUFFIX ::= `l' | `L'
     HEX-INTEGER-LITERAL ::= HEX-NUMERAL  [ INTEGER-TYPE-SUFFIX ]
     HEX-NUMERAL ::= `0x' HEX-DIGIT [ HEX-DIGIT ] ...
             | `0X' HEX-DIGIT  [ HEX-DIGIT ] ...
     HEX-DIGIT ::= DIGIT | `a' | `b' | `c' | `d' | `e' | `f'
             | `A' | `B' | `C' | `D' | `E' | `F'
     OCTAL-INTEGER-LITERAL ::= OCTAL-NUMERAL  [ INTEGER-TYPE-SUFFIX ]
     OCTAL-NUMERAL ::= `0' OCTAL-DIGIT [ OCTAL-DIGIT ] ...
     OCTAL-DIGIT ::= `0' | `1' | `2' | `3' | `4' | `5' | `6' | `7'
     FLOATING-POINT-LITERAL ::= DIGITS `.' [ DIGITS ]
               [ EXPONENT-PART ] [ FLOAT-TYPE-SUFFIX ]
             | `.' DIGITS [ EXPONENT-PART ] [ FLOAT-TYPE-SUFFIX ]
             | DIGITS EXPONENT-PART [ FLOAT-TYPE-SUFFIX ]
             | DIGITS [ EXPONENT-PART ] FLOAT-TYPE-SUFFIX
     EXPONENT-PART ::= EXPONENT-INDICATOR SIGNED-INTEGER
     EXPONENT-INDICATOR ::= `e' | `E'
     SIGNED-INTEGER ::= [ SIGN ] DIGITS
     SIGN ::= `+' | `-'
     FLOAT-TYPE-SUFFIX ::= `f' | `F' | `d' | `D'
     BOOLEAN-LITERAL ::= `true' | `false'
     CHARACTER-LITERAL ::= `'' SINGLE-CHARACTER `'' | `'' ESCAPE-SEQUENCE `''
     SINGLE-CHARACTER ::= any character except `'', `\', carriage return, or newline
     ESCAPE-SEQUENCE ::= `\b'    // backspace
              | `\t'                   // tab
              | `\n'                   // newline
              | `\r'                   // carriage return
              | `\''                   // single quote
              | `\"'                   // double quote
              | `\\'                   // backslash
              | OCTAL-ESCAPE
              | UNICODE-ESCAPE
     OCTAL-ESCAPE ::= `\' OCTAL-DIGIT [ OCTAL-DIGIT ]
              | `\' ZERO-TO-THREE OCTAL-DIGIT OCTAL-DIGIT
     ZERO-TO-THREE ::= `0' | `1' | `2' | `3'
     UNICODE-ESCAPE ::= `\u' HEX-DIGIT HEX-DIGIT HEX-DIGIT HEX-DIGIT
     STRING-LITERAL ::= `"' [ STRING-CHARACTER ] ... `"'
     STRING-CHARACTER ::= ESCAPE-SEQUENCE
              | any character except `"', `\', carriage return, or newline
     NULL-LITERAL ::= `null'
     INFORMAL-DESCRIPTION ::= `(*' NON-STARS-CLOSE [ NON-STARS-CLOSE ] ... `*)'
     NON-STARS-CLOSE ::= NON-STAR
             | STARS-NON-CLOSE
     STARS-NON-CLOSE ::= `*' [ `*' ] ... NON-STAR-CLOSE
     NON-STAR-CLOSE ::= any character except `)' or `*'

A.2 Compilation Units
=====================


     COMPILATION-UNIT ::= [ PACKAGE-DEFINITION ]
                   [ REFINE-PREFIX ]
                   [ IMPORT-DEFINITION ] ...
                   [ TOP-LEVEL-DEFINITION ] ...
     TOP-LEVEL-DEFINITION ::= TYPE-DEFINITION
             | MULTIJAVA-TOP-LEVEL-DECLARATION  // When parsing MultiJava
     PACKAGE-DEFINITION ::= `package' NAME `;'
     NAME ::= IDENT  [ `.' IDENT ] ...
     IMPORT-DEFINITION ::= [ `model' ] `import' NAME-STAR `;'
     NAME-STAR ::= IDENT [ `.' IDENT ] ... [ `.' `*' ]

A.3 Type Definitions
====================


     TYPE-DEFINITION ::= CLASS-DEFINITION
             | INTERFACE-DEFINITION
             | `;'
     CLASS-DEFINITION ::= [ DOC-COMMENT ] MODIFIERS `class' IDENT
                 [ CLASS-EXTENDS-CLAUSE ] [ IMPLEMENTS-CLAUSE ]
                 CLASS-BLOCK
     CLASS-BLOCK ::= `{' [ FIELD ] ... `}'
     INTERFACE-DEFINITION ::= [ DOC-COMMENT ] MODIFIERS `interface' IDENT
                [ INTERFACE-EXTENDS ]
                CLASS-BLOCK
     CLASS-EXTENDS-CLAUSE ::= [ `extends' NAME [ `weakly' ] ]
     IMPLEMENTS-CLAUSE ::= `implements' NAME-WEAKLY-LIST
     NAME-WEAKLY-LIST ::= NAME [ `weakly' ] [ `,' NAME [ `weakly' ] ] ...
     INTERFACE-EXTENDS ::= `extends' NAME-WEAKLY-LIST
     MODIFIERS ::= [ MODIFIER ] ...
     MODIFIER ::= `public' | `protected' | `private'
             | `abstract' | `static' |
             | `final' | `synchronized'
             | `transient' | `volatile'
             | `native' | `strictfp'
             | `const'             // reserved but not used in Java
             | JML-MODIFIER
     JML-MODIFIER ::= `spec_public' | `spec_protected'
             | `model' | `ghost' | `pure'
             | `instance' | `helper'
             | `uninitialized'
             | `spec_java_math' | `spec_safe_math' | `spec_bigint_math'
             | `code_java_math' | `code_safe_math' | `code_bigint_math'
             | `non_null' | `nullable' | `nullable_by_default'
             | `extract'

A.4 Class and Interface Member Declarations
===========================================


     FIELD ::= MEMBER-DECL
             | JML-DECLARATION
             | CLASS-INITIALIZER-DECL
             | `;'
     MEMBER-DECL ::= METHOD-DECL
             | VARIABLE-DEFINITION
             | CLASS-DEFINITION
             | INTERFACE-DEFINITION
     METHOD-DECL ::= [ DOC-COMMENT ] ...
                     METHOD-SPECIFICATION
                     MODIFIERS [ METHOD-OR-CONSTRUCTOR-KEYWORD ]
                     [ TYPE-SPEC ] METHOD-HEAD
                     METHOD-BODY
             | [ DOC-COMMENT ] ...
               MODIFIERS METHOD-OR-CONSTRUCTOR-KEYWORD
               [ TYPE-SPEC ] METHOD-HEAD
               [ METHOD-SPECIFICATION ]
               METHOD-BODY
     METHOD-OR-CONSTRUCTOR-KEYWORD ::= `method' | `constructor'
     METHOD-HEAD ::= IDENT FORMALS [ DIMS ] [ THROWS-CLAUSE ]
     METHOD-BODY ::= COMPOUND-STATEMENT | `;'
     THROWS-CLAUSE ::= `throws' NAME [ `,' NAME ] ...
     FORMALS ::= `(' [ PARAM-DECLARATION-LIST ] `)'
     PARAM-DECLARATION-LIST ::= PARAM-DECLARATION
                                [ `,' PARAM-DECLARATION ] ...
     PARAM-DECLARATION ::= [ PARAM-MODIFIER ] ... TYPE-SPEC IDENT [ DIMS ]
             | MULTIJAVA-PARAM-DECLARATION   // When MultiJava parsing is on
     PARAM-MODIFIER ::= `final' | `non_null' | `nullable'
     VARIABLE-DEFINITION ::= [ DOC-COMMENT ] ... MODIFIERS VARIABLE-DECLS
     VARIABLE-DECLS ::= [ `field' ] TYPE-SPEC VARIABLE-DECLARATORS `;'
                        [ JML-DATA-GROUP-CLAUSE ] ...
     VARIABLE-DECLARATORS ::= VARIABLE-DECLARATOR
                              [ `,' VARIABLE-DECLARATOR ] ...
     VARIABLE-DECLARATOR ::= IDENT [ DIMS ] [ `=' INITIALIZER ]
     INITIALIZER ::= EXPRESSION | ARRAY-INITIALIZER
     ARRAY-INITIALIZER ::= `{' [ INITIALIZER-LIST ] `}'
     INITIALIZER-LIST ::= INITIALIZER [ `,' INITIALIZER ] ... [ `,' ]
     TYPE-SPEC ::= [ OWNERSHIP-MODIFIERS ] TYPE [ DIMS ]
              | `\TYPE' [ DIMS ]
     TYPE ::= REFERENCE-TYPE | BUILT-IN-TYPE
     REFERENCE-TYPE ::= NAME
     DIMS ::= ``['' ``]'' [ ``['' ``]'' ] ...
     CLASS-INITIALIZER-DECL ::= [ METHOD-SPECIFICATION ]
                                [ `static' ] COMPOUND-STATEMENT
             | METHOD-SPECIFICATION `static_initializer'
             | METHOD-SPECIFICATION `initializer'

A.5 Type Specifications
=======================


     JML-DECLARATION ::= MODIFIERS INVARIANT
             | MODIFIERS HISTORY-CONSTRAINT
             | MODIFIERS REPRESENTS-CLAUSE
             | MODIFIERS INITIALLY-CLAUSE
             | MODIFIERS MONITORS-FOR-CLAUSE
             | MODIFIERS READABLE-IF-CLAUSE
             | MODIFIERS WRITABLE-IF-CLAUSE
             | AXIOM-CLAUSE
     INVARIANT ::= INVARIANT-KEYWORD PREDICATE `;'
     INVARIANT-KEYWORD ::= `invariant' | `invariant_redundantly'
     HISTORY-CONSTRAINT ::= CONSTRAINT-KEYWORD PREDICATE
                   [ `for' CONSTRAINED-LIST ] `;'
     CONSTRAINT-KEYWORD ::= `constraint' | `constraint_redundantly'
     CONSTRAINED-LIST ::= METHOD-NAME-LIST | `\everything'
     METHOD-NAME-LIST ::= METHOD-NAME [ `,' METHOD-NAME ] ...
     METHOD-NAME ::= METHOD-REF [ `(' [ PARAM-DISAMBIG-LIST ] `)' ] | METHOD-REF-START `.' `*'
     METHOD-REF ::= METHOD-REF-START [ `.' METHOD-REF-REST ] ...
             | `new' REFERENCE-TYPE
     METHOD-REF-START ::=  `super' | `this' | IDENT
     METHOD-REF-REST ::=  `this' | IDENT
     PARAM-DISAMBIG-LIST ::= PARAM-DISAMBIG [ `,' PARAM-DISAMBIG ] ...
     PARAM-DISAMBIG ::= TYPE-SPEC [ IDENT [ DIMS ] ]
     REPRESENTS-CLAUSE ::= REPRESENTS-KEYWORD STORE-REF-EXPRESSION
                         L-ARROW-OR-EQ SPEC-EXPRESSION `;'
             | REPRESENTS-KEYWORD STORE-REF-EXPRESSION `\such_that'
               PREDICATE `;'
     REPRESENTS-KEYWORD ::= `represents' | `represents_redundantly'
     L-ARROW-OR-EQ ::= `<-' | `='
     INITIALLY-CLAUSE ::= `initially' PREDICATE `;'
     AXIOM-CLAUSE ::= `axiom' PREDICATE `;'
     READABLE-IF-CLAUSE ::= `readable' IDENT `if' PREDICATE `;'
     WRITABLE-IF-CLAUSE ::= `writable' IDENT `if' PREDICATE `;'
     MONITORS-FOR-CLAUSE ::= `monitors_for' IDENT
                             L-ARROW-OR-EQ SPEC-EXPRESSION-LIST `;'

A.6 Method Specifications
=========================


     METHOD-SPECIFICATION ::= SPECIFICATION | EXTENDING-SPECIFICATION
     EXTENDING-SPECIFICATION ::= `also' SPECIFICATION
     SPECIFICATION ::= SPEC-CASE-SEQ [ REDUNDANT-SPEC ]
                   | REDUNDANT-SPEC
     SPEC-CASE-SEQ ::= SPEC-CASE [ `also' SPEC-CASE ] ...
     SPEC-CASE ::= LIGHTWEIGHT-SPEC-CASE | HEAVYWEIGHT-SPEC-CASE
             | MODEL-PROGRAM
     PRIVACY ::= `public' | `protected' | `private'
     LIGHTWEIGHT-SPEC-CASE ::= GENERIC-SPEC-CASE
     GENERIC-SPEC-CASE ::= [ SPEC-VAR-DECLS ]
                           SPEC-HEADER
                           [ GENERIC-SPEC-BODY ]
             | [ SPEC-VAR-DECLS ]
               GENERIC-SPEC-BODY
     GENERIC-SPEC-BODY ::= SIMPLE-SPEC-BODY
             | `{|' GENERIC-SPEC-CASE-SEQ `|}'
     GENERIC-SPEC-CASE-SEQ ::= GENERIC-SPEC-CASE
                               [ `also' GENERIC-SPEC-CASE ] ...
     SPEC-HEADER ::= REQUIRES-CLAUSE [ REQUIRES-CLAUSE ] ...
     SIMPLE-SPEC-BODY ::= SIMPLE-SPEC-BODY-CLAUSE
                          [ SIMPLE-SPEC-BODY-CLAUSE ] ...
     SIMPLE-SPEC-BODY-CLAUSE ::= DIVERGES-CLAUSE
             | ASSIGNABLE-CLAUSE | CAPTURES-CLAUSE
             | WHEN-CLAUSE | WORKING-SPACE-CLAUSE
             | DURATION-CLAUSE | ENSURES-CLAUSE
             | SIGNALS-ONLY-CLAUSE | SIGNALS-CLAUSE
     HEAVYWEIGHT-SPEC-CASE ::= BEHAVIOR-SPEC-CASE
             | EXCEPTIONAL-BEHAVIOR-SPEC-CASE
             | NORMAL-BEHAVIOR-SPEC-CASE
     BEHAVIOR-SPEC-CASE ::= [ PRIVACY ] [ `code' ] BEHAVIOR-KEYWORD
                            GENERIC-SPEC-CASE
     BEHAVIOR-KEYWORD ::= `behavior' | `behaviour'
     NORMAL-BEHAVIOR-SPEC-CASE ::= [ PRIVACY ] [ `code' ] NORMAL-BEHAVIOR-KEYWORD
                                   NORMAL-SPEC-CASE
     NORMAL-BEHAVIOR-KEYWORD ::= `normal_behavior' | `normal_behaviour'
     NORMAL-SPEC-CASE ::= GENERIC-SPEC-CASE
     EXCEPTIONAL-BEHAVIOR-SPEC-CASE ::= [ PRIVACY ] [ `code' ] `exceptional-behavior-keyword'
                                        EXCEPTIONAL-SPEC-CASE
     EXCEPTIONAL-BEHAVIOR-KEYWORD ::= `exceptional_behavior' | `exceptional_behaviour'
     EXCEPTIONAL-SPEC-CASE ::= GENERIC-SPEC-CASE
     SPEC-VAR-DECLS ::= FORALL-VAR-DECLS [ OLD-VAR-DECLS ]
             | OLD-VAR-DECLS
     FORALL-VAR-DECLS ::= FORALL-VAR-DECLARATOR [ FORALL-VAR-DECLARATOR ] ...
     FORALL-VAR-DECLARATOR ::= `forall' [ BOUND-VAR-MODIFIERS ] QUANTIFIED-VAR-DECLARATOR `;'
     OLD-VAR-DECLS ::= OLD-VAR-DECLARATOR [ OLD-VAR-DECLARATOR ] ...
     OLD-VAR-DECLARATOR ::= `old' [ BOUND-VAR-MODIFIERS ] TYPE-SPEC SPEC-VARIABLE-DECLARATORS `;'
     REQUIRES-CLAUSE ::= REQUIRES-KEYWORD PRED-OR-NOT `;'
             | REQUIRES-KEYWORD `\same' `;'
     REQUIRES-KEYWORD ::= `requires' | `pre'
             | `requires_redundantly' | `pre_redundantly'
     PRED-OR-NOT ::= PREDICATE | `\not_specified'
     ENSURES-CLAUSE ::= ENSURES-KEYWORD PRED-OR-NOT `;'
     ENSURES-KEYWORD ::= `ensures' | `post'
             | `ensures_redundantly' | `post_redundantly'
     SIGNALS-CLAUSE ::= SIGNALS-KEYWORD `(' REFERENCE-TYPE [ IDENT ] `)'
                        [ PRED-OR-NOT ] `;'
     SIGNALS-KEYWORD ::= `signals' | `signals_redundantly'
             | `exsures' | `exsures_redundantly'
     SIGNALS-ONLY-CLAUSE ::= SIGNALS-ONLY-KEYWORD REFERENCE-TYPE [ `,' REFERENCE-TYPE ] ... `;'
             | SIGNALS-ONLY-KEYWORD `\nothing' `;'
     SIGNALS-ONLY-KEYWORD ::= `signals_only' | `signals_only_redundantly'
     DIVERGES-CLAUSE ::= DIVERGES-KEYWORD PRED-OR-NOT `;'
     DIVERGES-KEYWORD ::= `diverges' | `diverges_redundantly'
     WHEN-CLAUSE ::= WHEN-KEYWORD PRED-OR-NOT `;'
     WHEN-KEYWORD ::= `when' | `when_redundantly'
     ASSIGNABLE-CLAUSE ::= ASSIGNABLE-KEYWORD STORE-REF-LIST `;'
     ASSIGNABLE-KEYWORD ::= `assignable' | `assignable_redundantly'
             | `modifiable' | `modifiable_redundantly'
             | `modifies' | `modifies_redundantly'
     ACCESSIBLE-CLAUSE ::= ACCESSIBLE-KEYWORD STORE-REF-LIST `;'
     ACCESSIBLE-KEYWORD ::= `accessible' | `accessible_redundantly'
     CALLABLE-CLAUSE ::= CALLABLE-KEYWORD CALLABLE-METHODS-LIST `;'
     CALLABLE-KEYWORD ::= `callable' | `callable_redundantly'
     CALLABLE-METHODS-LIST ::= METHOD-NAME-LIST | STORE-REF-KEYWORD
     MEASURED-CLAUSE ::= MEASURED-BY-KEYWORD `\not_specified' `;'
             | MEASURED-BY-KEYWORD SPEC-EXPRESSION [ `if' PREDICATE ] `;'
     MEASURED-BY-KEYWORD ::= `measured_by' | `measured_by_redundantly'
     CAPTURES-CLAUSE ::= CAPTURES-KEYWORD STORE-REF-LIST `;'
     CAPTURES-KEYWORD ::= `captures' | `captures_redundantly'
     WORKING-SPACE-CLAUSE ::= WORKING-SPACE-KEYWORD `\not_specified' `;'
             | WORKING-SPACE-KEYWORD SPEC-EXPRESSION [ `if' PREDICATE ] `;'
     WORKING-SPACE-KEYWORD ::= `working_space' | `working_space_redundantly'
     DURATION-CLAUSE ::= DURATION-KEYWORD `\not_specified' `;'
             | DURATION-KEYWORD SPEC-EXPRESSION [ `if' PREDICATE ] `;'
     DURATION-KEYWORD ::= `duration' | `duration_redundantly'

A.7 Data Groups
===============


     JML-DATA-GROUP-CLAUSE ::= IN-GROUP-CLAUSE | MAPS-INTO-CLAUSE
     IN-GROUP-CLAUSE ::= IN-KEYWORD GROUP-LIST `;'
     IN-KEYWORD ::= `in' | `in_redundantly'
     GROUP-LIST ::= GROUP-NAME [ `,' GROUP-NAME ] ...
     GROUP-NAME ::= [ GROUP-NAME-PREFIX ] IDENT
     GROUP-NAME-PREFIX ::= `super' `.' | `this' `.'
     MAPS-INTO-CLAUSE ::= MAPS-KEYWORD MEMBER-FIELD-REF `\into' GROUP-LIST `;'
     MAPS-KEYWORD ::= `maps' | `maps_redundantly'
     MEMBER-FIELD-REF ::= IDENT `.' MAPS-MEMBER-REF-EXPR
               | MAPS-ARRAY-REF-EXPR [ `.' MAPS-MEMBER-REF-EXPR ]
     MAPS-MEMBER-REF-EXPR ::= IDENT | `*'
     MAPS-ARRAY-REF-EXPR ::= IDENT MAPS-SPEC-ARRAY-DIM
                             [ MAPS-SPEC-ARRAY-DIM ] ...
     MAPS-SPEC-ARRAY-DIM ::= ``['' SPEC-ARRAY-REF-EXPR ``]''

A.8 Predicates and Specification Expressions
============================================


     PREDICATE ::= SPEC-EXPRESSION
     SPEC-EXPRESSION-LIST ::= SPEC-EXPRESSION
                              [ `,' SPEC-EXPRESSION ] ...
     SPEC-EXPRESSION ::= EXPRESSION
     EXPRESSION-LIST ::= EXPRESSION [ `,' EXPRESSION ] ...
     EXPRESSION ::= ASSIGNMENT-EXPR
     ASSIGNMENT-EXPR ::= CONDITIONAL-EXPR
                         [ ASSIGNMENT-OP ASSIGNMENT-EXPR ]
     ASSIGNMENT-OP ::=  `=' | `+=' | `-=' | `*=' | `/=' | `%=' | `>>='
             | `>>>=' | `<<=' | `&=' | ``|='' | `^='
     CONDITIONAL-EXPR ::= EQUIVALENCE-EXPR
                        [ `?' CONDITIONAL-EXPR `:' CONDITIONAL-EXPR ]
     EQUIVALENCE-EXPR ::= IMPLIES-EXPR
                          [ EQUIVALENCE-OP IMPLIES-EXPR ] ...
     EQUIVALENCE-OP ::= `<==>' | `<=!=>'
     IMPLIES-EXPR ::= LOGICAL-OR-EXPR
                  [ `==>' IMPLIES-NON-BACKWARD-EXPR ]
             | LOGICAL-OR-EXPR `<==' LOGICAL-OR-EXPR
                  [ `<==' LOGICAL-OR-EXPR ] ...
     IMPLIES-NON-BACKWARD-EXPR ::= LOGICAL-OR-EXPR
                  [ `==>' IMPLIES-NON-BACKWARD-EXPR ]
     LOGICAL-OR-EXPR ::= LOGICAL-AND-EXPR [ ``||'' LOGICAL-AND-EXPR ] ...
     LOGICAL-AND-EXPR ::= INCLUSIVE-OR-EXPR [ `&&' INCLUSIVE-OR-EXPR ] ...
     INCLUSIVE-OR-EXPR ::= EXCLUSIVE-OR-EXPR [ ``|'' EXCLUSIVE-OR-EXPR ] ...
     EXCLUSIVE-OR-EXPR ::= AND-EXPR [ `^' AND-EXPR ] ...
     AND-EXPR ::= EQUALITY-EXPR [ `&' EQUALITY-EXPR ] ...
     EQUALITY-EXPR ::= RELATIONAL-EXPR [ `==' RELATIONAL-EXPR] ...
             | RELATIONAL-EXPR [ `!=' RELATIONAL-EXPR] ...
     RELATIONAL-EXPR ::= SHIFT-EXPR `<' SHIFT-EXPR
             | SHIFT-EXPR `>' SHIFT-EXPR
             | SHIFT-EXPR `<=' SHIFT-EXPR
             | SHIFT-EXPR `>=' SHIFT-EXPR
             | SHIFT-EXPR `<:' SHIFT-EXPR
             | SHIFT-EXPR [ `instanceof' TYPE-SPEC ]
     SHIFT-EXPR ::= ADDITIVE-EXPR [ SHIFT-OP ADDITIVE-EXPR ] ...
     SHIFT-OP ::= `<<' | `>>' | `>>>'
     ADDITIVE-EXPR ::= MULT-EXPR [ ADDITIVE-OP MULT-EXPR ] ...
     ADDITIVE-OP ::= `+' | `-'
     MULT-EXPR ::= UNARY-EXPR [ MULT-OP UNARY-EXPR ] ...
     MULT-OP ::= `*' | `/' | `%'
     UNARY-EXPR ::= `(' TYPE-SPEC `)' UNARY-EXPR
             | `++' UNARY-EXPR
             | `--' UNARY-EXPR
             | `+' UNARY-EXPR
             | `-' UNARY-EXPR
             | UNARY-EXPR-NOT-PLUS-MINUS
     UNARY-EXPR-NOT-PLUS-MINUS ::= `~' UNARY-EXPR
             | `!' UNARY-EXPR
             | `(' BUILT-IN-TYPE `)' UNARY-EXPR
             | `(' REFERENCE-TYPE `)' UNARY-EXPR-NOT-PLUS-MINUS
             | POSTFIX-EXPR
     POSTFIX-EXPR ::= PRIMARY-EXPR [ PRIMARY-SUFFIX ] ... [ `++' ]
             | PRIMARY-EXPR [ PRIMARY-SUFFIX ] ... [ `--' ]
             | BUILT-IN-TYPE [ ``['' ``]'' ] ... `.' `class'
     PRIMARY-SUFFIX ::= `.' IDENT
             | `.' `this'
             | `.' `class'
             | `.' NEW-EXPR
             | `.' `super' `(' [ EXPRESSION-LIST ] `)'
             | `(' [ EXPRESSION-LIST ] `)'
             | ``['' EXPRESSION ``]''
             | [ ``['' ``]'' ] ... `.' `class'
     PRIMARY-EXPR ::= IDENT | NEW-EXPR
             | CONSTANT | `super' | `true'
             | `false' | `this' | `null'
             | `(' EXPRESSION `)'
             | JML-PRIMARY
     BUILT-IN-TYPE ::= `void' | `boolean' | `byte'
             | `char' | `short' | `int'
             | `long' | `float' | `double'
     CONSTANT ::= JAVA-LITERAL
     NEW-EXPR ::= `new' TYPE NEW-SUFFIX
     NEW-SUFFIX ::= `(' [ EXPRESSION-LIST ] `)' [ CLASS-BLOCK ]
             | ARRAY-DECL [ ARRAY-INITIALIZER ]
             | SET-COMPREHENSION
     ARRAY-DECL ::= DIM-EXPRS [ DIMS ]
     DIM-EXPRS ::= ``['' EXPRESSION ``]'' [ ``['' EXPRESSION ``]'' ] ...
     ARRAY-INITIALIZER ::= `{' [ INITIALIZER [ `,' INITIALIZER ] ... [ `,' ] ] `}'
     INITIALIZER ::= EXPRESSION
             | ARRAY-INITIALIZER
     JML-PRIMARY ::= RESULT-EXPRESSION
             | OLD-EXPRESSION
             | NOT-ASSIGNED-EXPRESSION
             | NOT-MODIFIED-EXPRESSION
             | ONLY-ACCESSED-EXPRESSION
             | ONLY-ASSIGNED-EXPRESSION
             | ONLY-CALLED-EXPRESSION
             | ONLY-CAPTURED-EXPRESSION
             | FRESH-EXPRESSION
             | REACH-EXPRESSION
             | DURATION-EXPRESSION
             | SPACE-EXPRESSION
             | WORKING-SPACE-EXPRESSION
             | NONNULLELEMENTS-EXPRESSION
             | INFORMAL-DESCRIPTION
             | TYPEOF-EXPRESSION
             | ELEMTYPE-EXPRESSION
             | TYPE-EXPRESSION
             | LOCKSET-EXPRESSION
             | MAX-EXPRESSION
             | IS-INITIALIZED-EXPRESSION
             | INVARIANT-FOR-EXPRESSION
             | LBLNEG-EXPRESSION
             | LBLPOS-EXPRESSION
             | SPEC-QUANTIFIED-EXPR
     RESULT-EXPRESSION ::= `\result'
     OLD-EXPRESSION ::= `\old' `(' SPEC-EXPRESSION [ `,' IDENT ] `)'
             | `\pre' `(' SPEC-EXPRESSION `)'
     NOT-ASSIGNED-EXPRESSION ::= `\not_assigned' `(' STORE-REF-LIST `)'
     NOT-MODIFIED-EXPRESSION ::= `\not_modified' `(' STORE-REF-LIST `)'
     ONLY-ACCESSED-EXPRESSION ::= `\only_accessed' `(' STORE-REF-LIST `)'
     ONLY-ASSIGNED-EXPRESSION ::= `\only_assigned' `(' STORE-REF-LIST `)'
     ONLY-CALLED-EXPRESSION ::= `\only_called' `(' METHOD-NAME-LIST `)'
     ONLY-CAPTURED-EXPRESSION ::= `\only_captured' `(' STORE-REF-LIST `)'
     FRESH-EXPRESSION ::= `\fresh' `(' SPEC-EXPRESSION-LIST `)'
     REACH-EXPRESSION ::= `\reach' `(' SPEC-EXPRESSION `)'
     DURATION-EXPRESSION ::= `\duration' `(' EXPRESSION `)'
     SPACE-EXPRESSION ::= `\space' `(' SPEC-EXPRESSION `)'
     WORKING-SPACE-EXPRESSION ::= `\working_space' `(' EXPRESSION `)'
     NONNULLELEMENTS-EXPRESSION ::= `\nonnullelements' `(' SPEC-EXPRESSION `)'
     TYPEOF-EXPRESSION ::= `\typeof' `(' SPEC-EXPRESSION `)'
     ELEMTYPE-EXPRESSION ::= `\elemtype' `(' SPEC-EXPRESSION `)'
     TYPE-EXPRESSION ::= `\type' `(' TYPE `)'
     LOCKSET-EXPRESSION ::= `\lockset'
     MAX-EXPRESSION ::= `\max' `(' SPEC-EXPRESSION `)'
     IS-INITIALIZED-EXPRESSION ::= `\is_initialized' `(' REFERENCE-TYPE `)'
     INVARIANT-FOR-EXPRESSION ::= `\invariant_for' `(' SPEC-EXPRESSION `)'
     LBLNEG-EXPRESSION ::= `(' `\lblneg' IDENT SPEC-EXPRESSION `)'
     LBLPOS-EXPRESSION ::= `(' `\lblpos' IDENT SPEC-EXPRESSION `)'
     SPEC-QUANTIFIED-EXPR ::= `(' QUANTIFIER QUANTIFIED-VAR-DECLS `;'
                                [ [ PREDICATE ] `;' ]
                                SPEC-EXPRESSION `)'
     QUANTIFIER ::= `\forall' | `\exists'
             | `\max' | `\min'
             | `\num_of' | `\product' | `\sum'
     QUANTIFIED-VAR-DECLS ::= [ BOUND-VAR-MODIFIERS ] TYPE-SPEC QUANTIFIED-VAR-DECLARATOR
                              [ `,' QUANTIFIED-VAR-DECLARATOR ] ...
     QUANTIFIED-VAR-DECLARATOR ::= IDENT [ DIMS ]
     SPEC-VARIABLE-DECLARATORS ::= SPEC-VARIABLE-DECLARATOR
                               [ `,' SPEC-VARIABLE-DECLARATOR ] ...
     SPEC-VARIABLE-DECLARATOR ::= IDENT [ DIMS ]
                                  [ `=' SPEC-INITIALIZER ]
     SPEC-ARRAY-INITIALIZER ::= `{' [ SPEC-INITIALIZER
                  [ `,' SPEC-INITIALIZER ] ... [ `,' ] ] `}'
     SPEC-INITIALIZER ::= SPEC-EXPRESSION
             | SPEC-ARRAY-INITIALIZER
     BOUND-VAR-MODIFIERS ::= `non_null' | `nullable'
     SET-COMPREHENSION ::= `{' [ BOUND-VAR-MODIFIERS ] TYPE-SPEC
                 QUANTIFIED-VAR-DECLARATOR ``|''
                 POSTFIX-EXPR `&&' PREDICATE `}'
     STORE-REF-LIST ::= STORE-REF-KEYWORD | STORE-REF [ `,' STORE-REF ] ...
     STORE-REF ::= STORE-REF-EXPRESSION
             | INFORMAL-DESCRIPTION
     STORE-REF-EXPRESSION ::= STORE-REF-NAME [ STORE-REF-NAME-SUFFIX ] ...
     STORE-REF-NAME ::= IDENT | `super' | `this'
     STORE-REF-NAME-SUFFIX ::= `.' IDENT | `.' `this' | ``['' SPEC-ARRAY-REF-EXPR ``]'' | `.' `*'
     SPEC-ARRAY-REF-EXPR ::= SPEC-EXPRESSION
             | SPEC-EXPRESSION `..' SPEC-EXPRESSION
             | `*'
     STORE-REF-KEYWORD ::= `\nothing' | `\everything' | `\not_specified'

A.9 Statements and Annotation Statements
========================================


     COMPOUND-STATEMENT ::= `{' STATEMENT [ STATEMENT ] ... `}'
     STATEMENT ::= COMPOUND-STATEMENT
             | LOCAL-DECLARATION `;'
             | IDENT `:' STATEMENT
             | EXPRESSION `;'
             | `if' `(' EXPRESSION `)'
               STATEMENT [ `else' STATEMENT ]
             | POSSIBLY-ANNOTATED-LOOP
             | `break' [ IDENT ] `;'
             | `continue' [ IDENT ] `;'
             | `return' [ EXPRESSION ] `;'
             | SWITCH-STATEMENT
             | TRY-BLOCK
             | `throw' EXPRESSION `;'
             | `synchronized' `(' EXPRESSION `)' STATEMENT
             | `;'
             | JML-ANNOTATION-STATEMENT
             | ASSERT-STATEMENT
             | JML-ANNOTATION-STATEMENT
             | MODEL-PROG-STATEMENT // only allowed in model programs
     SWITCH-STATEMENT ::= `switch' `(' EXPRESSION `)' `{'
                          [ SWITCH-BODY ] ... `}'
     SWITCH-BODY ::= SWITCH-LABEL-SEQ [ STATEMENT ] ...
     SWITCH-LABEL-SEQ ::= SWITCH-LABEL [ SWITCH-LABEL ] ...
     SWITCH-LABEL ::= `case' EXPRESSION `:' | `default' `:'
     TRY-BLOCK ::= `try' COMPOUND-STATEMENT
                   [ HANDLER ] ...
                   [ `finally' COMPOUND-STATEMENT ]
     HANDLER ::= `catch' `(' PARAM-DECLARATION `)' COMPOUND-STATEMENT
     LOCAL-DECLARATION ::= LOCAL-MODIFIERS VARIABLE-DECLS
     LOCAL-MODIFIERS ::= [ LOCAL-MODIFIER ] ...
     LOCAL-MODIFIER ::= `ghost' | `final'  `uninitialized' | `non_null' | `nullable'
              | OWNERSHIP-MODIFIER  // when the Universe type system is on
     POSSIBLY-ANNOTATED-LOOP ::=
               [ LOOP-INVARIANT ] ...
               [ VARIANT-FUNCTION ] ...
               [ IDENT `:' ] LOOP-STMT
     LOOP-STMT ::= `while' `(' EXPRESSION `)' STATEMENT
             | `do' STATEMENT `while' `(' EXPRESSION `)' `;'
             | `for' `(' [ FOR-INIT ] `;' [ EXPRESSION ] `;' [ EXPRESSION-LIST ] `)'
                  STATEMENT
     FOR-INIT ::= LOCAL-DECLARATION | EXPRESSION-LIST
     LOOP-INVARIANT ::= MAINTAINING-KEYWORD PREDICATE `;'
     MAINTAINING-KEYWORD ::= `maintaining' | `maintaining_redundantly'
             | `loop_invariant' | `loop_invariant_redundantly'
     VARIANT-FUNCTION ::= DECREASING-KEYWORD SPEC-EXPRESSION `;'
     DECREASING-KEYWORD ::= `decreasing' | `decreasing_redundantly'
             | `decreases' | `decreases_redundantly'
     ASSERT-STATEMENT ::= `assert' EXPRESSION [ `:' EXPRESSION ] `;'
             | `assert' PREDICATE [ `:' EXPRESSION ] `;'
     ASSERT-REDUNDANTLY-STATEMENT ::= `assert_redundantly' PREDICATE
                                      [ `:' EXPRESSION ] `;'
     JML-ANNOTATION-STATEMENT ::= ASSERT-REDUNDANTLY-STATEMENT
             | ASSUME-STATEMENT
             | HENCE-BY-STATEMENT
             | SET-STATEMENT
             | REFINING-STATEMENT
             | UNREACHABLE-STATEMENT
             | DEBUG-STATEMENT
     ASSUME-STATEMENT ::= ASSUME-KEYWORD PREDICATE
                          [ `:' EXPRESSION ] `;'
     ASSUME-KEYWORD ::= `assume' | `assume_redundantly'
     SET-STATEMENT ::= `set' ASSIGNMENT-EXPR `;'
     REFINING-STATEMENT ::= `refining' SPEC-STATEMENT STATEMENT
             | `refining' GENERIC-SPEC-STATEMENT-CASE STATEMENT
     UNREACHABLE-STATEMENT ::= `unreachable' `;'
     DEBUG-STATEMENT ::= `debug' EXPRESSION `;'
     HENCE-BY-STATEMENT ::= HENCE-BY-KEYWORD PREDICATE `;'
     HENCE-BY-KEYWORD ::= `hence_by' | `hence_by_redundantly'

A.10 Redundancy
===============


     REDUNDANT-SPEC ::= IMPLICATIONS [ EXAMPLES ] | EXAMPLES
     IMPLICATIONS ::= `implies_that' SPEC-CASE-SEQ
     EXAMPLES ::= `for_example' EXAMPLE [ `also' EXAMPLE ] ...
     EXAMPLE ::= [ [ PRIVACY ] `example' ]
                 [ SPEC-VAR-DECLS ]
                 [ SPEC-HEADER ]
                 SIMPLE-SPEC-BODY
             | [ PRIVACY ] `exceptional_example'
               [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ EXCEPTIONAL-EXAMPLE-BODY ]
             | [ PRIVACY ] `exceptional_example'
               [ SPEC-VAR-DECLS ]
               EXCEPTIONAL-EXAMPLE-BODY
             | [ PRIVACY ] `normal_example'
               [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ NORMAL-EXAMPLE-BODY ]
             | [ PRIVACY ] `normal_example'
               [ SPEC-VAR-DECLS ]
               NORMAL-EXAMPLE-BODY
     EXCEPTIONAL-EXAMPLE-BODY ::= EXCEPTIONAL-SPEC-CLAUSE
                                  [ EXCEPTIONAL-SPEC-CLAUSE ] ...
     NORMAL-EXAMPLE-BODY ::= NORMAL-SPEC-CLAUSE
                             [ NORMAL-SPEC-CLAUSE ] ...

A.11 Model Programs
===================


     MODEL-PROGRAM ::= [ PRIVACY ] [ `code' ] `model_program'
                       JML-COMPOUND-STATEMENT
     JML-COMPOUND-STATEMENT ::= COMPOUND-STATEMENT
     JML-STATEMENT ::= STATEMENT
     MODEL-PROG-STATEMENT ::= NONDETERMINISTIC-CHOICE
             | NONDETERMINISTIC-IF
             | SPEC-STATEMENT
             | INVARIANT
     NONDETERMINISTIC-CHOICE ::= `choose' ALTERNATIVE-STATEMENTS
     ALTERNATIVE-STATEMENTS ::= JML-COMPOUND-STATEMENT
                  [ `or' JML-COMPOUND-STATEMENT ] ...
     NONDETERMINISTIC-IF ::= `choose_if' GUARDED-STATEMENTS
                  [ `else' JML-COMPOUND-STATEMENT ]
     GUARDED-STATEMENTS ::= GUARDED-STATEMENT
                  [ `or' GUARDED-STATEMENT ] ...
     GUARDED-STATEMENT ::= `{'
                  ASSUME-STATEMENT
                  JML-STATEMENT [ JML-STATEMENT] ... `}'
     SPEC-STATEMENT ::= [ PRIVACY ] BEHAVIOR-KEYWORD
                        GENERIC-SPEC-STATEMENT-CASE
             | [ PRIVACY ] EXCEPTIONAL-BEHAVIOR-KEYWORD
               EXCEPTIONAL-SPEC-CASE
             | [ PRIVACY ] NORMAL-BEHAVIOR-KEYWORD
               NORMAL-SPEC-CASE
             | [ PRIVACY ] ABRUPT-BEHAVIOR-KEYWORD
               ABRUPT-SPEC-CASE
     GENERIC-SPEC-STATEMENT-CASE ::= [ SPEC-VAR-DECLS ]
                                     GENERIC-SPEC-STATEMENT-BODY
             | [ SPEC-VAR-DECLS ]
               SPEC-HEADER
               [ GENERIC-SPEC-STATEMENT-BODY ]
     GENERIC-SPEC-STATEMENT-BODY ::= SIMPLE-SPEC-STATEMENT-BODY
             | `{|' GENERIC-SPEC-STATEMENT-CASE-SEQ `|}'
     GENERIC-SPEC-STATEMENT-BODY-SEQ ::= GENERIC-SPEC-STATEMENT-CASE
                  [ `also' GENERIC-SPEC-STATEMENT-CASE ] ...
     SIMPLE-SPEC-STATEMENT-BODY ::= SIMPLE-SPEC-STATEMENT-CLAUSE
                                    [ SIMPLE-SPEC-STATEMENT-CLAUSE ] ...
     SIMPLE-SPEC-STATEMENT-CLAUSE ::= DIVERGES-CLAUSE
             | ASSIGNABLE-CLAUSE
             | WHEN-CLAUSE | WORKING-SPACE-CLAUSE | DURATION-CLAUSE
             | ENSURES-CLAUSE | SIGNALS-ONLY-CLAUSE | SIGNALS-CLAUSE
             | CONTINUES-CLAUSE | BREAKS-CLAUSE | RETURNS-CLAUSE
     ABRUPT-BEHAVIOR-KEYWORD ::= `abrupt_behavior' | `abrupt_behaviour'
     ABRUPT-SPEC-CASE ::= GENERIC-SPEC-STATEMENT-CASE
     CONTINUES-CLAUSE ::= CONTINUES-KEYWORD [ TARGET-LABEL ]
                          [ PRED-OR-NOT ] `;'
     CONTINUES-KEYWORD ::= `continues' | `continues_redundantly'
     TARGET-LABEL ::= `->' `(' IDENT `)'
     BREAKS-CLAUSE ::= BREAKS-KEYWORD [ TARGET-LABEL ]
                       [ PRED-OR-NOT ] `;'
     BREAKS-KEYWORD ::= `breaks' | `breaks_redundantly'
     RETURNS-CLAUSE ::= RETURNS-KEYWORD [ PRED-OR-NOT ] `;'
     RETURNS-KEYWORD ::= `returns' | `returns_redundantly'

A.12 Specification for Subtypes
===============================


A.13 Refinement
===============


     REFINE-PREFIX ::= REFINE-KEYWORD STRING-LITERAL `;'
     REFINE-KEYWORD ::= `refine' | `refines'

A.14 MultiJava Extensions to JML
================================


     MULTIJAVA-TOP-LEVEL-DECLARATION ::= MULTIJAVA-TOP-LEVEL-METHOD
     MULTIJAVA-TOP-LEVEL-METHOD ::= [ METHOD-SPECIFICATION ]
                   MODIFIERS [ `method' ]
                   [ TYPE-SPEC ] EXTENDING-METHOD-HEAD METHOD-BODY
     EXTENDING-METHOD-HEAD ::= NAME `.' `ident' FORMALS [DIMS ]
                               [ THROWS-CLAUSE ]
     MULTIJAVA-PARAM-DECLARATION ::= [ PARAM-MODIFIER ] ...
                      TYPE-SPEC SPECIALIZER IDENT [ DIMS ]
     SPECIALIZER ::= `@' TYPE-SPEC
             | `@@' VALUE-SPECIALIZER
     VALUE-SPECIALIZER ::= EXPRESSION

A.15 Universe Type System
=========================


     OWNERSHIP-MODIFIERS ::= OWNERSHIP-MODIFIER [ OWNERSHIP-MODIFIER ]
     OWNERSHIP-MODIFIER ::= `\rep' | `\peer' | `\readonly'
              | RESERVED-OWNERSHIP-MODIFIER // with -universesx parse or -universesx full
     RESERVED-OWNERSHIP-MODIFIER ::= `rep' | `peer' | `readonly'

A.16 Safe Math Extensions
=========================


A.17 Deprecated and Replaced Syntax
===================================



File: jmlrefman.info,  Node: Modifier Summary,  Next: Type Checking Summary,  Prev: Grammar Summary,  Up: Top

Appendix B Modifier Summary
***************************

This table summarizes which Java and JML modifiers may be used in
various grammatical contexts.

Grammatical construct         Java modifiers             JML modifiers
All modifiers                 `public protected          `spec_public
                              private abstract           spec_protected model
                              static final               ghost pure instance
                              synchronized               helper non_null
                              transient volatile         nullable
                              native strictfp'           nullable_by_default
                                                         monitored
                                                         uninitialized'

Class declaration             `public final              `pure model
                              abstract strictfp'         nullable_by_default
                                                         spec_public
                                                         spec_protected'

Interface declaration         `public strictfp'          `pure model
                                                         nullable_by_default
                                                         spec_public
                                                         spec_protected'

Nested Class declaration      `public protected          `spec_public
                              private static final       spec_protected model
                              abstract strictfp'         pure'

Nested interface              `public protected          `spec_public
declaration                   private static             spec_protected model
                              strictfp'                  pure'

Local Class (and local        `final abstract            `pure model'
model class) declaration      strictfp'                  

Type specification            `public protected          `instance'
(e.g. invariant)              private static'            

Field declaration             `public protected          `spec_public
                              private final              spec_protected
                              volatile transient         non_null nullable
                              static'                    instance monitored'

Ghost Field declaration       `public protected          `non_null nullable
                              private static final'      instance monitored'

Model Field declaration       `public protected          `non_null nullable
                              private static'            instance'

Method declaration in a       `public protected          `spec_public
class                         private abstract           spec_protected pure
                              final static               non_null nullable
                              synchronized native        helper extract'
                              strictfp'                  

Method declaration in         `public abstract'          `spec_public
an interface                                             spec_protected pure
                                                         non_null nullable
                                                         helper'

Constructor declaration       `public protected          `spec_public
                              private'                   spec_protected helper
                                                         pure extract'

Model method (in a            `public protected          `pure non_null
class or interface)           private abstract           nullable helper
                              static final               extract'
                              synchronized               
                              strictfp'                  

Model constructor             `public protected          `pure helper extract'
                              private'                   

Java initialization           `static'                   -
block                                                    
JML initializer and           -                          -
static_initializer                                       
annotation                                               

Formal parameter              `final'                    `non_null nullable'

Local variable and            `final'                    `ghost non_null
local ghost variable                                     nullable
declaration                                              uninitialized'

   Note that within interfaces, fields are implicitly public, static and
final [Gosling-etal00].  In an interface, ghost and model fields are
implicitly public and static, though they may be declared as `instance'
fields, which makes them not static.

   Also within an interface, methods may not be static and are
implicitly abstract.  Model methods in interfaces, however, are not
implicitly abstract and may be declared static.


File: jmlrefman.info,  Node: Type Checking Summary,  Next: Verification Logic Summary,  Prev: Modifier Summary,  Up: Top

Appendix C Type Checking Summary
********************************

[[[Hope to generate this automatically]]]


File: jmlrefman.info,  Node: Verification Logic Summary,  Next: Differences,  Prev: Type Checking Summary,  Up: Top

Appendix D Verification Logic Summary
*************************************

[[[Hope to generate this automatically]]]


File: jmlrefman.info,  Node: Differences,  Next: Bibliography,  Prev: Verification Logic Summary,  Up: Top

Appendix E Differences
**********************

The subsections below detail the differences between the JML Common
Tools release of JML and other tools and between JML and Java itself.

* Menu:

* Differences Between JML and Other Tools::
* Differences Between JML and Java::


File: jmlrefman.info,  Node: Differences Between JML and Other Tools,  Next: Differences Between JML and Java,  Prev: Differences,  Up: Differences

E.1 Differences Between JML and Other Tools
===========================================

ESC/Java [Leino-Nelson-Saxe00] and JML share a common syntax; this is
even more true of ESC/Java2 and JML.  The initial efforts to merge
syntaxes were due to the efforts of Raymie Stata.  After a long
process, the syntax of ESC/Java and JML were both changed and JML was
nearly a superset of ESC/Java when work on ESC/Java stopped with
ESC/Java 1.2.4. Following the open-source release of ESC/Java, Kiniry
and Cok began work on ESC/Java2, which is now very compatible with
JML's syntax [Kiniry-Cok04].  Users can thus use both tools with little
or no changes to their files.

   Similarly the Daikon tool [Ernst-etal01] also uses a variant of JML's
syntax, as do several other tools [Burdy-etal03].  While efforts are
ongoing to avoid differences, some differences are unavoidable, as
research is ongoing (and people have other things to do).

   We discuss the differences between the JML language described in this
manual and the variants used in these other tools below.

* Menu:

* Differences Between JML and ESC/Java2::


File: jmlrefman.info,  Node: Differences Between JML and ESC/Java2,  Prev: Differences Between JML and Other Tools,  Up: Differences Between JML and Other Tools

E.1.1 Differences Between JML and ESC/Java2
-------------------------------------------

This section discusses the current state of affairs of ESC/Java2
compatibility with JML's syntax.

   The following differences remain between ESC/Java2 and JML.

   * ESC/Java2 is tolerant (with a suppressible warning) of missing
     semicolons at the ends of annotations, in many circumstances.

   * ESC/Java2 does not enforce the visibility modifiers.

   * ESC/Java2 strictly requires whole syntactic constructs within a
     single annotation comment; JML tools are more lenient.

   * JML and ESC/Java2 differ in the search order for refinement files
     in the classpath.

   * JML and ESC/Java2 differ in where `helper' annotations are
     permitted.

   * JML does not support model classes (at least in runtime assertion
     checking).

   * ESC/Java2 reads but ignores model programs.


   The following differences between ESC/Java2 and JML are designed to
remain differences.  While the plan is for ESC/Java2 to parse all of
JML's syntax, there are times when one needs to write annotations for
one of these tool that are not understood by the other.  Thus these
differences are intended to allow users of both tools to write such
annotations.

   * JML supports annotation forms `//+@' and `/*+@' ... `@+*/', so
     that annotations that JML understands but ESC/Java doesn't can be
     written.

   * ESC/Java2 supports annotation forms `//-@' and `/*-@' ... `@-*/',
     so that annotations that ESC/Java2 understands but JML doesn't can
     be written.



File: jmlrefman.info,  Node: Differences Between JML and Java,  Prev: Differences Between JML and Other Tools,  Up: Differences

E.2 Differences Between JML and Java
====================================

This section describes differences between JML and Java without JML.
Currently the major differences are the way that JML treats `null'.

* Menu:

* Non-null by Default::


File: jmlrefman.info,  Node: Non-null by Default,  Prev: Differences Between JML and Java,  Up: Differences Between JML and Java

E.2.1 Non-null by Default
-------------------------

As described earlier (*note Null is Not the Default::), JML does not,
by default, allow `null' to be a value in a field, formal parameter,
method or a bound variable (*note Modifiers for Bound Variables::).  To
allow `null' as a value, one has to use the `nullable' modifier on the
declaration, or the `nullable_by_default' modifier on the type where
the declaration occurs *Note Nullity Modifiers::, for more details.

Appendix F What's Missing
*************************

What is missing from this reference manual?

   The following constructs are not discussed at all:
   * `abrupt_behavior'

   * `breaks' and `breaks_redundantly'

   * `choose' and `choose_if'

   * `continues' and `continues_redundantly'

   * `example' and `exceptional_example'

   * `implies_that'

   * `hence_by' and `hence_by_redundantly'

   * `model_program'

   * `returns' and `returns_redundantly'

   * `weakly' xxx

   Other stuff not to forget - DRCok
   * \not_specified

   * \nothing

   * \everything

   * nowarn annotation

   * methods and constructors without bodies in java files

   * methods and constructors with bodies in specification files

   * methods and constructors in annotation expressions - purity -
     modifies clauses - various checking

   * anonymous and block-level classes

   * field, method, constructor keywords

   * exceptions in annotation expressions


File: jmlrefman.info,  Node: Bibliography,  Next: Example Index,  Prev: Differences,  Up: Top

Bibliography
************

[America87]
     Pierre America.  Inheritance and Subtyping in a Parallel
     Object-Oriented Language.  In Jean Bezivin and others (eds.),
     `ECOOP '87, European Conference on Object-Oriented Programming,
     Paris, France'.  Lecture Notes in Computer Science, Vol. 276
     (Springer-Verlag, NY), pages 234-242.

[Arnold-Gosling-Holmes00]
     Ken Arnold, James Gosling, and David Holmes.  `The Java
     Programming Language Third Edition'.  The Java Series.
     Addison-Wesley, Reading, MA, 2000.

[ANSI95]
     `Working Paper for Draft Proposed International Standard for
     Information Systems -- Programming Language C++'.  CBEMA, 1250 Eye
     Street NW, Suite 200, Washington DC 20005, April 28, 1995.
     (Obtained by anonymous ftp to research.att.com, directory
     dist/c++std/WP.)

[Back88]
     R. J. R. Back.  A calculus of refinements for program derivations.
     `Acta Informatica', 25(6):593-624, August 1988.

[Back-vonWright89a]
     R. J. R. Back and J. von Wright.  Refinement Calculus, Part I:
     Sequential Nondeterministic Programs.  In J. W. de Bakker, et al,
     (eds.), `Stepwise Refinement of Distributed Systems, Models,
     Formalisms, Correctness, REX Workshop', Mook, The Netherlands,
     May/June 1989, pages 42-66.  Volume 430 of `Lecture Notes Computer
     Science', Spring-Verlag, 1989.

[Back-vonWright98]
     Ralph-Johan Back and Joakim von Wright.  `Refinement Calculus: A
     Systematic Introduction'.  Springer-Verlag, 1998.

[Borgida-etal95]
     Alex Borgida, John Mylopoulos, and Raymond Reiter.  On the Frame
     Problem in Procedure Specifications.  `IEEE Transactions on
     Software Engineering', 21(10):785-798, October 1995.

[Boyland00]
     John Boyland.  Alias burying: Unique variables without destructive
     reads.  `Software--Practice and Experience', 31(6):533-553, May
     2001.

[Buechi-Weck00]
     Martin Bu"chi and Wolfgang Weck.  The Greybox Approach: When
     Blackbox Specifications Hide Too Much.  Technical Report 297,
     Turku Centre for Computer Science, August 1999.
     `http://www.tucs.abo.fi/publications/techreports/TR297.html'.

[Buechi00]
     Martin Bu"chi.  Safe Language Mechanisms for Modularization and
     Concurrency.  Ph.D. Thesis, Turku Center for Computer Science, May
     2000.  TUCS Dissertations No. 28.

[Burdy-etal03]
     Lilian Burdy,  Yoonsik Cheon,  David Cok, Michael Ernst,  Joe
     Kiniry,  Gary T. Leavens, K. Rustan M. Leino, and Erik Poll.  An
     overview of JML tools and applications.  Dept. of Computer
     Science, University of Nijmegen, TR NIII-R0309, 2003.
     `http://www.eecs.ucf.edu/~leavens/JML/OldReleases/jml-white-paper.pdf'.

[Chalin07]
     Patrice Chalin.  A Sound Assertion Semantics for the Dependable
     Systems Evolution Verifying Compiler.  `Proceedings of the
     International Conference on Software Engineering (ICSE)',
     Minneapolis, MN, USA, 2007.

[Chalin-Rioux05]
     Patrice Chalin and Frederic Rioux.  Non-null References by Default
     in the Java Modeling Language.  In Proceedings of the Workshop on
     the Specification and Verification of Component-Based Systems
     (SAVCBS'05), Lisbon, Portugal.  September, 2005.  An updated
     version is available as Department of Computer Science, Concordia
     University, ENCS-CSE TR 2005-004, December 2005, which is
     available from the URL
     `http://www.cs.concordia.ca/~chalin/papers/TR-2005-004-r3.2.pdf'.

[Cheon-Leavens02]
     Yoonsik Cheon and Gary T. Leavens.  A Simple and Practical
     Approach to Unit Testing: The JML and JUnit Way.  In `ECOOP 2002 -
     Object-Oriented Programming, 16th European Conference, Malaga,
     Spain', pages 231-255.  Springer-Verlag, June 2002.  Also
     Department of Computer Science, Iowa State University, TR #01-12a,
     November 2001, revised March 2002, which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR01-12/TR.pdf'.

[Cheon-Leavens02b]
     Yoonsik Cheon and Gary T. Leavens.  A Runtime Assertion Checker
     for the Java Modeling Language (JML).  In Hamid R. Arabnia and
     Youngsong Mun (eds.), `Proceedings of the International Conference
     on Software Engineering Research and Practice (SERP '02), Las
     Vegas, Nevada, USA', pages 322-328.  CSREA Press, June 2002.  Also
     Department of Computer Science, Iowa State University, TR #02-05,
     March 2002, which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR02-05/TR.pdf'.

[Cheon-etal05]
     Yoonsik Cheon, Gary T. Leavens, Murali Sitaraman, and Stephen
     Edwards.  Model Variables: Cleanly Supporting Abstraction in
     Design By Contract.  `Software--Practice and Experience',
     35(6):583-599, May 2005.  Also Department of Computer Science,
     Iowa State University, TR 03-10, March 2003.
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR03-10/TR.pdf'.

[Cheon03]
     Yoonsik Cheon.  A Runtime Assertion Checker for the Java Modeling
     Language.  Department of Computer Science, Iowa State University,
     TR 03-09, April, 2003.
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR03-09/TR.pdf'

[Clifton-etal00]
     Curtis Clifton, Gary T. Leavens, Craig Chambers, and Todd
     Millstein.  MultiJava: Modular Open Classes and Symmetric Multiple
     Dispatch for Java.  In `OOPSLA 2000 Conference on Object-Oriented
     Programming,          Systems, Languages, and Applications,
     Minneapolis, Minnesota' (`ACM SIGPLAN Notices', 35(10):130-145,
     October 2000).

[Cohen90]
     Edward Cohen.  `Programming in the 1990s: An Introduction to the
     Calculation of Programs'.  Springer-Verlag, New York, N.Y., 1990.

[Corbett-etal00]
     James C. Corbett, Matthew B. Dwyer, John Hatcliff, Shawn Laubach,
     Corina S. Pasareanu, Robby, and Hongjun Zheng.  Bandera:
     Extracting Finite-State Models from Java Source Code.  In S.
     Brookes and M. Main and A. Melton and M. Mislove (eds.),
     `Proceedings of the 22nd International Conference on
       Software Engineering', pp. 439-448, ACM Press, 2000.

[Dhara-Leavens94b]
     Krishna Kishore Dhara and Gary T. Leavens.  Weak Behavioral
     Subtyping for Types with Mutable Objects.  In S. Brookes and M.
     Main and A. Melton and M. Mislove (eds.), `Mathematical
     Foundations of Programming Semantics, Eleventh Annual Conference',
     Volume 1 of `Electronic Notes in Computer Science', Elsevier, 1995.
     `http://www.sciencedirect.com/science/journal/15710661'.

[Dhara-Leavens96]
     Krishna Kishore Dhara and Gary T. Leavens.  Forcing Behavioral
     Subtyping Through Specification Inheritance.  In `Proceedings 18th
     International Conference on Software Engineering', Berlin,
     Germany, pages 258-267.  IEEE 1996.  An extended version is
     Department of Computer Science, Iowa State University, TR #95-20b,
     December 1995, which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR95-20/TR.ps.Z'.

[Dhara97]
     Krishna Kishore Dhara.  Behavioral Subtyping in Object-Oriented
     Languages.  Ph.D. Thesis, Department of Computer Science, Iowa
     State University.  Also Technical Report TR #97-09, May 1997.
     Available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR97-09/TR.ps.gz'.

[Dietl-Drossopoulou-Mueller07]
     Werner Dietl, Sophia Drossopoulou and Peter Mu"ller.  Generic
     Universe Types.  In E. Ernst, editor, `European Conference on
     Object-Oriented Programming (ECOOP)' pages 28-53, 2007.  Available
     from
     `http://sct.inf.ethz.ch/publications/getpdf.php?bibname=Own&id=DietlDrossopoulouMueller07a.pdf'.

[Dietl-Mueller04]
     Werner Dietl and Peter Mu"ller.  Exceptions in ownership type
     systems.  In E. Poll, editor, `Formal Techniques for Java-like
     Programs' pages 49-54, 2004.  Available from
     `http://sct.inf.ethz.ch/publications/getpdf.php?bibname=Own&id=DietlMueller04.pdf'.

[Dietl-Mueller05]
     Werner Dietl and Peter Mu"ller.  Universes: Lightweight Ownership
     for JML.  `Journal of Object Technology', 4(8):5-32, October 2005.
     Available from
     `http://www.jot.fm/issues/issue_2005_10/article1.pdf'.

[Dietl-Mueller-Schregenberger08]
     Werner Dietl, Peter Mu"ller and Daniel Schregenberger.  Universe
     Type System -- Quick-Reference.  Available from
     `http://sct.inf.ethz.ch/research/universes/tools/juts-quickref.pdf'.

[Dijkstra76]
     Edsger W. Dijkstra.  `A Discipline of Programming' (Prentice-Hall,
     Englewood Cliffs, N.J., 1976).

[Edwards-etal94]
     Stephen H. Edwards, Wayne D. Heym, Timothy J. Long, Murali
     Sitaraman, and Bruce W. Weide.  Part II: Specifying Components in
     RESOLVE.  `ACM SIGSOFT Software Engineering Notes', 19(4):29-39,
     October 1994.

[Ernst-etal01]
     Michael D. Ernst, Jake Cockrell, William G. Griswold, and David
     Notkin.  Dynamically discovering likely program invariants to
     support program evolution.  `IEEE Transactions on Software
     Engineering', 27(2):1-25, February 2001.

[Fitzgerald-Larsen98]
     John Fitzgerald and Peter Gorm Larsen.  `Modelling Systems:
     Practical Tools and Techniques in Software Development'.
     Cambridge University Press, Cambridge, UK, 1998.

[Gosling-etal00]
     James Gosling, Bill Joy, Guy Steele, and Gilad Bracha.  `The Java
     Language Specification Second Edition'.  The Java Series.
     Addison-Wesley, Boston, MA, 2000.

[Gries-Schneider95]
     David Gries and Fred B. Schneider.  Avoiding the Undefined by
     Underspecification.  In Jan van Leeuwen, editor, `Computer Science
     Today: Recent Trends and Developments', volume 1000 of `Lecture
     Notes in Computer Science', pages 366-373.  Springer-Verlag, New
     York, N.Y., 1995.

[Guttag-Horning-Wing85b]
     John V. Guttag and James J. Horning and Jeannette M. Wing.  The
     Larch Family of Specification Languages.  `IEEE Software',
     2(5):24-36, September 1985.

[Guttag-Horning93]
     John V. Guttag and James J. Horning with S.J. Garland, K.D. Jones,
     A. Modet and J.M. Wing.  `Larch: Languages and Tools for Formal
     Specification' (Springer-Verlag, NY, 1993).

[Hall90]
     Anthony Hall.  Seven Myths of Formal Methods.  `IEEE Software',
     7(5):11-19, September 1990.

[Hayes93]
     I. Hayes (ed.), `Specification Case Studies', second edition
     (Prentice-Hall, Englewood Cliffs, N.J., 1990).

[Hesselink92]
     Wim H. Hesselink.  `Programs, Recursion, and Unbounded Choice'
     (Cambridge University Press, Cambridge, UK, 1992).

[Hoare69]
     C. A. R. Hoare.  An Axiomatic Basis for Computer Programming.
     `Comm. ACM', 12(10):576-583, October 1969.

[Hoare72a]
     C. A. R. Hoare.  Proof of correctness of data representations.
     `Acta Informatica', 1(4):271-281, 1972.

[Huisman01]
     Marieke Huisman.  Reasoning about JAVA programs in higher order
     logic with PVS and Isabelle.  IPA dissertation series, 2001-03.
     Ph.D. dissertation, University of Nijmegen, 2001.

[ISO96]
     International Standards Organization.  `Information Technology -
     Programming Languages, Their Environments and System Software
     Interfaces - Vienna Development Method - Specification Language -
     Part 1: Base language'.  International Standard ISO/IEC 13817-1,
     December, 1996.

[Khurshid-Marinov-Jackson02]
     Sarfraz Khurshid and Darko Marinov and Daniel Jackson.  An
     Analyzable Annotation Language.  In `Proceedings of OOPSLA '02
     Conference on Object-Oriented Programming, Languages, Systems, and
     Applications'.  (`ACM SIGPLAN Notices', 37(11):231-245, October
     2002).

[Jacobs-etal98]
     Bart Jacobs, Joachim van den Berg, Marieke Huisman, Martijn van
     Berkum, Ulrich Hensel, and Hendrik Tews.  Reasoning about Java
     Classes (Preliminary Report) In `OOPSLA '98 Proceedings' (`ACM
     SIGPLAN Notices', 33(10):329-490, October 1998).

[Jones90]
     Cliff B. Jones.  `Systematic Software Development Using VDM'.
     International Series in Computer Science. Prentice Hall, Englewood
      Cliffs, N.J., second edition, 1990.

[Jones95e]
     C.B. Jones, Partial functions and logics: A warning.  `Information
     Processing Letters', 54(2):65-67, 1995.

[Kiczales-Lamping92]
     Gregor Kiczales and John Lamping.  Issues in the Design and
     Documentation of Class Libraries.  In Andreas Paepcke (ed.),
     `OOPSLA '92 Proceedings' (`ACM SIGPLAN Notices', 27(10):435-451,
     October 1992).

[Kiniry-Cok04]
     Joseph R. Kiniry and David R. Cok.  ESC/Java2: Uniting ESC/Java
     and JML: Progress and issues in building and using ESC/Java2 and a
     report on a case study involving the use of ESC/Java2 to verify
     portions of an Internet voting tally system.  In Marieke Huisman
     (ed.), `CASSIS 2004 - Construction and Analysis of Safe, Secure
     and Interoperable Smart devices, Marseille, France, 2004,
     Proceedings', volume 3362 of `Lecture Notes in Computer Science',
     pages 108-128.  Springer-Verlag, 2004.

[Krone-Ogden-Sitaraman03]
     Joan Krone, William F. Ogden, Murali Sitaraman.  Modular
     Verification of Performance Constraints.  Technical Report
     RSRG-03-04, Department of Computer Science, Clemson University,
     May, 2003.  Available from
     `http://www.cs.clemson.edu/~resolve/reports/RSRG-03-04.pdf'

[Lamport89]
     Leslie Lamport.  A Simple Approach to Specifying Concurrent
     Systems.  `CACM', 32(1):32-45, January 1989.

[LeavensLarchFAQ]
     Gary T. Leavens.  Larch frequently asked questions.  Version
     1.110. Available in
     `http://www.eecs.ucf.edu/~leavens/larch-faq.html', May 2000.

[Leavens-Baker99]
     Gary T. Leavens and Albert L. Baker.  Enhancing the pre- and
     postcondition technique for more expressive   specifications.  In
     Jeannette M. Wing, Jim Woodcock, and Jim Davies, editors, `
     FM'99 -- Formal Methods: World Congress on Formal Methods in the
     Development of Computing Systems, Toulouse, France, September 1999,
      Proceedings', volume 1709 of `Lecture Notes in Computer
     Science', pages   1087-1106. Springer-Verlag, 1999.

[Leavens-Baker-Ruby99]
     Gary T. Leavens, Albert L. Baker, and Clyde Ruby.  JML: a Notation
     for Detailed Design.  In Haim Kilov, Bernhard Rumpe, and Ian
     Simmonds (editors), `Behavioral Specifications for Businesses and
     Systems', chapter 12, pages 175-188.

[Leavens-Baker-Ruby06]
     Gary T. Leavens, Albert L. Baker, and Clyde Ruby.  Preliminary
     Design of JML:   A Behavioral Interface Specification Language for
     Java.  `ACM SIGSOFT Software Engineering Notes', 31(3):1-38, March
     2006.
     `http://doi.acm.org/10.1145/1127878.1127884'.  Also Iowa State
     University, Department of Computer Science, TR #98-06-rev29,
     January 2006, which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR98-06/TR.pdf'.

[Leavens-Cheon06]
     Gary T. Leavens and Yoonsik Cheon.  Design by Contract with JML.
     December, 2006, which is available from the URL
     `http://www.jmlspecs.org/jmldbc.pdf'.

[Leavens-Dhara00]
     Gary T. Leavens and Krishna Kishore Dhara.  Concepts of Behavioral
     Subtyping and a Sketch of Their Extension to Component-Based
     Systems.  In Gary T. Leavens and Murali Sitaraman (eds.),
     `Foundations of Component-Based Systems', Cambridge University
     Press, 2000, pp. 113-135.
     `http://www.eecs.ucf.edu/~leavens/FoCBS-book/06-leavens-dhara.pdf'

[Leavens-etal05]
     G. T. Leavens, Y. Cheon, C. Clifton, C. Ruby, and D. R. Cok.  How
     the design of JML accommodates both runtime assertion checking and
     formal verification `Science of Computer Programming',
     55(1-3):185-208, 2005.

[Leavens-Mueller07]
     Gary T. Leavens and Peter Mu"ller.  Information Hiding and
     Visibility in Interface Specifications.  In `International
     Conference on Software Engineering (ICSE)', pages 385-395, IEEE,
     2007.

[Leavens-Naumann06]
     Gary T. Leavens and David A. Naumann.  Behavioral Subtyping,
     Specification Inheritance, and Modular Reasoning.  Department of
     Computer Science, TR \#06-20b, July 2006, revised August,
     September 2006.  Available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR90-09/TR.pdf'.

[Leavens-Weihl90]
     Gary T. Leavens and William E. Weihl.  Reasoning about
     Object-oriented Programs that use Subtypes (extended abstract).
     In N. Meyrowitz (ed.), `OOPSLA ECOOP '90 Proceedings' (`ACM
     SIGPLAN Notices', 25(10):212-223, October 1990).

[Leavens-Weihl95]
     Gary T. Leavens and William E. Weihl.  Specification and
     Verification of Object-Oriented Programs Using Supertype
     Abstraction.  `Acta Informatica', 32(8):705-778, November 1995.

[Leavens-Wing98]
     Gary T. Leavens and Jeannette M. Wing.  Protective interface
     specifications.  `Formal Aspects of Computing', 10(1):590-75,
     January 1998.

[Leavens90]
     Gary T. Leavens.  Modular Verification of Object-Oriented Programs
     with Subtypes.  Department of Computer Science, Iowa State
     University (Ames, Iowa, 50011), TR 90-09, July 1990.  Available
     from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR90-09/TR.ps.Z'.

[Leavens91]
     Gary T. Leavens.  Modular Specification and Verification of
     Object-Oriented Programs.  `IEEE Software', 8(4):72-80, July 1991.

[Leavens96b]
     Gary T. Leavens.  An Overview of Larch/C++: Behavioral
     Specifications for C++ Modules.  In Haim Kilov and William Harvey
     (editors), `Specification of Behavioral Semantics in
     Object-Oriented Information Modeling' (Kluwer Academic Publishers,
     1996), Chapter 8, pages 121-142.  An extended version is
     Department of Computer Science, Iowa State University, TR #96-01c,
     July 1996, which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR96-01/TR.ps.Z'.

[Leavens97c]
     Gary T. Leavens.  `Larch/C++ Reference Manual'.  Version 5.14.
     Available in
     `http://www.eecs.ucf.edu/~leavens/larchc++.html', October 1997.

[Leavens06b]
     Gary T. Leavens.  JML's Rich, Inherited Specifications for
     Behavioral Subtypes.  In Zhiming Liu and He Jifeng (eds),
     `Proceedings, International Conference on Formal Engineering
     Methods (ICFEM'06), Macao, China', pages 2-36.  Volume 4260 of
     `Lecture Notes in Computer Science', Springer-Verlag, 2006.  Also
     Department of Computer Science, Iowa State University, TR \#06-22,
     August 2006.
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR06-22/TR.pdf'

[Ledgard80]
     Henry. F. Ledgard.  A Human Engineered Variant of BNF.  `ACM
     SIGPLAN Notices', 15(10):57-62, October 1980.

[Leino-Nelson-Saxe00]
     K. Rustan M. Leino, Greg Nelson, and James B. Saxe.  ESC/Java
     User's Manual. Technical Note 2000-02, Systems Research Center,
     October, 2000.

[Leino-etal00]
     K. Rustan M. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe,
     and Raymie Stata.  Extended Static Checking. Web page at
     `http://research.compaq.com/SRC/esc/Esc.html'.

[Leino95]
     K. Rustan M. Leino.  Towards Reliable Modular Programs.  PhD
     thesis, California Institute of Technology, January 1995.
     Available from the URL
     `ftp://ftp.cs.caltech.edu/tr/cs-tr-95-03.ps.Z'.

[Leino95b]
     K. Rustan M. Leino.  A myth in the modular specification of
     programs.  KRML 63, November 1995.  Obtained from the author
     (rustan@pa.dec.com).

[Leino98]
     K. Rustan M. Leino.  Data groups: Specifying the modification of
     extended state.  `OOPSLA '98 Conference Proceedings'.  (`ACM
     SIGPLAN Notices', 33(10):144-153, October 1998).

[Lerner91]
     Richard Allen Lerner.  Specifying Objects of Concurrent Systems.
     School of Computer Science, Carnegie Mellon University,
     CMU-CS-91-131, May 1991.  Available from the URL
     `ftp://ftp.cs.cmu.edu/afs/cs.cmu.edu/project/larch/ftp/thesis.ps.Z'.

[Liskov-Guttag86]
     Barbara Liskov and John Guttag.  `Abstraction and Specification in
     Program Development' (MIT Press, Cambridge, Mass., 1986).

[Liskov-Wing93b]
     Barbara Liskov and Jeannette M. Wing.  Specifications and their
     use in defining subtypes.  In Andreas Paepcke, editor, `OOPSLA '93
     Proceedings'.  (`ACM SIGPLAN Notices' 28(10):16-28, October, 1993.)

[Liskov-Wing94]
     Barbara Liskov and Jeannette M. Wing.  A Behavioral Notion of
     Subtyping.  `ACM Transactions on Programming Languages and
     Systems', 16(6):1811-1841, November 1994.

[Meyer92a]
     Bertrand Meyer.  Applying "design by contract".  `Computer',
     25(10):40-51, October 1992.

[Meyer92b]
     Bertrand Meyer.  `Eiffel: The Language'.  Object-Oriented Series.
     Prentice Hall, New York, N.Y., 1992.

[Meyer97]
     Bertrand Meyer.  `Object-oriented Software Construction'.
     Prentice Hall, New York, N.Y., second edition, 1997.

[Morgan-Vickers94]
     Carroll Morgan and Trevor Vickers.  `On the refinement calculus'.
     Springer-Verlag, New York, N.Y., 1994.

[Morgan94]
     Carroll Morgan.  `Programming from Specifications', second edition
     (Prentice-Hall, 1994).

[Morris87]
     Joseph~M. Morris.  A theoretical basis for stepwise refinement and
     the programming   calculus.  `Science of Computer Programming',
     9(3):287-306, December 1987.

[Mueller-Poetzsch-Heffter00]
     Peter Mu"ller and Arnd Poetzsch-Heffter.  Modular Specification
     and Verification Techniques for Object-Oriented Software
     Components.  In Gary T. Leavens and Murali Sitaraman (eds.),
     `Foundations of Component-Based Systems', pages 137-159. Cambridge
     University Press, 2000.

[Mueller-Poetzsch-Heffter00a]
     Peter Mu"ller and Arnd Poetzsch-Heffter.  A Type System for
     Controlling Representation Exposure in Java.  In S. Drossopoulou,
     et al. (eds.), `Formal Techniques for Java Programs', 2000.
     Technical Report 269, Fernuniversita"t Hagen, Available from
     `http://www.informatik.fernuni-hagen.de/pi5/publications.html'

[Mueller-Poetzsch-Heffter01a]
     Peter Mu"ller and Arnd Poetzsch-Heffter.  Universes: A Type System
     for Alias and Dependency Control.  Technical Report 279,
     Fernuniversita"t Hagen, 2001.  Available from
     `http://www.informatik.fernuni-hagen.de/pi5/publications.html'

[Mueller-Poetzsch-Heffter-Leavens03]
     Peter Mu"ller, Arnd Poetzsch-Heffter, and Gary T. Leavens.
     Modular Specification of Frame Properties in JML.  `Concurrency
     and Computation: Practice and Experience', 15(2):117-154, February
     2003.  Also Technical Report TR #02-02, Department of Computer
     Science, Iowa State University, Ames, Iowa, 50011, February 2002.
     Available from
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR02-02/TR.pdf'

[Mueller-Poetzsch-Heffter-Leavens06]
     Peter Mu"ller, Arnd Poetzsch-Heffter, and Gary T. Leavens.
     Modular Invariants for Layered Object Structures.  `Science of
     Computer Programming', 62(3):253-286, October 2006.
     `http://dx.doi.org/10.1016/j.scico.2006.03.001' Also Technical
     Report 424, ETH Zu"rich, October 2003, revised March 2004, March
     2005.  Available from
     `ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/4xx/424.pdf'

[Mueller02]
     Peter Mu"ller.  Modular Specification and Verification of
     Object-Oriented Programs.  Volume 2262 of `Lecture Notes in
     Computer Science', Springer-Verlag, 2002.

[Nelson89]
     Greg Nelson.  A Generalization of Dijkstra's Calculus.  `ACM
     Transactions on Programming Languages and Systems', 11(4):517-561,
     October 1989.

[Noble-Vitek-Potter98]
     James Noble, Jan Vitek, and John Potter.  Flexible Alias
     Protection.  In Eric Jul (ed.), `ECOOP '98 - Object-Oriented
     Programming, 12th European Conference, Brussels, Belgium', pages
     volume 1445 of `Lecture Notes in Computer Science', pages 158-185.
     Springer-Verlag, New York, N.Y., 1998.

[Parnas72]
     D. L. Parnas.  On the Criteria to be Used in Decomposing Systems
     into Modules.  `Comm. ACM', 15(12):1053-1058, December 1972.

[Poetzsch-Heffter97]
     Arnd Poetzsch-Heffter.  Specification and Verification of
     Object-Oriented Programs.  Habilitationsschrift, Technische
     Universitaet Muenchen, 1997.  Available from the URL
     `http://wwweickel.informatik.tu-muenchen.de/persons/poetzsch/habil.ps.gz'.

[Jacobs-Poll01]
     Bart Jacobs and Eric Poll.  A Logic for the Java Modeling Language
     JML.  In `Fundamental Approaches to Software Engineering
     (FASE'2001), Genova, Italy, 2001'.  Volume 2029 of `Lecture Notes
     in Computer Science', Springer-Verlag, 2001.
     `http://www.cs.kun.nl/~erikpoll/publications/jmllogic.html'

[Raghavan-Leavens05]
     Arun D. Raghavan and Gary T. Leavens.  Desugaring JML Method
     Specifications.  Technical Report #00-03a, Department of Computer
     Science, Iowa State   University, Ames, Iowa, 50011, April, 2000,
     revised May 2005.  Available in
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR00-03/TR.ps.gz'.

[Rioux-Chalin07]
     F. Rioux and P. Chalin.  Effective and Efficient Runtime Assertion
     Checking for JML Through Strong Validity.  `Proceedings of the 9th
     Workshop on Formal Techniques for Java-like Programs (FTfJP'07)',
     Berlin, Germany, 2007.

[Rodriguez-etal05]
     Edwin Rodriguez, Matthew B. Dwyer, Cormac Flanagan, John Hatcliff,
     Gary T. Leavens, Robby.  Extending JML for Modular Specification
     and Verification of Multi-Threaded Programs.  In Andrew P. Black
     (ed.), `ECOOP 2005 - Object-Oriented Programming 19th European
     Conference', Glasgow, UK, pages 551-576. Volume 3586 of `Lecture
     Notes in Computer Science', Springer Verlag, July 2005.

[Rosenblum95]
     David S. Rosenblum.  A practical approach to programming with
     assertions.  `IEEE Transactions on Software Engineering',
     21(1):19-31, January 1995.

[Ruby-Leavens00]
     Clyde Ruby and Gary T. Leavens.  Safely Creating Correct
     Subclasses without Seeing Superclass Code.  In `OOPSLA 2000
     Conference on Object-Oriented Programming,   Systems, Languages,
     and Applications, Minneapolis, Minnesota'.  (`ACM SIGPLAN
     Notices', 35(10):208-228, October, 2000.)  Also Technical Report
     #00-05d, Department of Computer Science, Iowa State   University,
     Ames, Iowa, 50011. April 2000, revised April, June, July 2000.
     Available in
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR00-05/TR.ps.gz'.

[Ruby06]
     Clyde Dwain Ruby.  Modular subclass verification: safely creating
     correct subclasses without superclass code.  Ph.D. Thesis,
     Department of Computer Science, Iowa State University.  Also
     Technical Report #06-34, December 2006.  Available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR06-34/TR.pdf'.

[Salcianu-Rinard05]
     Alexandru Salcianu and Martin Rinard.  Purity and Side Effect
     Analysis for Java Programs.  In Proceedings of the 6th
     International Conference on Verification, Model Checking and
     Abstract Interpretation. Paris, France January 2005.  Available in
     `http://www.mit.edu/~salcianu/publications/vmcai05-purity.pdf'

[Shaner-Leavens-Naumann07]
     Steve M. Shaner, Gary T. Leavens, and David A. Naumann.  Modular
     Verification of Higher-Order Methods with Mandatory Calls
     Specified by Model Programs Department of Computer Science, Iowa
     State University, TR #07-04a, March 2007, revised April 2007,
     which is available from the URL
     `ftp://ftp.cs.iastate.edu/pub/techreports/TR07-04/TR.pdf'.

[Spivey92]
     J. Michael Spivey.  `The Z Notation: A Reference Manual', second
     edition, (Prentice-Hall, Englewood Cliffs, N.J., 1992).

[Steyaert-etal96]
     Patrick Steyaert, Carine Lucas, Kim Mens, and Theo D'Hondt.
     Issues in the Design and Documentation of Class Libraries.  In
     `OOPSLA '96 Proceedings'.  (`ACM SIGPLAN Notices', 31(10):268-285,
     October, 1996.)

[Tan95]
     Yang Meng Tan.  `Formal Specification Techniques for Engineering
     Modular C Programs'.  International Series in Software Engineering
     (Kluwer Academic Publishers, Boston, 1995).  Also published as
     Formal Specification Techniques for Promoting Software Modularity,
     Enhancing Documentation, and Testing Specifications.  Technical
     Report TR-619, MIT Lab. for Comp. Sci., June 1994.

[Watt91]
     David A. Watt.  `Programming Language Syntax and Semantics'.
     Prentice Hall, International Series in Computer Science, New York,
     1991.

[Wills92b]
     Alan Wills.  Specification in Fresco.  In Susan Stepney and
     Rosalind Barden and David Cooper (eds.), `Object Orientation in
     Z', chapter 11, pages 127-135.  Springer-Verlag, Workshops in
     Computing Series, Cambridge CB2 1LQ, UK, 1992.

[Wing83]
     Jeannette Marie Wing.  `A Two-Tiered Approach to Specifying
     Programs' Technical Report TR-299, Mass. Institute of Technology,
     Laboratory for Computer Science, 1983.

[Wing87]
     Jeannette M. Wing.  Writing Larch Interface Language
     Specifications.  `ACM Transactions on Programming Languages and
     Systems', 9(1):1-24, January 1987.

[Wing90a]
     Jeannette M. Wing.  A Specifier's Introduction to Formal Methods.
     `Computer', 23(9):8-24, September 1990.


File: jmlrefman.info,  Node: Example Index,  Next: Concept Index,  Prev: Bibliography,  Up: Top

Example Index
*************

 [index ]
* Menu:

* Constraint:                            Constraints.          (line 35)
* Directory:                             Ideas Behind Model Programs.
                                                               (line 26)
* Diverges:                              Diverges Clauses.     (line 32)
* GhostLocals:                           Modifiers for Local Declarations.
                                                               (line 41)
* Heavyweight:                           Lightweight Specification Cases.
                                                               (line 65)
* ImplicitOld:                           Parameters in Postconditions.
                                                               (line 42)
* InconsistentMethodSpec:                Pragmatics of Exceptional Behavior Specification Cases.
                                                               (line 15)
* InconsistentMethodSpec2:               Pragmatics of Exceptional Behavior Specification Cases.
                                                               (line 43)
* IntHeap:                               A First Example.      (line 12)
* Invariant:                             Invariants.           (line 18)
* Lightweight:                           Lightweight Specification Cases.
                                                               (line 49)
* PrivacyDemoLegalAndIllegal:            Privacy Modifiers and Visibility.
                                                               (line 71)
* RefineDemo.java:                       Default Constructor Refinement.
                                                               (line 38)
* RefineDemo.jml:                        Default Constructor Refinement.
                                                               (line 26)
* RefineDemo.jml-refined:                Default Constructor Refinement.
                                                               (line 14)
* RefineDemo2.java:                      Default Constructor Refinement.
                                                               (line 91)
* RefineDemo2.jml:                       Default Constructor Refinement.
                                                               (line 75)
* RefineDemo2.jml-refined:               Default Constructor Refinement.
                                                               (line 67)
* SignalsClause:                         Pragmatics of Exceptional Behavior Specification Cases.
                                                               (line 74)
* SumArrayLoop:                          Loop Statements.      (line 28)

